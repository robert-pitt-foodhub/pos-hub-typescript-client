/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * POS Hub API
 * ## Introduction

Welcome to the POS Hub API documentation. This guide is designed to provide you with all the necessary information to seamlessly integrate your application with the POS Hub platform. Whether you're integrating a point-of-sale system, a reporting tool, an order management system, or any other application that interacts with the POS Hub API, this documentation will serve as your comprehensive resource.

Within this documentation, you will find detailed explanations of the API standards, authentication processes, common integration patterns, and pagination techniques employed by the POS Hub API. We will guide you through the steps of authenticating your application, making authenticated requests, and managing token expiration and refresh processes.

By following this documentation, you will be able to harness the full potential of the POS Hub API to optimize your business operations, access valuable data, and deliver a seamless experience to your users.

Let‚Äôs get started!

## API

The API section provides a thorough overview of the standards adhered to by the POS Hub API. These standards are in place to ensure consistency and compatibility across all endpoints.

### API Features

- Detailed documentation is generated directly from our implementation code, ensuring accuracy and up-to-date information.
- OAuth2 standards are used for authenticating users and applications, as well as performing application onboarding via the authorization flow.
- Resource-oriented endpoints provide GET, POST, PUT, PATCH, and DELETE functionality across various entities.
- All HTTP communication is conducted exclusively over SSL, both internally between systems and externally with partners.
- Requests and responses are strictly formatted using application/json, including all error responses.
- Our endpoints support cursor-based pagination, enabling efficient data retrieval within a resource.
- We adhere to relevant ISO standards for common values, including ISO 8601 for dates/times, ISO 4217 for currency codes, and ISO 639-1 for language codes and E.164 to represent global phone numbers.

### API Contracts

It is important to understand that the POS Hub API defines schemas for both request, response and webhook payloads. These schemas serve as a contract between POS Hub and API consumers. Compliance with these schemas is crucial, as all fields, data types, required flags, enumerations, and other specifications are validated against this documentation. Careful adherence to this documentation is essential for successful integration with our API.

Our schemas define the following information:

- Property Names: (e.g., orderId, status)
- Property Types: (e.g., string, number, boolean, or another schema)
- Allowed Values: Specified by enumeration tags
- String Length and Numeric Size: Minimum and maximum values
- Value Formatting: Such as uuid, uri, or date-time
- Field Requirements: Required or optional fields

### Authentication

There are multiple methods of authentication depending on what your trying to, typically applications will be using the `client_credentials` flow, however we have outlined the different types below.

#### Password Grant

the `password` grant type is used if you as the account owner wishes to authenticate to gain user level access, this requires a username and password to autheneticate, this is useful for resellers who wish to build in house custom tooling, allowing them to create a user within the reseller and authenticate to perform api calls as that user.

Note: the `password` grant requires POS Hub team to authorize this grant for your application, this is typically only done for enterprise customers, if you need this grant please reach out to one of our team.

#### Client Credentials Grant

the `client_credentials` grant os the grant used when an application wishes to get an an application level access token, this is by applications that need to perform authenticated requests on a location, such as inject an order, update a catalog or pull a menu.

Application credentials allows the application acces to all the locations that it has been authorized for, and the access is further limited to the scopes that the application is allowed and/or requested within the token request.

Example Request

```shell
curl -X POST -H "Content-Type: application/x-www-form-urlencoded" -d "grant_type=client_credentials&client_id=<CLIENT_ID>&client_secret=<CLIENT_SECRET>" "{path}/oauth2/token"
```

Example Response

```json
{ "access_token": "[access-token]", "token_type": "Bearer", "expires_in": 3600 }
```

#### Authorization Code Grant

The `authorization_code` grant is used when an application wishes to initiate the onboarding to a location, the application will prepare an
`/authorize` url which will inlcude the client id, client secret, redirect uri and required scopes, the application should redirect the user to the authoization url, once the user has been redirect to the url, they will be promted to authenticate and authorize your acccess to a selected location of their choosing.

Once the user has authorzed the request, they will be redirected back to the redirect uri with an intermediate token called the `code`, this code contains the users intent to authorize your application, taking this `code` property you can make a follow up call to the token endpoint with this intermediate code
to complete the onboarding steps.

Once the authorization flow us complete, the aplication credentials that are generated with the `client_credentials` flow will now have permission for this new store.

### Client Registration

Before your application can authenticate and access the POS Hub API, you must first create an application within your [POS Hub Developer's](https://tryposhub.com) area. Once your application is created, you will be issued a unique client ID and client secret, which are essential credentials for establishing a secure connection with the API. These credentials ensure that only authorized applications can interact with the POS Hub API, maintaining the integrity and privacy of your data.

### API Security Defintions

<SecurityDefinitions />

### Authenticating Requests

To securely access the POS Hub API, you need to include a valid access token in the Authorization header of your API requests. This access token allows your application to interact with API resources and perform operations on behalf of the user.

To include the access token in your requests, use the Bearer token type in the Authorization header:

```
Authorization: Bearer [access-token]
```

Here's an example of an authenticated request to retrieve a list of orders for an onboarded application:

```
curl -X GET https://api.trypos hub.com/accounts/{accountId}/locations/{locationId}/order/{orderId} \
  -H "Authorization: Bearer [access-token]"
```

**Note: Replace [access-token] with the actual access token you received in the token response.**

### Refresh Token Grant Flow

To ensure secure and uninterrupted access to the POS Hub API, it's important to understand and utilize the refresh token grant flow. This flow allows you to obtain new access tokens without the need to provide client credentials again.

When you obtain an access token through the client credentials grant flow, it has a limited lifespan for security reasons. The duration of the token's validity is typically set to 1 hour, as indicated by the "expires_in" field in the response.

To refresh an expiring access token, your application should make a token refresh request to the `/oauth2/token` endpoint using the refresh token grant type. This request will provide you with a new access token and a new refresh token.

Once you receive the new tokens, replace the old access token and refresh token in your authenticated requests with the new ones. This ensures seamless access to the POS Hub API without interruption.

By proactively managing token expiration and utilizing the refresh token grant flow, you can maintain secure and continuous access to authorized resources in your integrations with the POS Hub API.

## Common Patterns

Our API Is designed to have common and consistent patterns across all the endpoints, patterns such as pagination, filtering, and response envolopes.

### Response

There are two types of responses this API produces:

1. Object Response
   An object response is the structure that is returned when you working with a single item, such as an GET, POST, PUT or patch on an endpoint that ends with an id parameter, such as `/v1/accounts/{accountId}`, these response will always return a JSON Object with a single data field, the value of the data field is the single object you are reading or mutating.

2. List Response
   A list response is the structure that is returned when your working with list of items, such as a `GET` request on an api endpoint that returns a list of objects, such as `/v1/accounts` or `/v1/accounts/{accountId}/locations`.

The fields in the response are:

| property    | description                                                                                                                      |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------- |
| nextPageKey | A `string` that contains a unique pagination key, this can be passed back to the api on subsequent events to fetch the next page |
| hasNextPage | A `boolean` flag that indicates if there is another page of data available based on your current query request                   |
| data        | A `Array<Entity>` list that has the list of entities within the current page of data                                             |

### Pagination

POS Hub employs "Cursor-Based Pagination" instead of the traditional "Offset-Based Pagination" for several key reasons:

1. **Efficiency:** Cursor-based pagination offers faster and more efficient data retrieval, particularly with large datasets. Unlike offset-based pagination, which skips a fixed number of records, cursor-based pagination retrieves the next set of records using a unique identifier (cursor). This approach avoids the overhead of scanning through and skipping records, leading to quicker response times.

2. **Stability:** Cursor-based pagination is more reliable with frequently changing data. In offset-based pagination, adding or removing records between requests can lead to inconsistent results. Cursor-based pagination uses unique cursors, ensuring data remains consistent and accurate even if changes occur.

3. **Predictability:** Cursor-based pagination provides predictable results. When requesting the next page of data using a cursor, you will receive the same records as long as the dataset remains unchanged. This predictability is essential for maintaining data integrity and consistency in your applications.

### Example Flow of Cursor-Based Pagination

1. **Initial Request:** Specify the number of records per page and any filters or sorting criteria in your initial API request. The API will respond with the first page of results and provide a cursor indicating where the next page begins.

```bash
curl -X GET -H "Authorization: Bearer [access-token]" "{path}/orders?limit=10"
```

**Response:**

```json
{ "data": [...], "hasNextPage": true, "nextPageKey": "[next-page-token]" }
```

2. **Subsequent Requests:** To retrieve the next page of results, use the `nextPageKey` value from the previous response in your next request.

```bash
curl -X GET -H "Authorization: Bearer [access-token]" "{path}/orders?limit=10&nextPageKey=[next-page-token]"
```

**Response:**

```json
{ "data": [...], "hasNextPage": true, "nextPageKey": "[next-page-token]" }
```

3. **Repeat:** Continue retrieving subsequent pages by including the `nextPageKey` in your requests until no more pages are available (i.e., `hasNextPage` is false or `nextPageKey` is not present).

 * OpenAPI spec version: 1.8.9.5
 */
export type CatalogModifierGroupCreateEntityModifiersItem = {
  /**
   * Catalog Modifier Price
   * @minimum 0
   * @maximum 999999999
   */
  price: number;
  /** Catalog Modifier Name */
  name: string;
  /** Catalog Modifier ID (must already exists) */
  id: string;
};

export interface CatalogModifierGroupCreateEntity {
  /**
   * Maximum number of items that must be selected (inclusive)
   * @minimum 0
   */
  maxPermitted?: number;
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Modifier Group Name */
  name: string;
  /** Catalog Modifier Group Description */
  description?: string;
  /** Unique POS Reference ID */
  posReference: string;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  /** Position of the catalog modifier group */
  position?: number;
  /** @minItems 0 */
  modifiers: CatalogModifierGroupCreateEntityModifiersItem[];
}

/**
 * Separated components of the address.
 */
export type AddressAddressComponents = {
  /** Area or locality within the city. */
  area?: string;
  /** Country name. */
  country?: string;
  /** Flat or apartment number. */
  flatNo?: string;
  /** City name. */
  city?: string;
  /** Postal or ZIP code. */
  postalCode?: string;
  /** House number. */
  houseNo?: string;
  /** Street name or primary address line. */
  addressLine1?: string;
  /** Additional address details (e.g., suite, unit). */
  addressLine2?: string;
  /** State or province name. */
  state?: string;
};

export interface Address {
  /** Full customer address. */
  address: string;
  /** Google Place ID associated with the address. */
  googlePlaceId?: string;
  /**
   * Geographic latitude of the address.
   * @minimum -90
   * @maximum 90
   */
  latitude?: number;
  /** Separated components of the address. */
  addressComponents?: AddressAddressComponents;
  /**
   * Geographic longitude of the address.
   * @minimum -180
   * @maximum 180
   */
  longitude?: number;
}

export interface ListAccountMenuItemByIdResponse {
  data?: MenuItemEntity;
}

export interface CatalogProductSelection {
  /**
   * Maximum number of items that must be selected (inclusive)
   * @minimum 0
   * @maximum 100
   */
  maxPermitted?: number;
  /** Catalog Modifier Group Identifier */
  catalogModifierGroupId: string;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  modifiers?: CatalogProductSelectionModifier[];
}

/**
 * Payment Name
 */
export type OrderPaymentName = typeof OrderPaymentName[keyof typeof OrderPaymentName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderPaymentName = {
  CARD: 'CARD',
  CASH: 'CASH',
  OTHER: 'OTHER',
} as const;

/**
 * Order Payment Details
 */
export interface OrderPayment {
  /** Payment Amount */
  amount: number;
  /** Payment Name */
  name: OrderPaymentName;
}

/**
 * An ISO 4217 Currency Code.
 */
export type CurrencyCode = typeof CurrencyCode[keyof typeof CurrencyCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CurrencyCode = {
  GBP: 'GBP',
  USD: 'USD',
  EUR: 'EUR',
  NZD: 'NZD',
  AUD: 'AUD',
  CAD: 'CAD',
} as const;

/**
 * The reason for the cancellation of the order. This field is required when the status is CANCELLED.
 */
export type OrderCancelReason = typeof OrderCancelReason[keyof typeof OrderCancelReason];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderCancelReason = {
  OUT_OF_STOCK: 'OUT_OF_STOCK',
  STORE_CLOSED: 'STORE_CLOSED',
  TOO_BUSY: 'TOO_BUSY',
  CUSTOMER_CANCELLED: 'CUSTOMER_CANCELLED',
  OTHER: 'OTHER',
} as const;

/**
 * The strategy to use when auto selecting a quote for dispatch
 */
export type LocationCreateEntityDeliveryAutoDispatchSelectionStrategy = typeof LocationCreateEntityDeliveryAutoDispatchSelectionStrategy[keyof typeof LocationCreateEntityDeliveryAutoDispatchSelectionStrategy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LocationCreateEntityDeliveryAutoDispatchSelectionStrategy = {
  PRICE: 'PRICE',
  RANK: 'RANK',
} as const;

/**
 * Reference to the schema defining the business hours.
 */
export type LocationCreateEntityAvailability = {
  delivery?: ServiceAvailability;
  collection?: ServiceAvailability;
};

/**
 * The default action to take when a delivery fails (e.g., "RETURN" or "DISPOSE").
 */
export type LocationCreateEntityDeliveryDefaultFailureAction = typeof LocationCreateEntityDeliveryDefaultFailureAction[keyof typeof LocationCreateEntityDeliveryDefaultFailureAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LocationCreateEntityDeliveryDefaultFailureAction = {
  RETURN: 'RETURN',
  DISPOSE: 'DISPOSE',
} as const;

export interface LocationCreateEntity {
  /**
   * The number of seconds after the order has "started" that the order should be auto closed. This is only applicable if autoCloseOrders is enabled. (max: 24 hours, default is 3 hours)
   * @minimum 1800
   * @maximum 86400
   */
  autoCloseOrdersAfter?: number;
  /** Contact Person's Last Name */
  lastName?: string;
  /** The strategy to use when auto selecting a quote for dispatch */
  deliveryAutoDispatchSelectionStrategy?: LocationCreateEntityDeliveryAutoDispatchSelectionStrategy;
  /** Timezone of the location (e.g., "Europe/London"). */
  timezone: string;
  /** Reference to the schema defining the business hours. */
  availability?: LocationCreateEntityAvailability;
  /** A list of application ids that determine the rank (when RANK selection strategy is used) */
  deliveryAutoDispatchSelectionRanking?: string[];
  /** When enabled, a delivery will be created automatically for self delivery orders */
  autoCreateDeliveryOnDeliveryOrder?: boolean;
  /** List of tax rates applicable to the location */
  taxRates?: TaxRate[];
  countryCode?: CountryCode;
  currency?: CurrencyCode;
  /** List of payment types accepted at the location */
  paymentTypes?: PaymentType[];
  /** Contact Person's Email Address */
  email?: string;
  /** The default action to take when a delivery fails (e.g., "RETURN" or "DISPOSE"). */
  deliveryDefaultFailureAction?: LocationCreateEntityDeliveryDefaultFailureAction;
  address: Address;
  /** Indicates if orders should be automatically closed after a certain period of time. For ASAP orders, this is the time when the order was received; for scheduled orders, this is the scheduled time. */
  autoCloseOrders?: boolean;
  /** When enabled, if the first provider fails to honor the pickup time we will search for another provider */
  deliveryAutoDispatchFailoverEnabled?: boolean;
  businessHours?: ServiceAvailability;
  /** Indicates if deliveries should be automatically dispatched when created. */
  deliveryAutoDispatchEnabled?: boolean;
  /** Contact Person's First Name */
  firstName?: string;
  /** Valid E.164 phone number (e.g., +14155552671). */
  phoneNumber: string;
  /**
   * The number of seconds after the estimated pickup time to trigger the auto dispatch
   * @minimum 0
   * @maximum 900
   */
  deliveryAutoDispatchFailoverGraceTime?: number;
  /** Name of the location (e.g., "Acme Inc - London"). */
  name: string;
  /** Default instructions for the pickup location. */
  deliveryDefaultPickupInstructions?: string;
  /** Indicates if proof of delivery is required by default for deliveries. */
  deliveryDefaultProofRequired?: boolean;
  /** The identifier for this location within the POS system. */
  posReference?: string;
}

/**
 * Details about the driver's vehicle.
 */
export type OrderDriverVehicle = {
  /** Vehicle color. */
  color?: string;
  /** Publicly accessible tracking URL for the current driver */
  trackingUrl?: string;
  /** Current latitude of the driver. */
  latitude?: number;
  /** Vehicle model (e.g., Camry, Civic). */
  model?: string;
  /** Vehicle manufacturer (e.g., Toyota, Honda). */
  make?: string;
  /** Current longitude of the driver. */
  longitude?: number;
};

/**
 * Order Driver
 */
export interface OrderDriver {
  /** Driver's first name. */
  firstName: string;
  /** Driver's last name. */
  lastName?: string;
  /** Driver's contact phone number. */
  phoneNumber?: string;
  /** Unique identifier for the driver */
  driverReference?: string;
  /** Details about the driver's vehicle. */
  vehicle?: OrderDriverVehicle;
}

/**
 * The type of grant being requested by the application.
 */
export type TokenRequestGrantType = typeof TokenRequestGrantType[keyof typeof TokenRequestGrantType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TokenRequestGrantType = {
  client_credentials: 'client_credentials',
  password: 'password',
  refresh_token: 'refresh_token',
  authorization_code: 'authorization_code',
  otp: 'otp',
} as const;

export interface TokenRequest {
  /** The resource owner password. */
  password?: string;
  /** The type of grant being requested by the application. */
  grant_type: TokenRequestGrantType;
  /** The resource owner phone number. */
  phone?: string;
  /** The scope of the access request. */
  scope?: string;
  /** The client secret issued to the client during the registration process (note: this should only be sent from server side.) */
  client_secret?: string;
  /** The client identifier issued to the client during the registration process. */
  client_id: string;
  /** The resource owner username. */
  username?: string;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListCatalogModifiersResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: CatalogModifierEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

export interface CatalogCategoryEntity {
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Category Description */
  description?: string;
  /** An external url to the original image from the POS */
  originalImageUrl?: string;
  /** Account Identifier */
  accountId: string;
  /** Catalog Category created at timestamp */
  createdAt: string;
  /** Catalog Category Show Online */
  showOnline?: boolean;
  /** Location Identifier */
  locationId: string;
  /** Catalog Category Image URL */
  imageUrl?: string;
  /** Catalog Category Name */
  name: string;
  /** Unique POS Reference ID */
  posReference: string;
  /** Catalog Category Identifier */
  id: string;
  /** Position of catalog category within list of categories */
  position?: number;
  /** Catalog Category updated at timestamp */
  updatedAt: string;
}

/**
 * Charge Name: (e.g: DELIVERY or SERVICE)
 */
export type OrderChargeName = typeof OrderChargeName[keyof typeof OrderChargeName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderChargeName = {
  DELIVERY: 'DELIVERY',
  SERVICE: 'SERVICE',
  OTHER: 'OTHER',
  DRIVER_TIP: 'DRIVER_TIP',
  RESTAURANT_TIP: 'RESTAURANT_TIP',
} as const;

/**
 * Order Charge
 */
export interface OrderCharge {
  /** Charge Amount: (e.g: 1000 = ¬£10.00) */
  amount: number;
  /** Display name */
  displayName?: string;
  /** Charge Name: (e.g: DELIVERY or SERVICE) */
  name: OrderChargeName;
}

export interface MenuCategoryPatchEntity {
  /** Category Show Online */
  showOnline?: boolean;
  /** Category Description */
  catalogCategoryId?: string;
  /** Menu Category Image */
  imageUrl?: string;
  /** Category Name */
  name?: string;
  /** Category Description */
  description?: string;
  /** Position of category within list of categories */
  position?: number;
}

/**
 * Fulfillment Types.
 */
export type FulfillmentType = typeof FulfillmentType[keyof typeof FulfillmentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const FulfillmentType = {
  DELIVERY: 'DELIVERY',
  PICKUP: 'PICKUP',
  'DINE-IN': 'DINE-IN',
  WAITING: 'WAITING',
  IN_STORE: 'IN_STORE',
} as const;

/**
 * Type of product, either product, variant or modifier
 */
export type MenuItemVariantEntityType = typeof MenuItemVariantEntityType[keyof typeof MenuItemVariantEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MenuItemVariantEntityType = {
  PRODUCT: 'PRODUCT',
  VARIANT: 'VARIANT',
  MODIFIER: 'MODIFIER',
} as const;

export interface MenuItemVariantEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Whether the menu item contains alcohol */
  containsAlcohol?: boolean;
  /** Identifier of the catalog product this variation corresponds to */
  catalogProductId?: string;
  /** Variant Description */
  description?: string;
  fulfillmentTypes?: FulfillmentTypes;
  /** Type of product, either product, variant or modifier */
  type?: MenuItemVariantEntityType;
  /** Ids of menu modifier groups the variant is mapped to */
  modifierGroups?: string[];
  /** Menu Variant Parent Identifier */
  parentId?: string;
  /** Account Identifier */
  accountId?: string;
  /** ISO 8601 timestamp of when the item was created */
  createdAt?: string;
  /** Whether the menu item is bike friendly */
  isBikeFriendly?: boolean;
  /** Variant Show Online */
  showOnline?: boolean;
  /**
   * Variant Price
   * @minimum 0
   * @maximum 999999999
   */
  price?: number;
  /** Location ID to which this menu is associated with */
  locationId?: string;
  /** Variant Image */
  imageUrl?: string;
  /** Variation Name */
  name?: string;
  /** Whether the menu item contains tobacco */
  containsTobacco?: boolean;
  /** The menu id in which this item belongs to */
  menuId?: string;
  serviceAvailability?: ServiceAvailability;
  /** The identifier of the item */
  id?: string;
  /** Ids of menu categories the variant is mapped to */
  categories?: string[];
  /** Position of item within list of items */
  position?: number;
  /**
   * When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders.
   * @minimum 0
   * @maximum 999999999
   */
  inStorePrice?: number;
  /** ISO 8601 timestamp of when the item was updated */
  updatedAt?: string;
}

export interface GetApplicationByIdResponse {
  data?: ApplicationEntity;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListAccountCatalogModifierGroupsResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: CatalogModifierGroupEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

export type ApplicationScopesItem = typeof ApplicationScopesItem[keyof typeof ApplicationScopesItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationScopesItem = {
  accountsread: 'accounts.read',
  accountswrite: 'accounts.write',
  locationsread: 'locations.read',
  locationswrite: 'locations.write',
  catalogsread: 'catalogs.read',
  catalogswrite: 'catalogs.write',
  ordersread: 'orders.read',
  orderswrite: 'orders.write',
  deliveriesread: 'deliveries.read',
  deliverieswrite: 'deliveries.write',
  resellersread: 'resellers.read',
  resellerswrite: 'resellers.write',
  userread: 'user.read',
  userwrite: 'user.write',
} as const;

/**
 * Scope Identifier
 */
export type ApplicationScopes = ApplicationScopesItem[];

export interface MenuModifierCreateEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Catalog Modifier ID */
  catalogModifierId: string;
  /** Menu Modifier Contains Alcohol */
  containsAlcohol?: boolean;
  /** Maximum number of items that must be selected (inclusive) */
  maxPermitted?: number;
  /** Menu Modifier Description */
  description: string;
  /** Menu Modifier is Bike Friendly */
  isBikeFriendly?: boolean;
  /** Menu Modifier Online Availability */
  showOnline?: boolean;
  /** Menu Modifier Price */
  price: number;
  /** Image URL of the modifier */
  imageUrl?: string;
  /** Menu Modifier Name */
  name: string;
  /** Menu Modifier Contains Tabacco */
  containsTobacco?: boolean;
  /** Position of the menu modifier */
  position?: number;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  /** When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders. */
  inStorePrice?: number;
}

export interface MenuCategoryCreateEntity {
  /** Category Show Online */
  showOnline?: boolean;
  /** Category Description */
  catalogCategoryId?: string;
  /** Menu Category Image */
  imageUrl?: string;
  /** Category Name */
  name: string;
  /** Category Description */
  description: string;
  /** Position of category within list of categories */
  position?: number;
}

/**
 * Application Patch Entity
 */
export interface ApplicationPatchEntity {
  /** URL for dispatching a delivery quote (applicable only for DELIVERY applications). */
  dispatchDeliveryQuoteUrl?: string;
  /** URL for cancelling a dispatched delivery (applicable only for DELIVERY applications). */
  cancelDeliveryUrl?: string;
  /** URL for getting the latest details for adispatched delivery (applicable only for DELIVERY applications). */
  getDeliveryUrl?: string;
  /** URL for catalog synchronization (only used for POS applications). */
  catalogSyncUrl?: string;
  /** Display name of the application. */
  name?: string;
  /** Brief description of the application. */
  description?: string;
  /** URL for menu publication (if applicable). */
  menuPublicationUrl?: string;
  /** List of allowed countries this application can be used in. */
  allowedCountries?: CountryCode[];
  scopes?: ApplicationScopes;
  /** Webhook endpoint URL for the application. */
  webhookEndpoint?: string;
  /** List of redirect URIs permitted for this application. */
  redirectUris?: string[];
  /** URL for getting delivery quotes for a given delivery (applicable only for DELIVERY applications). */
  getDeliveryQuoteUrl?: string;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListApplicationsResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: ApplicationEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

/**
 * The current status of the driver assigned to the delivery.
 */
export type OrderPatchEntityDriverStatus = typeof OrderPatchEntityDriverStatus[keyof typeof OrderPatchEntityDriverStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderPatchEntityDriverStatus = {
  UNASSIGNED: 'UNASSIGNED',
  ASSIGNED: 'ASSIGNED',
  ON_ROUTE_TO_PICKUP: 'ON_ROUTE_TO_PICKUP',
  AT_PICKUP: 'AT_PICKUP',
  ON_ROUTE_TO_DROP_OFF: 'ON_ROUTE_TO_DROP_OFF',
  AT_DROP_OFF: 'AT_DROP_OFF',
  RETURNING: 'RETURNING',
  RETURNED: 'RETURNED',
  COMPLETED: 'COMPLETED',
} as const;

export interface OrderPatchEntity {
  driver?: OrderDriver;
  cancellationReason?: OrderCancelReason;
  /** The current status of the driver assigned to the delivery. */
  driverStatus?: OrderPatchEntityDriverStatus;
  status?: OrderStatus;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListAccountMenuModifierGroupsResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: MenuModifierGroupEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

export interface AccountMenuModifierGroupByIdResponse {
  data?: MenuModifierGroupEntity;
}

export interface UserEntity {
  /** Identifier for the associated reseller. */
  resellerId: string;
  /** User's first name. */
  firstName: string;
  /** User's last name. */
  lastName: string;
  /** Indicates whether the user's email address is verified. */
  emailVerified: boolean;
  /** Timestamp when the user was created. */
  createdAt: string;
  /** User's phone number. (E.164 format) */
  phone?: string;
  /** Indicates whether the user's phone number is verified. */
  phoneVerified: boolean;
  language: LanguageCode;
  /** Unique identifier for the user. */
  id: string;
  accounts: string[];
  /** User's email address. */
  email: string;
  /** Timestamp when the user was last updated. */
  updatedAt: string;
}

export interface CatalogCategoryPatchEntity {
  /** An external url to the original image from the POS */
  originalImageUrl?: string;
  /** Catalog Category Show Online */
  showOnline?: boolean;
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Category Name */
  name?: string;
  /** Catalog Category Description */
  description?: string;
  /** Position of catalog category within list of categories */
  position?: number;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListCatalogCategoriesResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: CatalogCategoryEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

/**
 * Type of the vehicle used for the delivery.
 */
export type DeliveryDispatchDriverVehicleType = typeof DeliveryDispatchDriverVehicleType[keyof typeof DeliveryDispatchDriverVehicleType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryDispatchDriverVehicleType = {
  BYCYCLE: 'BYCYCLE',
  SCOOTER: 'SCOOTER',
  MOTORCYCLE: 'MOTORCYCLE',
  CAR: 'CAR',
  OTHER: 'OTHER',
} as const;

/**
 * The current status of the driver assigned to the delivery.
 */
export type DeliveryDispatchDriverStatus = typeof DeliveryDispatchDriverStatus[keyof typeof DeliveryDispatchDriverStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryDispatchDriverStatus = {
  UNASSIGNED: 'UNASSIGNED',
  ASSIGNED: 'ASSIGNED',
  ON_ROUTE_TO_PICKUP: 'ON_ROUTE_TO_PICKUP',
  AT_PICKUP: 'AT_PICKUP',
  ON_ROUTE_TO_DROP_OFF: 'ON_ROUTE_TO_DROP_OFF',
  AT_DROP_OFF: 'AT_DROP_OFF',
  RETURNING: 'RETURNING',
  RETURNED: 'RETURNED',
  COMPLETED: 'COMPLETED',
} as const;

export interface DeliveryDispatch {
  /** Model of the vehicle used for the delivery, example "Model S". */
  driverVehicleModel?: string;
  /** Publicly accessable tracking URL for the current driver */
  trackingUrl?: string;
  /** Time the delivery was last updated */
  lastUpdatedAt?: string;
  /** Type of the vehicle used for the delivery. */
  driverVehicleType?: DeliveryDispatchDriverVehicleType;
  /** Make of the vehicle used for the delivery, example "Tesla". */
  driverVehicleMake?: string;
  /**
   * Latitude of the driver location.
   * @minimum -90
   * @maximum 90
   */
  driverLatitude?: number;
  /** Unique ID provided by the application for the delivery, this should be returned during the dispatch delivery request */
  dispatchedId: string;
  /** Phone number of the assigned driver (format E.164). */
  driverPhoneNumber?: string;
  /** Color of the vehicle used for the delivery, example "red". */
  driverVehicleColor?: string;
  /** The current status of the driver assigned to the delivery. */
  driverStatus: DeliveryDispatchDriverStatus;
  /** A pin number used when contacting the driver via a shared phone number. */
  driverPhonePin?: string;
  /**
   * Longitude of the driver location.
   * @minimum -180
   * @maximum 180
   */
  driverLongitude?: number;
  /** Unique ID provided by the application for the delivery quote, this should be returned during the get delivery quote request */
  quoteId: string;
  /** Actual time the driver arrived at the dropoff location */
  actualDropoffTime?: string;
  /** Actual time the driver arrived at the pickup location */
  actualPickupTime?: string;
  /** Time the delivery was dispatched */
  dispatchedAt: string;
  /** Price of the delivery quote, in the lowest denomination of the currency */
  price: number;
  /** Estimated time for the driver to arrive at the dropoff location */
  estimatedDropoffTime?: string;
  /** The drivers public display name. */
  driverName?: string;
  /** Application ID that provided the delivery quote */
  applicationId: string;
  /** Application name that provided the delivery quote */
  applicationName: string;
  /** Estimated time for the driver to arrive at the pickup location */
  estimatedPickupTime?: string;
  /** License plate of the vehicle used for the delivery. */
  driverVehicleLicensePlate?: string;
}

export interface GetUserByIdResponse {
  data?: UserEntity;
}

/**
 * Action the driver should take with the order contents when the delivery status is FAILED.
 */
export type DeliveryCreateEntityFailureAction = typeof DeliveryCreateEntityFailureAction[keyof typeof DeliveryCreateEntityFailureAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryCreateEntityFailureAction = {
  RETURN: 'RETURN',
  DISPOSE: 'DISPOSE',
} as const;

export type DeliveryCreateEntityDropoff = {
  instructions?: string;
  address: Address;
  contactName: string;
  contactPhone: string;
};

export type DeliveryCreateEntityPickup = {
  instructions?: string;
  address: Address;
  contactName: string;
  contactPhone: string;
};

/**
 * The mode of delivery that is being requested for the delivery.
 */
export type DeliveryCreateEntityDeliveryMode = typeof DeliveryCreateEntityDeliveryMode[keyof typeof DeliveryCreateEntityDeliveryMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryCreateEntityDeliveryMode = {
  ASAP: 'ASAP',
  SCHEDULED: 'SCHEDULED',
} as const;

/**
 * The strategy to use when auto selecting a quote for dispatch
 */
export type DeliveryCreateEntityAutoDispatchSelectionStrategy = typeof DeliveryCreateEntityAutoDispatchSelectionStrategy[keyof typeof DeliveryCreateEntityAutoDispatchSelectionStrategy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryCreateEntityAutoDispatchSelectionStrategy = {
  PRICE: 'PRICE',
  RANK: 'RANK',
} as const;

export interface DeliveryCreateEntity {
  /** If provided, this confirmation code will be used by the delviery driver to confirm the delivery. */
  confirmationCode?: string;
  package: DeliveryPackage;
  /** Action the driver should take with the order contents when the delivery status is FAILED. */
  failureAction: DeliveryCreateEntityFailureAction;
  /** Optional order ID associated with the delivery, if applicable. this id must be owned by the specified locationId */
  orderId?: string;
  dropoff: DeliveryCreateEntityDropoff;
  pickup: DeliveryCreateEntityPickup;
  /** When enabled, if the first provider fails to honor the pickup time we will search for another provider */
  autoDispatchFailoverEnabled?: boolean;
  /**
   * The number of seconds after the estimated pickup time to trigger the auto dispatch
   * @minimum 0
   * @maximum 900
   */
  autoDispatchFailoverGraceTime?: number;
  /** A list of application ids that determine the rank (when RANK selection strategy is used) */
  autoDispatchSelectionRanking?: string[];
  /** The account ID of the location the delivery is for. */
  accountId: string;
  /** The mode of delivery that is being requested for the delivery. */
  deliveryMode: DeliveryCreateEntityDeliveryMode;
  /** The location ID the delivery is for (must be apart of the account specified within accountId). */
  locationId: string;
  /** When true, the delivery will be automatically dispatched based on the location preferences. */
  autoDispatchEnabled?: boolean;
  /** The estimated time for the driver to arrive at the dropoff location. */
  estimatedDropoffTime?: string;
  /** When true, the driver should be requested to provide proof of delivery, typically in the form of an image or confirmation code. */
  proofRequired: boolean;
  /** The strategy to use when auto selecting a quote for dispatch */
  autoDispatchSelectionStrategy?: DeliveryCreateEntityAutoDispatchSelectionStrategy;
  /** The estimated time for the driver to arrive at the pickup location. */
  estimatedPickupTime?: string;
}

/**
 * Type of product, either product, variant or modifier
 */
export type CatalogProductCreateEntityType = typeof CatalogProductCreateEntityType[keyof typeof CatalogProductCreateEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogProductCreateEntityType = {
  PRODUCT: 'PRODUCT',
  VARIANT: 'VARIANT',
  MODIFIER: 'MODIFIER',
} as const;

/**
 * Catalog Variant Parent Identifier
 */
export type CatalogProductCreateEntityParentId = { [key: string]: unknown };

export interface CatalogProductCreateEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Catalog Product Contains Alcohol */
  containsAlcohol?: boolean;
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Product Description */
  description?: string;
  /** Type of product, either product, variant or modifier */
  type?: CatalogProductCreateEntityType;
  /** Ids of catalog modifier groups the item is mapped to */
  modifierGroups: string[];
  /** Catalog Variant Parent Identifier */
  parentId?: CatalogProductCreateEntityParentId;
  /** An external url to the original image from the POS */
  originalImageUrl?: string;
  /** Catalog Product is Bike Friendly */
  isBikeFriendly?: boolean;
  /** Catalog Product Show Online */
  showOnline: boolean;
  /** Selections for the product */
  selections?: CatalogProductSelection[];
  /**
   * Catalog Product Price
   * @minimum 0
   * @maximum 999999999
   */
  price: number;
  /** Catalog Product Name */
  name: string;
  /** Catalog Product Contains Tabacco */
  containsTobacco?: boolean;
  serviceAvailability?: ServiceAvailability;
  /** POS Product Reference */
  posReference: string;
  /** Ids of catalog categories the item is mapped to */
  categories: string[];
  /** Position of the catalog product */
  position?: number;
  /**
   * When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders.
   * @minimum 0
   * @maximum 999999999
   */
  inStorePrice?: number;
}

/**
 * Delivery type
 */
export type OrderCreateEntityDeliveryDeliveryType = typeof OrderCreateEntityDeliveryDeliveryType[keyof typeof OrderCreateEntityDeliveryDeliveryType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderCreateEntityDeliveryDeliveryType = {
  SELF_DELIVERY: 'SELF_DELIVERY',
  PARTNER_DELIVERY: 'PARTNER_DELIVERY',
} as const;

/**
 * Delivery details (Exists when fulfillment type is DELIVERY)
 */
export type OrderCreateEntityDelivery = {
  /** Specific Delivery instructions */
  instructions?: string;
  address?: Address;
  /** Delivery type */
  deliveryType: OrderCreateEntityDeliveryDeliveryType;
};

/**
 * This field identifies the order's source platform, aiding in efficient tracking and management based on its origin
 */
export type OrderCreateEntitySourceDeviceType = typeof OrderCreateEntitySourceDeviceType[keyof typeof OrderCreateEntitySourceDeviceType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderCreateEntitySourceDeviceType = {
  KIOSK: 'KIOSK',
  MOBILE: 'MOBILE',
  WEB: 'WEB',
  VOICE: 'VOICE',
  CHAT: 'CHAT',
  POS: 'POS',
  WEB_POS: 'WEB_POS',
} as const;

/**
 * Order source name
 */
export type OrderCreateEntitySourceName = typeof OrderCreateEntitySourceName[keyof typeof OrderCreateEntitySourceName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderCreateEntitySourceName = {
  UBEREATS: 'UBEREATS',
  FOODHUB: 'FOODHUB',
  GLORIAFOOD: 'GLORIAFOOD',
  DOORDASH: 'DOORDASH',
  GRUBHUB: 'GRUBHUB',
  CAVIAR: 'CAVIAR',
  YELP: 'YELP',
  SEAMLESS: 'SEAMLESS',
  DIRECT: 'DIRECT',
  GROUPON: 'GROUPON',
  UNKNOWN: 'UNKNOWN',
  EAT24: 'EAT24',
  TAPINGO: 'TAPINGO',
} as const;

export interface OrderCreateEntity {
  /** Delivery details (Exists when fulfillment type is DELIVERY) */
  delivery?: OrderCreateEntityDelivery;
  /** Comments */
  notes?: string;
  /** Auto incrementing daily order id, such as 10 if this order is the 10th order of the day */
  orderNumber?: string;
  /** This field identifies the order's source platform, aiding in efficient tracking and management based on its origin */
  sourceDeviceType?: OrderCreateEntitySourceDeviceType;
  /** Estimated Delivery time */
  estimatedDeliveryTime?: string;
  /** List of order payments */
  payments: OrderPayment[];
  /** List of order taxes */
  tax: OrderTax[];
  /** Order Sub total */
  subTotal: number;
  fulfillmentType: FulfillmentType;
  /** Order freindly id */
  friendlyId?: string;
  /** Order total tax */
  totalTax?: number;
  /** Order placed on timestamp */
  placedOn: string;
  /** Payment status */
  isPaid?: boolean;
  /** List of order charges */
  charges: OrderCharge[];
  /** Order total */
  total: number;
  /** List of order discounts */
  discounts: OrderDiscount[];
  /** Scheduled order status */
  isScheduledOrder?: boolean;
  /** Order Id */
  partnerId: string;
  /** Order source name */
  sourceName: OrderCreateEntitySourceName;
  /** List of order items */
  items: OrderItem[];
  /** Estimated Pick up time */
  estimatedPickupTime?: string;
  customer: OrderCustomer;
}

/**
 * Status of the delivery quote request
 */
export type DeliveryQuoteStatus = typeof DeliveryQuoteStatus[keyof typeof DeliveryQuoteStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryQuoteStatus = {
  SUCCESS: 'SUCCESS',
  ERROR: 'ERROR',
} as const;

export interface DeliveryQuote {
  /** Price of the delivery quote, in the lowest denomination of the currency (present if status is SUCCESS) */
  price?: number;
  /** Application ID that provided the delivery quote */
  applicationId: string;
  /** Error message (present if status is ERROR) */
  error?: string;
  /** Unique ID provided by the application for the delivery quote, this will be used in the delviery dispatch request (present if status is SUCCESS) */
  quoteId?: string;
  /** Application name that provided the delivery quote */
  applicationName: string;
  /** Name of the underlying delivery provider (applicable when application supports multiple providers) */
  providerName?: string;
  /** ISO8601 timestamp when the quote expires (present if status is SUCCESS) */
  quoteExpiresAt?: string;
  /** Status of the delivery quote request */
  status: DeliveryQuoteStatus;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListAccountMenuModifiersResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: MenuModifierEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

export interface GetOrderByIdResponse {
  data?: OrderEntity;
}

export interface MenuModifierGroupPatchEntity {
  /** Maximum number of items that must be selected (inclusive) */
  maxPermitted?: number;
  /** Catalog Modifier Group Name */
  name?: string;
  /** Catalog  Modifier Group Description */
  description?: string;
  /** Position of the menu modifier group */
  position?: number;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  modifiers?: string[];
}

export interface ListAccountCatalogModifierGroupByIdResponse {
  data?: CatalogModifierGroupEntity;
}

/**
 * Reference to the schema defining the business hours.
 */
export type MenuEntityAvailability = {
  delivery?: ServiceAvailability;
  collection?: ServiceAvailability;
};

export interface MenuEntity {
  /** Reseller Identifier (format: uuid) */
  resellerId: string;
  /** Account Identifier */
  accountId: string;
  /** Menu created at timestamp */
  createdAt: string;
  /** Location ID to which this menu is associated with */
  locationId: string;
  /** Menu Image */
  imageUrl: string;
  /** Menu Display Name */
  name: string;
  /** Menu Description */
  description: string;
  serviceAvailability?: ServiceAvailability;
  fulfillmentTypes: FulfillmentTypes;
  /** Menu Identifer */
  id: string;
  /** Reference to the schema defining the business hours. */
  availability?: MenuEntityAvailability;
  /** Menu updated at timestamp */
  updatedAt: string;
}

export interface SignedUrlResponse {
  /** The signed URL that can be used to upload the file, not that this URL will expire in 5 minutes */
  data: string;
}

/**
 * Order Status
 */
export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderStatus = {
  NEW: 'NEW',
  PLACED: 'PLACED',
  ACCEPTED: 'ACCEPTED',
  PREPARING: 'PREPARING',
  READY: 'READY',
  DELIVERING: 'DELIVERING',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED',
  DELIVERY_FAILED: 'DELIVERY_FAILED',
} as const;

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListAccountMenusResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: MenuEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListAccountMenuCategoriesResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: MenuCategoryEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

export interface UserPatchEntity {
  /** Users First Name */
  firstName?: string;
  /** Users Last Name */
  lastName?: string;
  /** Users Password */
  password?: string;
  /** Users phone number */
  phone?: string;
  language?: LanguageCode;
}

export interface GetAccountMenuByIdResponse {
  data?: MenuEntity;
}

/**
 * The mode of delivery that is being requested for the delivery.
 */
export type DeliveryEntityDeliveryMode = typeof DeliveryEntityDeliveryMode[keyof typeof DeliveryEntityDeliveryMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryEntityDeliveryMode = {
  ASAP: 'ASAP',
  SCHEDULED: 'SCHEDULED',
} as const;

/**
 * The strategy to use when auto selecting a quote for dispatch
 */
export type DeliveryEntityAutoDispatchSelectionStrategy = typeof DeliveryEntityAutoDispatchSelectionStrategy[keyof typeof DeliveryEntityAutoDispatchSelectionStrategy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryEntityAutoDispatchSelectionStrategy = {
  PRICE: 'PRICE',
  RANK: 'RANK',
} as const;

/**
 * Action the driver should take with the order contents when the delivery status is FAILED.
 */
export type DeliveryEntityFailureAction = typeof DeliveryEntityFailureAction[keyof typeof DeliveryEntityFailureAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryEntityFailureAction = {
  RETURN: 'RETURN',
  DISPOSE: 'DISPOSE',
} as const;

export type DeliveryEntityDropoff = {
  address: Address;
  contactName: string;
  contactPhone: string;
};

export type DeliveryEntityPickup = {
  address: Address;
  contactName: string;
  contactPhone: string;
};

/**
 * This is the current status of the overall delivery.
 */
export type DeliveryEntityStatus = typeof DeliveryEntityStatus[keyof typeof DeliveryEntityStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryEntityStatus = {
  CREATED: 'CREATED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  RETURNED: 'RETURNED',
} as const;

export interface DeliveryEntity {
  /** If provided, this confirmation code will be used by the delviery driver to confirm the delivery. */
  confirmationCode?: string;
  country?: CountryCode;
  /** Identifier for the associated order. */
  orderId: string;
  /** The timezone of the delivery (IANA timezone format) */
  timezone?: string;
  /** A short description that provides context for the delivery. */
  description?: string;
  /**
   * The number of seconds after the estimated pickup time to trigger the auto dispatch
   * @minimum 0
   * @maximum 900
   */
  autoDispatchFailoverGraceTime?: number;
  /** An array of quotes that were provided for the delivery. */
  quotes: DeliveryQuote[];
  /** Once the delivery has been picked up, this field will be populated with the actual time the delivery was picked up. */
  actualPickupTime?: string;
  /** A list of application ids that determine the rank (when RANK selection strategy is used) */
  autoDispatchSelectionRanking?: string[];
  /** Timestamp when the user was created. */
  createdAt: string;
  /** The mode of delivery that is being requested for the delivery. */
  deliveryMode: DeliveryEntityDeliveryMode;
  /** Identifier for the associated location. */
  locationId: string;
  /** When true, the delivery will be automatically dispatched based on the location preferences. */
  autoDispatchEnabled?: boolean;
  /** Once the driver has marked the delivery as completed, this field will be populated with the actual time the delivery was completed. */
  actualDeliveryTime?: string;
  currency?: CurrencyCode;
  /** Unique identifier for the delivery. */
  id: string;
  /** When true, the driver should be requested to provide proof of delivery, typically in the form of an image or confirmation code. */
  proofRequired: boolean;
  /** The strategy to use when auto selecting a quote for dispatch */
  autoDispatchSelectionStrategy?: DeliveryEntityAutoDispatchSelectionStrategy;
  /** If the delivery status is CANCELLED, this field will contain the reason for the cancellation. */
  cancelledReason?: string;
  /** The estimated time for the driver to arrive at the pickup location. */
  estimatedPickupTime?: string;
  /** Timestamp when the user was last updated. */
  updatedAt: string;
  /** Application that last updated the delivery entity */
  lastUpdatedBy: string;
  /** The actual time the delivery was marked as completed. */
  completedAt?: string;
  /** An array of dispatched delivery entities that were created from the delivery. */
  dispatched: DeliveryDispatch[];
  package?: DeliveryPackage;
  /** Action the driver should take with the order contents when the delivery status is FAILED. */
  failureAction: DeliveryEntityFailureAction;
  dropoff: DeliveryEntityDropoff;
  pickup: DeliveryEntityPickup;
  /** When enabled, if the first provider fails to honor the pickup time we will search for another provider */
  autoDispatchFailoverEnabled?: boolean;
  /** Identifier for the associated reseller. */
  resellerId: string;
  /** Identifier for the associated account. */
  accountId: string;
  /** Application that created the delivery entity */
  createdBy: string;
  /** The estimated time for the driver to arrive at the dropoff location. */
  estimatedDropoffTime?: string;
  /** This is the current status of the overall delivery. */
  status: DeliveryEntityStatus;
  /** If the delivery status is FAILED, this field will contain the reason for the failure. */
  failedReason?: string;
}

/**
 * Oauth2 Error Code
 */
export type OAuth2ErrorResponseError = typeof OAuth2ErrorResponseError[keyof typeof OAuth2ErrorResponseError];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OAuth2ErrorResponseError = {
  invalid_request: 'invalid_request',
  invalid_client: 'invalid_client',
  invalid_grant: 'invalid_grant',
  unauthorized_client: 'unauthorized_client',
  unsupported_grant_type: 'unsupported_grant_type',
  invalid_scope: 'invalid_scope',
} as const;

export interface OAuth2ErrorResponse {
  /** Human-readable ASCII [USASCII] text providing additional information, used to assist the client developer in understanding the error that occurred. (optional) */
  error_description?: string;
  /** Oauth2 Error Code */
  error: OAuth2ErrorResponseError;
  /** A URI identifying a human-readable web page with information about the error, used to provide the client developer with additional information about the error. (optional) */
  error_uri?: string;
}

export interface CatalogExportEntity {
  categories: CatalogCategoryPatchEntity[];
  modifiers: CatalogModifierPatchEntity[];
  modifierGroups: CatalogModifierGroupPatchEntity[];
  products: CatalogProductPatchEntity[];
}

export interface MenuModifierGroupEntity {
  /** Maximum number of items that must be selected (inclusive) */
  maxPermitted: number;
  /** Catalog ID */
  catalogModifierGroupId: string;
  /** Catalog  Modifier Group Description */
  description: string;
  modifiers: string[];
  /** Account Identifier */
  accountId: string;
  /** Menu Item created at timestamp */
  createdAt: string;
  /** Location Identifier */
  locationId: string;
  /** Catalog Modifier Group Name */
  name: string;
  /** Menu ID this category belongs to */
  menuId: string;
  /** Identifier */
  id: string;
  /** Position of the menu modifier group */
  position?: number;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted: number;
  /** Menu Item updated at timestamp */
  updatedAt: string;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListAuditsResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: AuditEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

/**
 * ISO-639-1 language code for the user
 */
export type ResellerUserPatchEntityLanguage = typeof ResellerUserPatchEntityLanguage[keyof typeof ResellerUserPatchEntityLanguage];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResellerUserPatchEntityLanguage = {
  'en-GB': 'en-GB',
  'en-US': 'en-US',
  'fr-FR': 'fr-FR',
  'de-DE': 'de-DE',
  'es-ES': 'es-ES',
  'it-IT': 'it-IT',
} as const;

export interface ResellerUserPatchEntity {
  /** Users First Name */
  firstName?: string;
  /** Users Last Name */
  lastName?: string;
  /** Users Password */
  password?: string;
  /** Users phone number */
  phone?: string;
  /** ISO-639-1 language code for the user */
  language?: ResellerUserPatchEntityLanguage;
  accounts?: string[];
  /** Users email address */
  email?: string;
}

/**
 * Order Customer
 */
export interface OrderCustomer {
  /** Customer First Name */
  firstName: string;
  /** Customer Last Name */
  lastName?: string;
  /** Customer Phone */
  phone: string;
  /** Phone Code */
  phonePin?: string;
  /** Customer Identifer (any unique identifier for this customer) */
  id: string;
  /** Customer Email */
  email?: string;
}

export interface GetAccountCatalogModifierByIdResponse {
  data?: CatalogModifierEntity;
}

/**
 * The default action to take when a delivery fails (e.g., "RETURN" or "DISPOSE").
 */
export type ResellerLocationPatchEntityDeliveryDefaultFailureAction = typeof ResellerLocationPatchEntityDeliveryDefaultFailureAction[keyof typeof ResellerLocationPatchEntityDeliveryDefaultFailureAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResellerLocationPatchEntityDeliveryDefaultFailureAction = {
  RETURN: 'RETURN',
  DISPOSE: 'DISPOSE',
} as const;

/**
 * The strategy to use when auto selecting a quote for dispatch
 */
export type ResellerLocationPatchEntityDeliveryAutoDispatchSelectionStrategy = typeof ResellerLocationPatchEntityDeliveryAutoDispatchSelectionStrategy[keyof typeof ResellerLocationPatchEntityDeliveryAutoDispatchSelectionStrategy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResellerLocationPatchEntityDeliveryAutoDispatchSelectionStrategy = {
  PRICE: 'PRICE',
  RANK: 'RANK',
} as const;

export interface ResellerLocationPatchEntity {
  /**
   * The number of seconds after the order has "started" that the order should be auto closed. This is only applicable if autoCloseOrders is enabled. (max: 24 hours, default is 3 hours)
   * @minimum 1800
   * @maximum 86400
   */
  autoCloseOrdersAfter?: number;
  /** The default action to take when a delivery fails (e.g., "RETURN" or "DISPOSE"). */
  deliveryDefaultFailureAction?: ResellerLocationPatchEntityDeliveryDefaultFailureAction;
  /** Users Last Name */
  lastName?: string;
  address?: Address;
  /** The strategy to use when auto selecting a quote for dispatch */
  deliveryAutoDispatchSelectionStrategy?: ResellerLocationPatchEntityDeliveryAutoDispatchSelectionStrategy;
  /** Location Timezone: (e.g. Europe/London) */
  timezone?: string;
  /** Indicates if orders should be automatically closed after a certain period of time. For ASAP orders, this is the time when the order was received; for scheduled orders, this is the scheduled time. */
  autoCloseOrders?: boolean;
  /** When enabled, if the first provider fails to honor the pickup time we will search for another provider */
  deliveryAutoDispatchFailoverEnabled?: boolean;
  businessHours?: ServiceAvailability;
  /** Indicates if deliveries should be automatically dispatched when created. */
  deliveryAutoDispatchEnabled?: boolean;
  /** The account ID */
  accountId?: string;
  /** A list of application ids that determine the rank (when RANK selection strategy is used) */
  deliveryAutoDispatchSelectionRanking?: string[];
  /** Users First Name */
  firstName?: string;
  /** Valid E.164 phone number (e.g. +14155552671) */
  phoneNumber?: string;
  /** When enabled, a delivery will be created automatically for self delivery orders */
  autoCreateDeliveryOnDeliveryOrder?: boolean;
  /** List of tax rates applicable to the location */
  taxRates?: TaxRate[];
  /**
   * The number of seconds after the estimated pickup time to trigger the auto dispatch
   * @minimum 0
   * @maximum 900
   */
  deliveryAutoDispatchFailoverGraceTime?: number;
  /** Location name: (e.g: Acme Inc - London) */
  name?: string;
  /** Default instructions for the pickup location. */
  deliveryDefaultPickupInstructions?: string;
  /** Indicates if proof of delivery is required by default for deliveries. */
  deliveryDefaultProofRequired?: boolean;
  /** The identifier for this location within the POS system. */
  posReference?: string;
  /** List of payment types accepted at the location */
  paymentTypes?: PaymentType[];
  /** Users Email Address */
  email?: string;
}

/**
 * The day of the week to which these hours apply.
 */
export type ServiceAvailabilityItemWeekday = typeof ServiceAvailabilityItemWeekday[keyof typeof ServiceAvailabilityItemWeekday];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ServiceAvailabilityItemWeekday = {
  MONDAY: 'MONDAY',
  TUESDAY: 'TUESDAY',
  WEDNESDAY: 'WEDNESDAY',
  THURSDAY: 'THURSDAY',
  FRIDAY: 'FRIDAY',
  SATURDAY: 'SATURDAY',
  SUNDAY: 'SUNDAY',
} as const;

export type ServiceAvailabilityItemTimePeriodsItem = {
  /** The start time for the service availability, in 24-hour HH:MM format (e.g., "08:30", "23:00"). */
  startTime?: string;
  /** The end time for the service availability, in 24-hour HH:MM format (e.g., "08:30", "23:00"). */
  endTime?: string;
};

export type ServiceAvailabilityItem = {
  /** The day of the week to which these hours apply. */
  weekday: ServiceAvailabilityItemWeekday;
  timePeriods: ServiceAvailabilityItemTimePeriodsItem[];
};

/**
 * Service Availability
 */
export type ServiceAvailability = ServiceAvailabilityItem[];

/**
 * Type of product, either product, variant or modifier
 */
export type CatalogProductVariantEntityType = typeof CatalogProductVariantEntityType[keyof typeof CatalogProductVariantEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogProductVariantEntityType = {
  PRODUCT: 'PRODUCT',
  VARIANT: 'VARIANT',
  MODIFIER: 'MODIFIER',
} as const;

/**
 * Catalog Variant Parent Identifier
 */
export type CatalogProductVariantEntityParentId = { [key: string]: unknown };

export interface CatalogProductVariantEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Whether the product contains alcohol */
  containsAlcohol?: boolean;
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Variant Description */
  description?: string;
  /** Type of product, either product, variant or modifier */
  type?: CatalogProductVariantEntityType;
  /** Catalog Variant Parent Identifier */
  parentId?: CatalogProductVariantEntityParentId;
  /** Ids of catalog modifier groups the variant is mapped to */
  modifierGroups?: string[];
  /** An external url to the original image from the POS */
  originalImageUrl?: string;
  /** Account Identifier */
  accountId?: string;
  /** Catalog Variant Creation Date */
  createdAt?: string;
  /** Whether the product is bike friendly */
  isBikeFriendly?: boolean;
  /** Variant Show Online */
  showOnline?: boolean;
  /** Location Identifier */
  locationId?: string;
  /**
   * Variant Price
   * @minimum 0
   * @maximum 999999999
   */
  price?: number;
  /** Variant Image */
  imageUrl?: string;
  /** Variation Name */
  name?: string;
  /** Whether the product contains tobacco */
  containsTobacco?: boolean;
  serviceAvailability?: ServiceAvailability;
  /** POS Product Reference */
  posReference?: string;
  /** Catalog Product Identifier */
  id?: string;
  /** Ids of catalog categories the variant is mapped to */
  categories?: string[];
  /** Position of the catalog variant product */
  position?: number;
  /**
   * When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders.
   * @minimum 0
   * @maximum 999999999
   */
  inStorePrice?: number;
  /** Catalog Variant Update Date */
  updatedAt?: string;
}

export interface CatalogModifierPatchEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Catalog Modifier Contains Alcohol */
  containsAlcohol?: boolean;
  /** Maximum number of items that must be selected (inclusive) */
  maxPermitted?: number;
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Modifier Description */
  description?: string;
  /** An external url to the original image from the POS */
  originalImageUrl?: string;
  /** Catalog Modifier is Bike Friendly */
  isBikeFriendly?: boolean;
  /** Catalog Modifier Show Online */
  showOnline?: boolean;
  /**
   * Catalog Modifier Price
   * @minimum 0
   * @maximum 999999999
   */
  price?: number;
  /** Catalog Modifier Name */
  name?: string;
  /** Catalog Modifier Contains Tabacco */
  containsTobacco?: boolean;
  /** Position of the catalog modifier */
  position?: number;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  /**
   * When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders.
   * @minimum 0
   * @maximum 999999999
   */
  inStorePrice?: number;
}

export interface ErrorResponse {
  error: string;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListResellersResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: ResellerEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

/**
 * Type of request (optional).
 */
export type AuditEntityRequestType = typeof AuditEntityRequestType[keyof typeof AuditEntityRequestType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuditEntityRequestType = {
  API: 'API',
  WEBHOOK: 'WEBHOOK',
  INTERNAL: 'INTERNAL',
} as const;

/**
 * HTTP method used for the request.
 */
export type AuditEntityRequestMethod = typeof AuditEntityRequestMethod[keyof typeof AuditEntityRequestMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AuditEntityRequestMethod = {
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  DELETE: 'DELETE',
  PATCH: 'PATCH',
} as const;

/**
 * Filtered headers of the request.
 */
export type AuditEntityRequestHeaders = { [key: string]: unknown };

export interface AuditEntity {
  /** Client ID related to the audit (format: UUID). */
  clientId: string;
  /** Type of request (optional). */
  requestType?: AuditEntityRequestType;
  /** Order ID related to the audit (optional, format: UUID). */
  orderId?: string;
  /** Time taken to respond to the request (in milliseconds). */
  responseTime: number;
  /** Resource path in the format of /resource/{id} (optional). */
  resourcePath?: string;
  /** HTTP method used for the request. */
  requestMethod: AuditEntityRequestMethod;
  /** User ID related to the audit (optional, format: UUID). */
  userId?: string;
  /** HTTP response code. */
  responseCode: number;
  /** Reseller ID related to the audit (format: UUID). */
  resellerId?: string;
  /** Account ID related to the audit (optional, format: UUID). */
  accountId?: string;
  /** Timestamp when the audit record was created. */
  createdAt: string;
  /** Filtered headers of the request. */
  requestHeaders?: AuditEntityRequestHeaders;
  /** Timestamp when the request was made. */
  requestedAt: string;
  /** Body of the request. */
  requestBody?: string;
  /** Location ID related to the audit (optional, format: UUID). */
  locationId?: string;
  /** Unique identifier for the audit (format: UUID). */
  id: string;
  /** Path of the request. */
  requestPath: string;
}

export interface CatalogImportSelection {
  /**
   * Maximum number of items that must be selected (inclusive)
   * @minimum 0
   * @maximum 100
   */
  maxPermitted?: number;
  /** Catalog Modifier Group Identifier */
  posReference: string;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  /** Array of embedded modifier objects */
  modifiers: CatalogImportSelectionModifiersItem[];
}

/**
 * Type of product, either product, variant or modifier
 */
export type MenuItemPatchEntityType = typeof MenuItemPatchEntityType[keyof typeof MenuItemPatchEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MenuItemPatchEntityType = {
  PRODUCT: 'PRODUCT',
  VARIANT: 'VARIANT',
  MODIFIER: 'MODIFIER',
} as const;

/**
 * Menu Variant Parent Identifier
 */
export type MenuItemPatchEntityParentId = { [key: string]: unknown };

export interface MenuItemPatchEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Whether the menu item contains alcohol */
  containsAlcohol?: boolean;
  /** Menu Item Description */
  description?: string;
  fulfillmentTypes?: FulfillmentTypes;
  /** Type of product, either product, variant or modifier */
  type?: MenuItemPatchEntityType;
  modifierGroups?: string[];
  /** Menu Variant Parent Identifier */
  parentId?: MenuItemPatchEntityParentId;
  /** Whether the menu item is bike friendly */
  isBikeFriendly?: boolean;
  /** Menu Item Online Availability */
  showOnline?: boolean;
  /** Selections for the menu item */
  selections?: MenuItemSelection[];
  /**
   * Menu Item Price
   * @minimum 0
   * @maximum 999999999
   */
  price?: number;
  /** Menu Item Image */
  imageUrl?: string;
  /** Menu Item Display Name */
  name?: string;
  /** Whether the menu item contains tobacco */
  containsTobacco?: boolean;
  serviceAvailability?: ServiceAvailability;
  /** Ids of menu categories the item is mapped to */
  categories?: string[];
  /** Position of the menu item */
  position?: number;
  /**
   * When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders.
   * @minimum 0
   * @maximum 999999999
   */
  inStorePrice?: number;
}

/**
 * The default action to take when a delivery fails (e.g., "RETURN" or "DISPOSE").
 */
export type ResellerLocationCreateEntityDeliveryDefaultFailureAction = typeof ResellerLocationCreateEntityDeliveryDefaultFailureAction[keyof typeof ResellerLocationCreateEntityDeliveryDefaultFailureAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResellerLocationCreateEntityDeliveryDefaultFailureAction = {
  RETURN: 'RETURN',
  DISPOSE: 'DISPOSE',
} as const;

/**
 * The strategy to use when auto selecting a quote for dispatch
 */
export type ResellerLocationCreateEntityDeliveryAutoDispatchSelectionStrategy = typeof ResellerLocationCreateEntityDeliveryAutoDispatchSelectionStrategy[keyof typeof ResellerLocationCreateEntityDeliveryAutoDispatchSelectionStrategy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResellerLocationCreateEntityDeliveryAutoDispatchSelectionStrategy = {
  PRICE: 'PRICE',
  RANK: 'RANK',
} as const;

export interface ResellerLocationCreateEntity {
  /**
   * The number of seconds after the order has "started" that the order should be auto closed. This is only applicable if autoCloseOrders is enabled. (max: 24 hours, default is 3 hours)
   * @minimum 1800
   * @maximum 86400
   */
  autoCloseOrdersAfter?: number;
  /** The default action to take when a delivery fails (e.g., "RETURN" or "DISPOSE"). */
  deliveryDefaultFailureAction?: ResellerLocationCreateEntityDeliveryDefaultFailureAction;
  /** Contact Person's Last Name */
  lastName?: string;
  address: Address;
  /** The strategy to use when auto selecting a quote for dispatch */
  deliveryAutoDispatchSelectionStrategy?: ResellerLocationCreateEntityDeliveryAutoDispatchSelectionStrategy;
  /** Location Timezone: (e.g. Europe/London) */
  timezone: string;
  /** Indicates if orders should be automatically closed after a certain period of time. For ASAP orders, this is the time when the order was received; for scheduled orders, this is the scheduled time. */
  autoCloseOrders?: boolean;
  /** When enabled, if the first provider fails to honor the pickup time we will search for another provider */
  deliveryAutoDispatchFailoverEnabled?: boolean;
  businessHours?: ServiceAvailability;
  /** Indicates if deliveries should be automatically dispatched when created. */
  deliveryAutoDispatchEnabled?: boolean;
  /** Account ID */
  accountId: string;
  /** A list of application ids that determine the rank (when RANK selection strategy is used) */
  deliveryAutoDispatchSelectionRanking?: string[];
  /** Contact Person's First Name */
  firstName?: string;
  /** Valid E.164 phone number (e.g. +14155552671) */
  phoneNumber: string;
  /** When enabled, a delivery will be created automatically for self delivery orders */
  autoCreateDeliveryOnDeliveryOrder?: boolean;
  /** List of tax rates applicable to the location */
  taxRates?: TaxRate[];
  /**
   * The number of seconds after the estimated pickup time to trigger the auto dispatch
   * @minimum 0
   * @maximum 900
   */
  deliveryAutoDispatchFailoverGraceTime?: number;
  /** Location name: (e.g: Acme Inc - London) */
  name: string;
  /** Default instructions for the pickup location. */
  deliveryDefaultPickupInstructions?: string;
  /** Indicates if proof of delivery is required by default for deliveries. */
  deliveryDefaultProofRequired?: boolean;
  /** The identifier for this location within the POS system. */
  posReference?: string;
  /** List of payment types accepted at the location */
  paymentTypes?: PaymentType[];
  /** Contact Person's Email Address */
  email?: string;
}

/**
 * The strategy to use when auto selecting a quote for dispatch
 */
export type LocationPatchEntityDeliveryAutoDispatchSelectionStrategy = typeof LocationPatchEntityDeliveryAutoDispatchSelectionStrategy[keyof typeof LocationPatchEntityDeliveryAutoDispatchSelectionStrategy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LocationPatchEntityDeliveryAutoDispatchSelectionStrategy = {
  PRICE: 'PRICE',
  RANK: 'RANK',
} as const;

/**
 * Reference to the schema defining the business hours.
 */
export type LocationPatchEntityAvailability = {
  delivery?: ServiceAvailability;
  collection?: ServiceAvailability;
};

/**
 * The default action to take when a delivery fails (e.g., "RETURN" or "DISPOSE").
 */
export type LocationPatchEntityDeliveryDefaultFailureAction = typeof LocationPatchEntityDeliveryDefaultFailureAction[keyof typeof LocationPatchEntityDeliveryDefaultFailureAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LocationPatchEntityDeliveryDefaultFailureAction = {
  RETURN: 'RETURN',
  DISPOSE: 'DISPOSE',
} as const;

export interface LocationPatchEntity {
  /**
   * The number of seconds after the order has "started" that the order should be auto closed. This is only applicable if autoCloseOrders is enabled. (max: 24 hours, default is 3 hours)
   * @minimum 1800
   * @maximum 86400
   */
  autoCloseOrdersAfter?: number;
  /** Contact Person's Last Name */
  lastName?: string;
  /** The strategy to use when auto selecting a quote for dispatch */
  deliveryAutoDispatchSelectionStrategy?: LocationPatchEntityDeliveryAutoDispatchSelectionStrategy;
  /** Location Timezone: (e.g., "Europe/London"). */
  timezone?: string;
  /** Reference to the schema defining the business hours. */
  availability?: LocationPatchEntityAvailability;
  /** A list of application ids that determine the rank (when RANK selection strategy is used) */
  deliveryAutoDispatchSelectionRanking?: string[];
  /** When enabled, a delivery will be created automatically for self delivery orders */
  autoCreateDeliveryOnDeliveryOrder?: boolean;
  /** List of tax rates applicable to the location */
  taxRates?: TaxRate[];
  countryCode?: CountryCode;
  currency?: CurrencyCode;
  /** List of payment types accepted at the location */
  paymentTypes?: PaymentType[];
  /** Contact Person's Email Address */
  email?: string;
  /** The default action to take when a delivery fails (e.g., "RETURN" or "DISPOSE"). */
  deliveryDefaultFailureAction?: LocationPatchEntityDeliveryDefaultFailureAction;
  address?: Address;
  /** Indicates if orders should be automatically closed after a certain period of time. For ASAP orders, this is the time when the order was received; for scheduled orders, this is the scheduled time. */
  autoCloseOrders?: boolean;
  /** When enabled, if the first provider fails to honor the pickup time we will search for another provider */
  deliveryAutoDispatchFailoverEnabled?: boolean;
  businessHours?: ServiceAvailability;
  /** Indicates if deliveries should be automatically dispatched when created. */
  deliveryAutoDispatchEnabled?: boolean;
  /** Contact Person's First Name */
  firstName?: string;
  /** Valid E.164 phone number (e.g., +14155552671). */
  phoneNumber?: string;
  /**
   * The number of seconds after the estimated pickup time to trigger the auto dispatch
   * @minimum 0
   * @maximum 900
   */
  deliveryAutoDispatchFailoverGraceTime?: number;
  /** Location name: (e.g., "Acme Inc - London"). */
  name?: string;
  /** Default instructions for the pickup location. */
  deliveryDefaultPickupInstructions?: string;
  /** Indicates if proof of delivery is required by default for deliveries. */
  deliveryDefaultProofRequired?: boolean;
  /** The identifier for this location within the POS system. */
  posReference?: string;
}

/**
 * Order Item
 */
export interface OrderItem {
  /** Quantity (e.g: 2) */
  quantity: number;
  /**
   * Item Price (e.g: 1000 = ¬£10.00)
   * @minimum 0
   * @maximum 999999999
   */
  price: number;
  /** Item Name */
  name: string;
  /** Parent pos reference id of this item, typically category id (If available) */
  parentPosReference?: string;
  /** List of order options */
  options: OrderOption[];
  /** Customer Notes */
  customerNotes?: string;
  /** The pos reference id of this item (If available) */
  posReference?: string;
  /** The id of the MenuItem entity that this item refers to */
  partnerId?: string;
  /** The id of the MenuCategory entity this item belongs to */
  menuCategoryId?: string;
}

export interface GetConnectionByIdResponse {
  data?: ConnectionEntity;
}

export interface MenuCategoryEntity {
  /** Account Identifier */
  accountId: string;
  /** Category created at timestamp */
  createdAt: string;
  /** Menu Category Online Availability */
  showOnline?: boolean;
  /** Category Description */
  catalogCategoryId?: string;
  /** Location ID to which this menu is associated with */
  locationId: string;
  /** Menu Category Image */
  imageUrl?: string;
  /** Category Name */
  name: string;
  /** Menu ID this category belongs to */
  menuId?: string;
  /** Category Description */
  description: string;
  /** Identifier */
  id: string;
  /** Position of category within list of categories */
  position?: number;
  /** Category updated at timestamp */
  updatedAt: string;
}

export interface GetAccountCatalogCategoryByIdResponse {
  data?: CatalogCategoryEntity;
}

export interface UserCreateEntity {
  /** Users First Name */
  firstName: string;
  /** Users Last Name */
  lastName: string;
  /** User password */
  password: string;
  /** Users phone number */
  phone?: string;
  language: LanguageCode;
  accounts: string[];
  /** Users email address */
  email: string;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface GetAccountProductVariantsResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: CatalogProductVariantEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

export interface MenuPublishCreateEntity {
  /** Menu Id */
  menuId: string;
  /** Auto Publish Interval */
  autoPublishInterval?: number;
}

export interface GetDeliveryByIdResponse {
  data?: DeliveryEntity;
}

export interface CatalogImportEntity {
  location?: LocationPatchEntity;
  categories: CatalogCategoryCreateEntity[];
  modifiers: CatalogModifierCreateEntity[];
  modifierGroups: CatalogModifierGroupCreateEntity[];
  products: CatalogImportProductEntity[];
}

export interface CatalogModifierEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Catalog Modifier Contains Alcohol */
  containsAlcohol?: boolean;
  /** Maximum number of items that must be selected (inclusive) */
  maxPermitted?: number;
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Modifier Description */
  description?: string;
  /** An external url to the original image from the POS */
  originalImageUrl?: string;
  /** Account Identifier */
  accountId: string;
  /** Catalog Modifier created at timestamp */
  createdAt: string;
  /** Catalog Modifier is Bike Friendly */
  isBikeFriendly?: boolean;
  /** Catalog Modifier Show Online */
  showOnline?: boolean;
  /** Location Identifier */
  locationId: string;
  /**
   * Catalog Modifier Price
   * @minimum 0
   * @maximum 999999999
   */
  price: number;
  /** Catalog Modifier Image URL */
  imageUrl?: string;
  /** Catalog Modifier Name */
  name: string;
  /** Catalog Modifier Contains Tabacco */
  containsTobacco?: boolean;
  /** Unique POS Reference ID */
  posReference: string;
  /** Catalog Modifier Identifier */
  id: string;
  /** Position of the catalog modifier */
  position?: number;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  /**
   * When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders.
   * @minimum 0
   * @maximum 999999999
   */
  inStorePrice?: number;
  /** Catalog Modifier updated at timestamp */
  updatedAt: string;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListAccountMenuItemVariantsResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: MenuItemVariantEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

/**
 * This field represents the status of the connection from the perspective of the application, i.e the application is connected to the location but the application may not have access to the downstream services.
 */
export type ConnectionPatchEntityStatus = typeof ConnectionPatchEntityStatus[keyof typeof ConnectionPatchEntityStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionPatchEntityStatus = {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
} as const;

export interface ConnectionPatchEntity {
  /** Failure Reason for the connection */
  failureReason?: string;
  /** This field represents the status of the connection from the perspective of the application, i.e the application is connected to the location but the application may not have access to the downstream services. */
  status?: ConnectionPatchEntityStatus;
}

/**
 * An ISO 639-1 language code.
 */
export type LanguageCode = typeof LanguageCode[keyof typeof LanguageCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LanguageCode = {
  'en-GB': 'en-GB',
  'en-US': 'en-US',
  'fr-FR': 'fr-FR',
  'de-DE': 'de-DE',
  'es-ES': 'es-ES',
  'it-IT': 'it-IT',
} as const;

export interface GetAccountByIdResponse {
  data?: AccountEntity;
}

export interface GetApplicationInfoResponse {
  data?: ApplicationInfo;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListDeliveriesResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: DeliveryEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListUsersResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: UserEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

export interface GetAccountMenuExportResponse {
  data?: MenuExportEntity;
}

export type CatalogProductSelectionModifierSelectionsItem = { [key: string]: unknown };

export interface CatalogProductSelectionModifier {
  /** The identifier to the POS Hub Catalog Modifier Group */
  catalogModifierId: string;
  /**
   * Maximum number of items that must be selected (inclusive)
   * @minimum 0
   * @maximum 100
   */
  maxPermitted?: number;
  /** Show online of the modifier */
  showOnline?: boolean;
  /** Array of nested selections */
  selections?: CatalogProductSelectionModifierSelectionsItem[];
  /**
   * The price of the modifier
   * @minimum 0
   */
  price?: number;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  /**
   * The inStore price of the modifier
   * @minimum 0
   */
  inStorePrice?: number;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListAccountMenuItemsResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: MenuItemEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

export interface GetResellerByIdResponse {
  data?: ResellerEntity;
}

export interface CatalogCategoryCreateEntity {
  /** An external url to the original image from the POS */
  originalImageUrl?: string;
  /** Catalog Category Show Online */
  showOnline?: boolean;
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Category Name */
  name: string;
  /** Catalog Category Description */
  description?: string;
  /** Unique POS Reference ID */
  posReference: string;
  /** Position of catalog category within list of categories */
  position?: number;
}

export type MenuItemSelectionModifierSelectionsItem = { [key: string]: unknown };

export interface MenuItemSelectionModifier {
  /** The identifier to the POS Hub Catalog Modifier */
  catalogModifierId: string;
  /**
   * Maximum number of items that must be selected (inclusive)
   * @minimum 0
   * @maximum 100
   */
  maxPermitted?: number;
  /** Show online of the modifier */
  showOnline?: boolean;
  /** Array of nested selections */
  selections?: MenuItemSelectionModifierSelectionsItem[];
  /** The identifier to the POS Hub Menu Modifier */
  menuModifierId: string;
  /**
   * The price of the modifier
   * @minimum 0
   */
  price?: number;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  /**
   * The inStore price of the modifier
   * @minimum 0
   */
  inStorePrice?: number;
}

export type CatalogModifierGroupPatchEntityModifiersItem = {
  /**
   * Catalog Modifier Price
   * @minimum 0
   * @maximum 999999999
   */
  price: number;
  /** Catalog Modifier Name */
  name: string;
  /** Catalog Modifier ID (must already exists) */
  id: string;
};

export interface CatalogModifierGroupPatchEntity {
  /** Catalog Modifier Group Expanded by default */
  expanded?: boolean;
  /**
   * Maximum number of items that must be selected (inclusive)
   * @minimum 0
   */
  maxPermitted?: number;
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Modifier Group Name */
  name?: string;
  /** Catalog Modifier Group Description */
  description?: string;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  /** Position of the catalog modifier group */
  position?: number;
  modifiers?: CatalogModifierGroupPatchEntityModifiersItem[];
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListConnectionsResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: ConnectionEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

export interface AccountPatchEntity {
  /** Account phone number */
  phoneNumber?: string;
  address?: Address;
  /** Timezone associated with the account (e.g., "America/New_York"). */
  timezone?: string;
  countryCode?: CountryCode;
  /** Account name */
  name?: string;
  currency?: CurrencyCode;
}

/**
 * Reference to the schema defining the business hours.
 */
export type MenuCreateEntityAvailability = {
  delivery?: ServiceAvailability;
  collection?: ServiceAvailability;
};

export interface MenuCreateEntity {
  /** Location ID to which this menu is associated with */
  locationId?: string;
  /** Menu Image */
  imageUrl?: string;
  /** Menu Display Name */
  name: string;
  /** Menu Description */
  description: string;
  serviceAvailability?: ServiceAvailability;
  fulfillmentTypes: FulfillmentTypes;
  /** Reference to the schema defining the business hours. */
  availability?: MenuCreateEntityAvailability;
}

/**
 * Type of product, either product, variant or modifier
 */
export type MenuItemEntityType = typeof MenuItemEntityType[keyof typeof MenuItemEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MenuItemEntityType = {
  PRODUCT: 'PRODUCT',
  VARIANT: 'VARIANT',
  MODIFIER: 'MODIFIER',
} as const;

/**
 * Menu Variant Parent Identifier
 */
export type MenuItemEntityParentId = { [key: string]: unknown };

export interface MenuItemEntity {
  /** Identifier of the catalog product this item corresponds to */
  catalogProductId: string;
  /** Description field used to describe the item to the consumers */
  description: string;
  fulfillmentTypes?: FulfillmentTypes;
  /** Type of product, either product, variant or modifier */
  type?: MenuItemEntityType;
  modifierGroups: string[];
  /** ISO 8601 timestamp of when the item was created */
  createdAt: string;
  /** Indicates if the item is bike friendly */
  isBikeFriendly?: boolean;
  /** Location ID to which this menu is associated with */
  locationId: string;
  /**
   * The price of the item in lowest denomination of the currency
   * @minimum 0
   * @maximum 999999999
   */
  price: number;
  /** Image URL of the item */
  imageUrl?: string;
  /** Indicates if the item contains tobacco */
  containsTobacco?: boolean;
  /** The menu id in which this item belongs to */
  menuId: string;
  /** The identifier of the item */
  id: string;
  /** Ids of menu categories the item is mapped to */
  categories: string[];
  /** ISO 8601 timestamp of when the item was updated */
  updatedAt: string;
  nutritionalInfo?: NutritionalInfo;
  /** Indicates if the item contains alcohol */
  containsAlcohol?: boolean;
  /** Menu Variant Parent Identifier */
  parentId?: MenuItemEntityParentId;
  /** Account Identifier */
  accountId?: string;
  /** Menu Item Online Availability */
  showOnline: boolean;
  selections?: MenuItemSelection[];
  /** The display name of the item */
  name: string;
  serviceAvailability?: ServiceAvailability;
  /** Position of item within list of items */
  position: number;
  /**
   * When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders.
   * @minimum 0
   * @maximum 999999999
   */
  inStorePrice?: number;
}

/**
 * Reference to the schema defining the business hours.
 */
export type MenuPatchEntityAvailability = {
  delivery?: ServiceAvailability;
  collection?: ServiceAvailability;
};

export interface MenuPatchEntity {
  /** Location ID to which this menu is associated with */
  locationId?: string;
  /** Menu Image */
  imageUrl?: string;
  /** Menu Display Name */
  name?: string;
  /** Menu Description */
  description?: string;
  serviceAvailability?: ServiceAvailability;
  fulfillmentTypes?: FulfillmentTypes;
  /** Menu Identifer */
  id?: string;
  /** Reference to the schema defining the business hours. */
  availability?: MenuPatchEntityAvailability;
}

export interface AccountMenuModifierByIdResponse {
  data?: MenuModifierEntity;
}

export interface CatalogImportSelectionModifiersItem {
  /**
   * Maximum number of items that must be selected (inclusive)
   * @minimum 0
   * @maximum 100
   */
  maxPermitted?: number;
  /** Array of nested selections */
  selections?: CatalogImportSelectionModifiersItemSelectionsItem[];
  /**
   * The price of the modifier
   * @minimum 0
   */
  price?: number;
  /** The identifier to the POS Hub Catalog Modifier Group */
  posReference: string;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
}

export interface GetAccountProductByIdResponse {
  data?: CatalogProductEntity;
}

export interface CatalogImportSelectionModifiersItemSelectionsItem {
  /**
   * Maximum number of items that must be selected (inclusive)
   * @minimum 0
   * @maximum 100
   */
  maxPermitted?: number;
  /** The identifier to the POS Hub Catalog Modifier Group */
  posReference: string;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  /** Array of nested modifier selections */
  modifiers: CatalogImportSelectionModifiersItem[];
}

export type FulfillmentTypes = FulfillmentType[];

export interface ResellerAccountCreateEntity {
  /** Account phone number */
  phoneNumber: string;
  address: Address;
  countryCode?: CountryCode;
  /** Account name */
  name: string;
  currency: CurrencyCode;
  /** User ID */
  ownerId: string;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListApplicationsInfoResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: ApplicationInfo[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

/**
 * The type of token this is, typically just the string ‚ÄúBearer‚Äù.
 */
export type TokenResponseTokenType = typeof TokenResponseTokenType[keyof typeof TokenResponseTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TokenResponseTokenType = {
  Bearer: 'Bearer',
} as const;

export interface TokenResponse {
  /** The access token issued by the authorization server */
  access_token: string;
  /** The refresh token, which can be used to obtain new access tokens using the same authorization grant. */
  refresh_token?: string;
  /** The scope of the access token. */
  scope: string;
  /** The type of token this is, typically just the string ‚ÄúBearer‚Äù. */
  token_type: TokenResponseTokenType;
  /** The length the token is valid for in seconds */
  expires_in?: number;
}

export interface MenuItemSelection {
  /**
   * Maximum number of items that must be selected (inclusive)
   * @minimum 0
   * @maximum 100
   */
  maxPermitted?: number;
  /** Modifier Group Identifier */
  menuModifierGroupId: string;
  /** Catalog Modifier Group Identifier */
  catalogModifierGroupId: string;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  modifiers?: MenuItemSelectionModifier[];
}

/**
 * Category of the application, e.g., POS, MARKETPLACE.
 */
export type ApplicationEntityCategory = typeof ApplicationEntityCategory[keyof typeof ApplicationEntityCategory];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationEntityCategory = {
  MARKETPLACE: 'MARKETPLACE',
  POS: 'POS',
  DELIVERY: 'DELIVERY',
  OTHER: 'OTHER',
} as const;

export interface ApplicationEntity {
  /** URL for dispatching a delivery quote (applicable only for DELIVERY applications). */
  dispatchDeliveryQuoteUrl?: string;
  /** List of allowed grants for this application. */
  allowedGrants: string[];
  /** Indicates if this application can skip the consent screen. Typically false for third-party applications. */
  skipConsent: boolean;
  /** Detailed description of the application. */
  description: string;
  /** List of allowed countries this application can be used in. */
  allowedCountries?: CountryCode[];
  /** Unique identifier for the application owner (format: UUID). */
  ownerId?: string;
  /** List of redirect URIs permitted for this application. */
  redirectUris: string[];
  /** URL for getting delivery quotes for a given delivery (applicable only for DELIVERY applications). */
  getDeliveryQuoteUrl?: string;
  /** Unique identifier for the reseller associated with the application (format: UUID). */
  resellerId?: string;
  /** URL for cancelling a dispatched delivery (applicable only for DELIVERY applications). */
  cancelDeliveryUrl?: string;
  /** Timestamp when the application was created. */
  createdAt?: string;
  /** URL for getting the latest details for adispatched delivery (applicable only for DELIVERY applications). */
  getDeliveryUrl?: string;
  /** URL for catalog synchronization (applicable only for POS applications). */
  catalogSyncUrl?: string;
  /** URL of the application's image. */
  imageUrl?: string;
  /** Display name of the application. */
  name: string;
  /** URL for menu publication (applicable only for MARKETPLACE applications). */
  menuPublicationUrl?: string;
  /** Unique identifier for the application (format: UUID). */
  id: string;
  scopes: ApplicationScopes;
  /** Category of the application, e.g., POS, MARKETPLACE. */
  category: ApplicationEntityCategory;
  /** Webhook endpoint URL for the application. */
  webhookEndpoint?: string;
  /** Timestamp when the application was last updated. */
  updatedAt?: string;
}

export interface DeliveryPatchEntity {
  /** Estimated time for the delivery to be delivered. */
  estimatedDropoffTime: string;
  /** Estimated time for the delivery to be picked up. */
  estimatedPickupTime?: string;
}

export interface MenuModifierEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Catalog Modifier ID */
  catalogModifierId: string;
  /** Menu Modifier Contains Alcohol */
  containsAlcohol?: boolean;
  /** Maximum number of items that must be selected (inclusive) */
  maxPermitted?: number;
  /** Menu Modifier Description */
  description: string;
  /** Account Identifier */
  accountId: string;
  /** Menu Modifier created at timestamp */
  createdAt: string;
  /** Menu Modifier is Bike Friendly */
  isBikeFriendly?: boolean;
  /** Menu Modifier Online Availability */
  showOnline?: boolean;
  /** Location Identifier */
  locationId: string;
  /** Menu Modifier Price */
  price: number;
  /** Image URL of the modifier */
  imageUrl?: string;
  /** Menu Modifier Name */
  name: string;
  /** Menu Modifier Contains Tabacco */
  containsTobacco?: boolean;
  /** Menu ID */
  menuId: string;
  /** Menu Modifier Identifier */
  id: string;
  /** Position of the menu modifier */
  position?: number;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  /** When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders. */
  inStorePrice?: number;
  /** Menu Modifier updated at timestamp */
  updatedAt: string;
}

export interface CatalogModifierCreateEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Catalog Modifier Contains Alcohol */
  containsAlcohol?: boolean;
  /** Maximum number of items that must be selected (inclusive) */
  maxPermitted?: number;
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Modifier Description */
  description?: string;
  /** An external url to the original image from the POS */
  originalImageUrl?: string;
  /** Catalog Modifier is Bike Friendly */
  isBikeFriendly?: boolean;
  /** Catalog Modifier Show Online */
  showOnline?: boolean;
  /**
   * Catalog Modifier Price
   * @minimum 0
   * @maximum 999999999
   */
  price: number;
  /** Catalog Modifier Name */
  name: string;
  /** Catalog Modifier Contains Tabacco */
  containsTobacco?: boolean;
  /** Unique POS Reference ID */
  posReference: string;
  /** Position of the catalog modifier */
  position?: number;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  /**
   * When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders.
   * @minimum 0
   * @maximum 999999999
   */
  inStorePrice?: number;
}

/**
 * Size of the package
 */
export type DeliveryPackagePackageSize = typeof DeliveryPackagePackageSize[keyof typeof DeliveryPackagePackageSize];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryPackagePackageSize = {
  SMALL: 'SMALL',
  MEDIUM: 'MEDIUM',
  LARGE: 'LARGE',
} as const;

export type DeliveryPackageItemsItem = {
  /** Quantity of the item */
  quantity?: number;
  /** Price of the item */
  price?: number;
  /** Name of the item */
  name?: string;
};

export interface DeliveryPackage {
  /** Total tax applied to the package */
  totalTax?: number;
  /**
   * Total price of the package
   * @minimum 0
   * @maximum 999999999
   */
  totalValue?: number;
  /** Description of the package */
  description?: string;
  /** The unique ID of the package (typically a order id) */
  id?: string;
  /** Size of the package */
  packageSize?: DeliveryPackagePackageSize;
  items?: DeliveryPackageItemsItem[];
  /** Total service charge applied to the package */
  totalServiceCharge?: number;
}

/**
 * Category of the application, e.g., POS, MARKETPLACE.
 */
export type ApplicationInfoCategory = typeof ApplicationInfoCategory[keyof typeof ApplicationInfoCategory];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationInfoCategory = {
  MARKETPLACE: 'MARKETPLACE',
  POS: 'POS',
  DELIVERY: 'DELIVERY',
  OTHER: 'OTHER',
} as const;

export interface ApplicationInfo {
  /** Timestamp when the application was created. */
  createdAt?: string;
  /** URL of the application's image. */
  imageUrl?: string;
  /** Display name of the application. */
  name: string;
  /** Detailed description of the application. */
  description: string;
  /** Unique identifier for the application (format: UUID). */
  id: string;
  /** List of allowed countries this application can be used in. */
  allowedCountries: CountryCode[];
  scopes: ApplicationScopes;
  /** Category of the application, e.g., POS, MARKETPLACE. */
  category: ApplicationInfoCategory;
  /** Timestamp when the application was last updated. */
  updatedAt?: string;
}

export interface MenuRearrangeRequest {
  /** Categories Sequence Rearrange */
  categories?: string[];
  /** Modifiers Sequence Rearrange */
  modifiers?: string[];
  /** Items Sequence Rearrange */
  items?: string[];
  /** Modifier Groups Sequence Rearrange */
  modifierGroups?: string[];
}

export interface MenuExportEntity {
  categories: MenuCategoryEntity[];
  menu: MenuEntity;
  modifiers: MenuModifierEntity[];
  items: MenuItemEntity[];
  modifierGroups: MenuModifierGroupEntity[];
}

/**
 * Type of product, either product, variant or modifier
 */
export type CatalogImportProductEntityType = typeof CatalogImportProductEntityType[keyof typeof CatalogImportProductEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogImportProductEntityType = {
  PRODUCT: 'PRODUCT',
  VARIANT: 'VARIANT',
  MODIFIER: 'MODIFIER',
} as const;

/**
 * Catalog Variant Parent Identifier
 */
export type CatalogImportProductEntityParentId = { [key: string]: unknown };

export interface CatalogImportProductEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Catalog Product Contains Alcohol */
  containsAlcohol?: boolean;
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Product Description */
  description?: string;
  /** Type of product, either product, variant or modifier */
  type?: CatalogImportProductEntityType;
  /** Ids of catalog modifier groups the item is mapped to */
  modifierGroups: string[];
  /** Catalog Variant Parent Identifier */
  parentId?: CatalogImportProductEntityParentId;
  /** An external url to the original image from the POS */
  originalImageUrl?: string;
  /** Catalog Product is Bike Friendly */
  isBikeFriendly?: boolean;
  /** Catalog Product Show Online */
  showOnline: boolean;
  /** Selections for the product */
  selections?: CatalogImportSelection[];
  /**
   * Catalog Product Price
   * @minimum 0
   * @maximum 999999999
   */
  price: number;
  /** Catalog Product Name */
  name: string;
  /** Catalog Product Contains Tabacco */
  containsTobacco?: boolean;
  serviceAvailability?: ServiceAvailability;
  /** POS Product Reference */
  posReference: string;
  /** Ids of catalog categories the item is mapped to */
  categories: string[];
  /** Position of the catalog product */
  position?: number;
  /**
   * When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders.
   * @minimum 0
   * @maximum 999999999
   */
  inStorePrice?: number;
}

/**
 * Order Option
 */
export interface OrderOption {
  /** Quantity */
  quantity: number;
  /** The id of the MenuModifierGroup entity that this option refers to */
  menuModifierGroupId?: string;
  /**
   * Option Price (e.g: 240 = ¬£2.40)
   * @minimum 0
   * @maximum 999999999
   */
  price: number;
  /** The parent modifier pos reference id that this option refers to */
  parentModifierPosReference?: string;
  /** Option Name */
  name: string;
  /** The parent pos reference id of this option (If available) */
  parentPosReference?: string;
  /** The pos reference id of this option (If available) */
  posReference?: string;
  /** The id of the MenuModifier entity that this option refers to */
  partnerId?: string;
  /** The parent menu modifier id that this option refers to */
  parentMenuModifierId?: string;
  /** The parent modifier menu modifier group id that this option refers to */
  parentModifierGroupPosReference?: string;
  /** The parent menu modifier group id that this option refers to */
  parentMenuModifierGroupId?: string;
}

/**
 * Account Entity
 */
export interface AccountEntity {
  /** Unique identifier for the reseller associated with the account (format: UUID). */
  resellerId?: string;
  /** Timestamp indicating when the account was created (format: date-time). */
  createdAt?: string;
  address: Address;
  /** Timezone associated with the account (e.g., "America/New_York"). */
  timezone: string;
  countryCode?: CountryCode;
  /** Display name of the account (e.g., "Acme Inc."). */
  name: string;
  currency: CurrencyCode;
  /** Unique identifier for the account (format: UUID). */
  id: string;
  /** Unique identifier for the account owner (format: UUID). */
  ownerId: string;
  /** Timestamp indicating when the account was last updated (format: date-time). */
  updatedAt?: string;
}

export interface MenuModifierGroupCreateEntity {
  /** Maximum number of items that must be selected (inclusive) */
  maxPermitted: number;
  /** Catalog Modifier Group ID */
  catalogModifierGroupId: string;
  /** Catalog Modifier Group Name */
  name: string;
  /** Catalog  Modifier Group Description */
  description: string;
  /** Position of the menu modifier group */
  position?: number;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted: number;
  modifiers: string[];
}

/**
 * This field identifies the order's source platform, aiding in efficient tracking and management based on its origin
 */
export type OrderEntitySourceDeviceType = typeof OrderEntitySourceDeviceType[keyof typeof OrderEntitySourceDeviceType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderEntitySourceDeviceType = {
  KIOSK: 'KIOSK',
  MOBILE: 'MOBILE',
  WEB: 'WEB',
  VOICE: 'VOICE',
  CHAT: 'CHAT',
  POS: 'POS',
  WEB_POS: 'WEB_POS',
} as const;

/**
 * The current status of the driver assigned to the delivery.
 */
export type OrderEntityDriverStatus = typeof OrderEntityDriverStatus[keyof typeof OrderEntityDriverStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderEntityDriverStatus = {
  UNASSIGNED: 'UNASSIGNED',
  ASSIGNED: 'ASSIGNED',
  ON_ROUTE_TO_PICKUP: 'ON_ROUTE_TO_PICKUP',
  AT_PICKUP: 'AT_PICKUP',
  ON_ROUTE_TO_DROP_OFF: 'ON_ROUTE_TO_DROP_OFF',
  AT_DROP_OFF: 'AT_DROP_OFF',
  RETURNING: 'RETURNING',
  RETURNED: 'RETURNED',
  COMPLETED: 'COMPLETED',
} as const;

/**
 * Delivery type
 */
export type OrderEntityDeliveryDeliveryType = typeof OrderEntityDeliveryDeliveryType[keyof typeof OrderEntityDeliveryDeliveryType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderEntityDeliveryDeliveryType = {
  SELF_DELIVERY: 'SELF_DELIVERY',
  PARTNER_DELIVERY: 'PARTNER_DELIVERY',
} as const;

/**
 * Delivery details (Exists when fulfillment type is DELIVERY)
 */
export type OrderEntityDelivery = {
  /** Specific Delivery instructions */
  instructions?: string;
  address?: Address;
  /** Delivery type */
  deliveryType: OrderEntityDeliveryDeliveryType;
};

/**
 * Order source name
 */
export type OrderEntitySourceName = typeof OrderEntitySourceName[keyof typeof OrderEntitySourceName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderEntitySourceName = {
  UBEREATS: 'UBEREATS',
  FOODHUB: 'FOODHUB',
  GLORIAFOOD: 'GLORIAFOOD',
  CHOWNOW: 'CHOWNOW',
  GRUBHUB: 'GRUBHUB',
  EATSTREET: 'EATSTREET',
  CLOUDWAITRESS: 'CLOUDWAITRESS',
  FLIPDISH: 'FLIPDISH',
  MENUFY: 'MENUFY',
  DOORDASH: 'DOORDASH',
  CAVIAR: 'CAVIAR',
  YELP: 'YELP',
  SEAMLESS: 'SEAMLESS',
  DIRECT: 'DIRECT',
  GROUPON: 'GROUPON',
  UNKNOWN: 'UNKNOWN',
  EAT24: 'EAT24',
  TAPINGO: 'TAPINGO',
} as const;

export interface OrderEntity {
  /** Comments */
  notes?: string;
  /** Auto incrementing daily order id, such as 10 if this order is the 10th order of the day */
  orderNumber?: string;
  /** Order freindly id */
  freindlyId?: string;
  /** This field identifies the order's source platform, aiding in efficient tracking and management based on its origin */
  sourceDeviceType?: OrderEntitySourceDeviceType;
  /** Account Name */
  accountName: string;
  /** Name of the client the order belongs to */
  clientName: string;
  /** Estimated delivery time */
  estimatedDeliveryTime?: string;
  /** List of order payments */
  payments: OrderPayment[];
  /** Order sub total */
  subTotal: number;
  /** The current status of the driver assigned to the delivery. */
  driverStatus?: OrderEntityDriverStatus;
  fulfillmentType: FulfillmentType;
  /** Actual pick up time */
  actualPickupTime?: string;
  /** Order total tax */
  totalTax?: number;
  /** Timestamp the order was created */
  createdAt: string;
  /** Order total */
  total: number;
  /** List of order discounts */
  discounts: OrderDiscount[];
  /** ID of the location the order belongs to */
  locationId: string;
  /** Timestamp the order was marked as rejected */
  rejectedAt?: string;
  /** Actual delivery time */
  actualDeliveryTime?: string;
  /** Menu ID that was used for this order */
  menuId?: string;
  /** Order Identifer */
  id: string;
  /** Estimated pick up time */
  estimatedPickupTime?: string;
  /** Timestamp the order was accepted */
  acceptedAt?: string;
  /** Timestamp the order was updated */
  updatedAt: string;
  /** Delivery details (Exists when fulfillment type is DELIVERY) */
  delivery?: OrderEntityDelivery;
  /** Timestamp the order was completed */
  completedAt?: string;
  /** ID of the client the order belongs to */
  clientId: string;
  /** Location Name */
  locationName: string;
  /** Last client to update the order */
  updatedBy: string;
  cancellationReason?: OrderCancelReason;
  /** Timestamp the order was cancelled */
  cancelledAt?: string;
  /** List of order taxes */
  tax: OrderTax[];
  /** Reseller Identifier (format: uuid) */
  resellerId: string;
  /** ID of the account the order belongs to */
  accountId: string;
  /** Order placed on timestamp */
  placedOn: string;
  /** Payment status */
  isPaid?: boolean;
  /** List of order charges */
  charges: OrderCharge[];
  driver?: OrderDriver;
  /** Client that created the order */
  createdBy: string;
  /** Scheduled order status */
  isScheduledOrder?: boolean;
  /** Order Id */
  partnerId?: string;
  /** Order source name */
  sourceName: OrderEntitySourceName;
  /** List of order items */
  items: OrderItem[];
  status: OrderStatus;
  customer: OrderCustomer;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListAccountsResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: AccountEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

export interface GetDispatchedByIdResponse {
  data?: DeliveryDispatch;
}

/**
 * Action the driver should take with the order contents when the delivery status is FAILED.
 */
export type ResellerDeliveryCreateEntityFailureAction = typeof ResellerDeliveryCreateEntityFailureAction[keyof typeof ResellerDeliveryCreateEntityFailureAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResellerDeliveryCreateEntityFailureAction = {
  RETURN: 'RETURN',
  DISPOSE: 'DISPOSE',
} as const;

export type ResellerDeliveryCreateEntityDropoff = {
  instructions?: string;
  address: Address;
  contactName: string;
  contactPhone: string;
};

export type ResellerDeliveryCreateEntityPickup = {
  instructions?: string;
  address: Address;
  contactName: string;
  contactPhone: string;
};

/**
 * The mode of delivery that is being requested for the delivery.
 */
export type ResellerDeliveryCreateEntityDeliveryMode = typeof ResellerDeliveryCreateEntityDeliveryMode[keyof typeof ResellerDeliveryCreateEntityDeliveryMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResellerDeliveryCreateEntityDeliveryMode = {
  ASAP: 'ASAP',
  SCHEDULED: 'SCHEDULED',
} as const;

/**
 * The strategy to use when auto selecting a quote for dispatch
 */
export type ResellerDeliveryCreateEntityAutoDispatchSelectionStrategy = typeof ResellerDeliveryCreateEntityAutoDispatchSelectionStrategy[keyof typeof ResellerDeliveryCreateEntityAutoDispatchSelectionStrategy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ResellerDeliveryCreateEntityAutoDispatchSelectionStrategy = {
  PRICE: 'PRICE',
  RANK: 'RANK',
} as const;

export interface ResellerDeliveryCreateEntity {
  /** If provided, this confirmation code will be used by the delviery driver to confirm the delivery. */
  confirmationCode?: string;
  package: DeliveryPackage;
  /** Action the driver should take with the order contents when the delivery status is FAILED. */
  failureAction: ResellerDeliveryCreateEntityFailureAction;
  /** Optional order ID associated with the delivery, if applicable. this id must be owned by the specified locationId */
  orderId?: string;
  dropoff: ResellerDeliveryCreateEntityDropoff;
  pickup: ResellerDeliveryCreateEntityPickup;
  /** When enabled, if the first provider fails to honor the pickup time we will search for another provider */
  autoDispatchFailoverEnabled?: boolean;
  /**
   * The number of seconds after the estimated pickup time to trigger the auto dispatch
   * @minimum 0
   * @maximum 900
   */
  autoDispatchFailoverGraceTime?: number;
  /** A list of application ids that determine the rank (when RANK selection strategy is used) */
  autoDispatchSelectionRanking?: string[];
  /** The account ID of the location the delivery is for. */
  accountId: string;
  /** The mode of delivery that is being requested for the delivery. */
  deliveryMode: ResellerDeliveryCreateEntityDeliveryMode;
  /** The location ID the delivery is for (must be apart of the account specified within accountId). */
  locationId: string;
  /** When true, the delivery will be automatically dispatched based on the location preferences. */
  autoDispatchEnabled?: boolean;
  /** The estimated time for the driver to arrive at the dropoff location. */
  estimatedDropoffTime?: string;
  /** When true, the driver should be requested to provide proof of delivery, typically in the form of an image or confirmation code. */
  proofRequired: boolean;
  /** The strategy to use when auto selecting a quote for dispatch */
  autoDispatchSelectionStrategy?: ResellerDeliveryCreateEntityAutoDispatchSelectionStrategy;
  /** The estimated time for the driver to arrive at the pickup location. */
  estimatedPickupTime?: string;
}

/**
 * The category of tax calculation:
- "FIXED" means the tax is a fixed amount per item (e.g. $1.50 per item).
- "PERCENTAGE" means the tax is a percentage of the item price (e.g. 5% of the item price).
 */
export type TaxRateType = typeof TaxRateType[keyof typeof TaxRateType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TaxRateType = {
  FIXED: 'FIXED',
  PERCENTAGE: 'PERCENTAGE',
} as const;

export interface TaxRate {
  /** Indicates if this tax is inclusive in prices or added on top:
false (default) means the tax is applied on top of item prices (i.e. prices are before tax, and this tax will be added at checkout).
true means the tax is already included in listed prices (common for VAT systems). */
  inclusive?: boolean;
  /** Indicates if this tax rate is the default tax rate */
  isDefault?: boolean;
  /**
   * The tax rate value expressed as an integer. Its interpretation depends on the tax type:
- If type is "FIXED": the rate is the fixed tax amount in the smallest currency unit (e.g. cents), such as 150 for $1.50.
- If type is "PERCENTAGE": An integer representing a tax value scaled by a factor of 10,000 (e.g. 12.275% is 12275).
   * @minimum 0
   * @maximum 1000000
   */
  rate: number;
  /** The human-readable name of the tax. This typically corresponds to what the merchant calls the tax (e.g. ‚ÄúNY Sales Tax‚Äù, ‚ÄúVAT 20%‚Äù, ‚ÄúService Fee‚Äù). */
  name: string;
  /** The identifier of the tax in the external system */
  posReference: string;
  /** The category of tax calculation:
- "FIXED" means the tax is a fixed amount per item (e.g. $1.50 per item).
- "PERCENTAGE" means the tax is a percentage of the item price (e.g. 5% of the item price). */
  type?: TaxRateType;
}

/**
 * The API code for the payment type. Orders with this payment type will be tagged with this code.
 */
export type PaymentTypeCode = typeof PaymentTypeCode[keyof typeof PaymentTypeCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PaymentTypeCode = {
  CASH: 'CASH',
  CARD: 'CARD',
  GIFT_CARD: 'GIFT_CARD',
  OTHER: 'OTHER',
} as const;

export interface PaymentType {
  /** Indicates if this tax rate is the default tax rate */
  isDefault?: boolean;
  /** The API code for the payment type. Orders with this payment type will be tagged with this code. */
  code: PaymentTypeCode;
  /** The name of the payment type. This is the name that will be displayed to the user. */
  name: string;
  /** If this payment type was imported from a POS system, this field will contain the reference to the original payment type. */
  posReference: string;
  /** Indicates if this tax rate is active */
  isActive?: boolean;
}

/**
 * Type of product, either product, variant or modifier
 */
export type CatalogProductEntityType = typeof CatalogProductEntityType[keyof typeof CatalogProductEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogProductEntityType = {
  PRODUCT: 'PRODUCT',
  VARIANT: 'VARIANT',
  MODIFIER: 'MODIFIER',
} as const;

/**
 * Catalog Variant Parent Identifier
 */
export type CatalogProductEntityParentId = { [key: string]: unknown };

export interface CatalogProductEntity {
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Product Description */
  description: string;
  /** Type of product, either product, variant or modifier */
  type?: CatalogProductEntityType;
  /** Ids of catalog modifier groups the item is mapped to */
  modifierGroups: string[];
  /** An external url to the original image from the POS */
  originalImageUrl?: string;
  /** Catalog Product Creation Date */
  createdAt: string;
  /** Catalog Product Is Bike Friendly */
  isBikeFriendly?: boolean;
  /** Location Identifier */
  locationId: string;
  /**
   * Catalog Product Price
   * @minimum 0
   * @maximum 999999999
   */
  price: number;
  /** Catalog Product Image */
  imageUrl?: string;
  /** Catalog Product Contains Tobacco */
  containsTobacco?: boolean;
  /** Catalog Product Identifier */
  id: string;
  /** Ids of catalog categories the item is mapped to */
  categories: string[];
  /** Catalog Product Update Date */
  updatedAt: string;
  nutritionalInfo?: NutritionalInfo;
  /** Catalog Product Contains Alcohol */
  containsAlcohol?: boolean;
  /** Catalog Variant Parent Identifier */
  parentId?: CatalogProductEntityParentId;
  /** Account Identifier */
  accountId: string;
  /** Catalog Product Show Online */
  showOnline: boolean;
  /** Selections for the product */
  selections?: CatalogProductSelection[];
  /** Catalog Product Name */
  name: string;
  serviceAvailability?: ServiceAvailability;
  /** POS Product Reference */
  posReference: string;
  /** Position of the catalog product */
  position?: number;
  /**
   * When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders.
   * @minimum 0
   * @maximum 999999999
   */
  inStorePrice?: number;
}

/**
 * An ISO 3166-1 alpha-2 Country Code.
 */
export type CountryCode = typeof CountryCode[keyof typeof CountryCode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CountryCode = {
  US: 'US',
  CA: 'CA',
  GB: 'GB',
  AU: 'AU',
  NZ: 'NZ',
  DE: 'DE',
  FR: 'FR',
  ES: 'ES',
  IT: 'IT',
  NL: 'NL',
  MX: 'MX',
} as const;

/**
 * The content type of the file
 */
export type SignedUrlRequestContentType = typeof SignedUrlRequestContentType[keyof typeof SignedUrlRequestContentType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SignedUrlRequestContentType = {
  'image/jpeg': 'image/jpeg',
  'image/png': 'image/png',
  'image/webp': 'image/webp',
} as const;

export interface SignedUrlRequest {
  /**
   * The size of the file in bytes (Max 50MB)
   * @maximum 50000000
   */
  contentSize: number;
  /** The content type of the file */
  contentType: SignedUrlRequestContentType;
  /** The file's original filename, e.g image.jpg or image.png */
  originalFilename: string;
}

/**
 * This field represents the status of the connection from the perspective of the application, i.e the application is connected to the location but the application may not have access to the downstream services.
 */
export type ConnectionEntityStatus = typeof ConnectionEntityStatus[keyof typeof ConnectionEntityStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionEntityStatus = {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
} as const;

export interface ConnectionEntity {
  /** Next Auto Publish date */
  nextAutoPublishAt?: string;
  /** Auto Publish Interval in minutes */
  autoPublishInterval?: number;
  /** Reseller Identifier (format: uuid) */
  resellerId: string;
  /** Account Identifier */
  accountId: string;
  /** Creation date */
  createdAt?: string;
  /** Last Menu Synced Date */
  lastMenuSyncedAt?: string;
  /** Location Identifier */
  locationId: string;
  /** Failure Reason for the connection */
  failureReason?: string;
  /** Identifier */
  id: string;
  /** Application Identifier */
  applicationId: string;
  /** This field represents the status of the connection from the perspective of the application, i.e the application is connected to the location but the application may not have access to the downstream services. */
  status: ConnectionEntityStatus;
  /** Last Menu ID That was syncronised to this location */
  lastMenuSyncId?: string;
  /** Update date */
  updatedAt: string;
}

export interface MenuModifierPatchEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Menu Modifier Contains Alcohol */
  containsAlcohol?: boolean;
  /** Maximum number of items that must be selected (inclusive) */
  maxPermitted?: number;
  /** Menu Modifier Description */
  description?: string;
  /** Menu Modifier is Bike Friendly */
  isBikeFriendly?: boolean;
  /** Menu Modifier Online Availability */
  showOnline?: boolean;
  /** Menu Modifier Price */
  price?: number;
  /** Image URL of the modifier */
  imageUrl?: string;
  /** Menu Modifier Name */
  name?: string;
  /** Menu Modifier Contains Tabacco */
  containsTobacco?: boolean;
  /** Position of the menu modifier */
  position?: number;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted?: number;
  /** When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders. */
  inStorePrice?: number;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListLocationsResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: LocationEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

export interface GetLocationByIdResponse {
  data?: LocationEntity;
}

export interface ResellerAccountPatchEntity {
  /** Account phone number */
  phoneNumber?: string;
  address?: Address;
  /** Timezone associated with the account (e.g., "America/New_York"). */
  timezone?: string;
  countryCode?: CountryCode;
  /** Account name */
  name?: string;
  /** Last user ID */
  lastOwnerId?: string;
  currency?: CurrencyCode;
  /** User ID */
  ownerId?: string;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListProductsResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: CatalogProductEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

/**
 * Generic theme properties
 */
export type ResellerEntityTheme = { [key: string]: unknown };

export interface ResellerEntity {
  /** Reseller Created At */
  createdAt: string;
  /** Reseller Domain Name (e.g. acme.com) */
  domainName?: string;
  /** Reseller Name */
  name: string;
  /** Reseller Logo */
  logo?: string;
  /** Generic theme properties */
  theme?: ResellerEntityTheme;
  /** Reseller Identifier */
  id: string;
  /** The user id that owns this reseller entity */
  ownerId?: string;
  /** Reseller Updated At */
  updatedAt: string;
}

/**
 * Category of the application, e.g., POS, ORDERING.
 */
export type ApplicationCreateEntityCategory = typeof ApplicationCreateEntityCategory[keyof typeof ApplicationCreateEntityCategory];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApplicationCreateEntityCategory = {
  MARKETPLACE: 'MARKETPLACE',
  POS: 'POS',
  DELIVERY: 'DELIVERY',
  OTHER: 'OTHER',
} as const;

/**
 * Application Create Entity
 */
export interface ApplicationCreateEntity {
  /** URL for dispatching a delivery quote (applicable only for DELIVERY applications). */
  dispatchDeliveryQuoteUrl?: string;
  /** Brief description of the application. */
  description: string;
  /** List of allowed countries this application can be used in. */
  allowedCountries?: CountryCode[];
  /** List of redirect URIs permitted for this application. */
  redirectUris: string[];
  /** URL for getting delivery quotes for a given delivery (applicable only for DELIVERY applications). */
  getDeliveryQuoteUrl?: string;
  /** URL for cancelling a dispatched delivery (applicable only for DELIVERY applications). */
  cancelDeliveryUrl?: string;
  /** URL for getting the latest details for adispatched delivery (applicable only for DELIVERY applications). */
  getDeliveryUrl?: string;
  /** URL for catalog synchronization (only used for POS applications). */
  catalogSyncUrl?: string;
  /** Display name of the application. */
  name: string;
  /** URL for menu publication (if applicable). */
  menuPublicationUrl?: string;
  scopes: ApplicationScopes;
  /** Webhook endpoint URL for the application. */
  webhookEndpoint?: string;
  /** Category of the application, e.g., POS, ORDERING. */
  category: ApplicationCreateEntityCategory;
}

export type CatalogModifierGroupEntityModifiersItem = {
  /**
   * Catalog Modifier Price
   * @minimum 0
   * @maximum 999999999
   */
  price: number;
  /** Catalog Modifier Name */
  name: string;
  /** Catalog Modifier ID */
  id: string;
};

export interface CatalogModifierGroupEntity {
  /** Maximum number of items that must be selected (inclusive) */
  maxPermitted: number;
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Modifier Group Description */
  description?: string;
  modifiers: CatalogModifierGroupEntityModifiersItem[];
  /** Account Identifier */
  accountId: string;
  /** Catalog Modifier Group created at timestamp */
  createdAt: string;
  /** Location Identifier */
  locationId: string;
  /** Catalog Modifier Group Name */
  name: string;
  /** Unique POS Reference ID */
  posReference: string;
  /** Catalog Modifier Group Identifier */
  id: string;
  /**
   * Minimum number of items that must be selected (inclusive)
   * @minimum 0
   */
  minPermitted: number;
  /** Position of the catalog modifier group */
  position?: number;
  /** Catalog Modifier Group updated at timestamp */
  updatedAt: string;
}

/**
 * Order Tax
 */
export interface OrderTax {
  /** Tax Amount (e.g: 1000 = ¬£10.00) */
  amount: number;
  /** Display name */
  displayName?: string;
  /** Tax name */
  name: string;
}

export interface GetAccountMenuCategoryByIdResponse {
  data?: MenuCategoryEntity;
}

/**
 * Type of product, either product, variant or modifier
 */
export type CatalogProductPatchEntityType = typeof CatalogProductPatchEntityType[keyof typeof CatalogProductPatchEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogProductPatchEntityType = {
  PRODUCT: 'PRODUCT',
  VARIANT: 'VARIANT',
  MODIFIER: 'MODIFIER',
} as const;

/**
 * Catalog Variant Parent Identifier
 */
export type CatalogProductPatchEntityParentId = { [key: string]: unknown };

export interface CatalogProductPatchEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Whether the product contains alcohol */
  containsAlcohol?: boolean;
  /** A version string that represents the version of this entity in the POS, such as a iso timestamp, epoch timestamp, or a version number */
  posVersion?: string;
  /** Catalog Product Description */
  description?: string;
  /** Type of product, either product, variant or modifier */
  type?: CatalogProductPatchEntityType;
  /** Ids of catalog modifier groups the item is mapped to */
  modifierGroups?: string[];
  /** Catalog Variant Parent Identifier */
  parentId?: CatalogProductPatchEntityParentId;
  /** An external url to the original image from the POS */
  originalImageUrl?: string;
  /** Whether the product is bike friendly */
  isBikeFriendly?: boolean;
  /** Catalog Product Show Online */
  showOnline?: boolean;
  /** Selections for the product */
  selections?: CatalogProductSelection[];
  /**
   * Catalog Product Price
   * @minimum 0
   * @maximum 999999999
   */
  price?: number;
  /** Catalog Product Name */
  name?: string;
  /** Whether the product contains tobacco */
  containsTobacco?: boolean;
  serviceAvailability?: ServiceAvailability;
  /** Ids of catalog categories the item is mapped to */
  categories?: string[];
  /** Position of the catalog product */
  position?: number;
  /**
   * When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders.
   * @minimum 0
   * @maximum 999999999
   */
  inStorePrice?: number;
}

/**
 * Kilojoules
 */
export type NutritionalInfoKilojoules = {
  /** The lower range of the energy content */
  lowerRange?: number;
  /** The upper range of the energy content. */
  upperRange?: number;
};

/**
 * Carbohydrates
 */
export type NutritionalInfoCarbohydrates = {
  /** The lower range of the energy content */
  lowerRange?: number;
  /** The upper range of the energy content. */
  upperRange?: number;
};

/**
 * List of dietary restrictions in the product. Allow single value.
 */
export type NutritionalInfoDietaryRestriction = typeof NutritionalInfoDietaryRestriction[keyof typeof NutritionalInfoDietaryRestriction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NutritionalInfoDietaryRestriction = {
  VEGAN: 'VEGAN',
  VEGETARIAN: 'VEGETARIAN',
} as const;

/**
 * Saturated Fat
 */
export type NutritionalInfoSaturatedFat = {
  /** The lower range of the energy content */
  lowerRange?: number;
  /** The upper range of the energy content. */
  upperRange?: number;
};

/**
 * Salt
 */
export type NutritionalInfoSalt = {
  /** The lower range of the energy content */
  lowerRange?: number;
  /** The upper range of the energy content. */
  upperRange?: number;
};

/**
 * List of spiciness in the product.Allow single value.
 */
export type NutritionalInfoSpiciness = typeof NutritionalInfoSpiciness[keyof typeof NutritionalInfoSpiciness];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NutritionalInfoSpiciness = {
  MILD: 'MILD',
  MEDIUM: 'MEDIUM',
  HOT: 'HOT',
  UNKNOWN: 'UNKNOWN',
  VERY_HOT: 'VERY_HOT',
} as const;

/**
 * Protein
 */
export type NutritionalInfoProtein = {
  /** The lower range of the energy content */
  lowerRange?: number;
  /** The upper range of the energy content. */
  upperRange?: number;
};

/**
 * Calories
 */
export type NutritionalInfoCalories = {
  /** The lower range of the energy content */
  lowerRange?: number;
  /** The upper range of the energy content. */
  upperRange?: number;
};

/**
 * Sugar
 */
export type NutritionalInfoSugar = {
  /** The lower range of the energy content */
  lowerRange?: number;
  /** The upper range of the energy content. */
  upperRange?: number;
};

export type NutritionalInfoAdditiveItem = typeof NutritionalInfoAdditiveItem[keyof typeof NutritionalInfoAdditiveItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NutritionalInfoAdditiveItem = {
  UNSPECIFIED: 'UNSPECIFIED',
  COLORANT_UNSPECIFIED: 'COLORANT_UNSPECIFIED',
  COLORANT_ADVERSE_EFFECT: 'COLORANT_ADVERSE_EFFECT',
  PRESERVATIVES_UNSPECIFIED: 'PRESERVATIVES_UNSPECIFIED',
  PRESERVATIVES_NITRITE_CURING_SALT: 'PRESERVATIVES_NITRITE_CURING_SALT',
  PRESERVATIVES_NITRATE: 'PRESERVATIVES_NITRATE',
  PRESERVATIVES_NITRATE_CURING_SALT_AND_NITRATE: 'PRESERVATIVES_NITRATE_CURING_SALT_AND_NITRATE',
  ANTIOXIDANT: 'ANTIOXIDANT',
  FLAVOURE_ENHANCER: 'FLAVOURE_ENHANCER',
  SULFITES: 'SULFITES',
  BLACKENED: 'BLACKENED',
  WAXED: 'WAXED',
  PHOSPHATE: 'PHOSPHATE',
  SWEETENER_UNSPECIFIED: 'SWEETENER_UNSPECIFIED',
  SWEETENER_PHENYLALANINE: 'SWEETENER_PHENYLALANINE',
  SWEETENER_LAXATIVE: 'SWEETENER_LAXATIVE',
  ACIDIFIERS: 'ACIDIFIERS',
  CAFFEINE_UNSPECIFIED: 'CAFFEINE_UNSPECIFIED',
  CAFFEINE_HIGH_CAFFEINE: 'CAFFEINE_HIGH_CAFFEINE',
  PROTEIN_STARCH: 'PROTEIN_STARCH',
  CAFFEINE_CAFFEINE: 'CAFFEINE_CAFFEINE',
  QUININE: 'QUININE',
  GENETICALLY_MODIFIED: 'GENETICALLY_MODIFIED',
  STABILISERS: 'STABILISERS',
  PROTEIN_UNSPECIFIED: 'PROTEIN_UNSPECIFIED',
  PROTEIN_MILK_PROTEIN: 'PROTEIN_MILK_PROTEIN',
  PROTEIN_EGG_WHITE: 'PROTEIN_EGG_WHITE',
} as const;

export type NutritionalInfoAllergensItem = typeof NutritionalInfoAllergensItem[keyof typeof NutritionalInfoAllergensItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NutritionalInfoAllergensItem = {
  NO_ALLERGENS: 'NO ALLERGENS',
  GLUTEN: 'GLUTEN',
  CEREAL_UNSPECIFIED: 'CEREAL_UNSPECIFIED',
  CEREAL_WHEAT: 'CEREAL_WHEAT',
  CEREAL_RYE: 'CEREAL_RYE',
  CEREAL_BARLEY: 'CEREAL_BARLEY',
  CEREAL_OATS: 'CEREAL_OATS',
  CEREAL_SPELT: 'CEREAL_SPELT',
  CEREAL_KAMUT: 'CEREAL_KAMUT',
  CRUSTACEANS: 'CRUSTACEANS',
  EGGS: 'EGGS',
  FISH: 'FISH',
  PEANUTS: 'PEANUTS',
  SOYBEANS: 'SOYBEANS',
  MILK: 'MILK',
  NUTS_UNSPECIFIED: 'NUTS_UNSPECIFIED',
  NUTS_ALMONDS: 'NUTS_ALMONDS',
  NUTS_HAZELNUTS: 'NUTS_HAZELNUTS',
  NUTS_WALNUTS: 'NUTS_WALNUTS',
  NUTS_CASHEWS: 'NUTS_CASHEWS',
  NUTS_PECAN: 'NUTS_PECAN',
  NUTS_BRAZIL: 'NUTS_BRAZIL',
  NUTS_PISTACHIO: 'NUTS_PISTACHIO',
  NUTS_MACADAMIA: 'NUTS_MACADAMIA',
  NUTS_QUEENSLAND: 'NUTS_QUEENSLAND',
  CELERY: 'CELERY',
  MUSTARD: 'MUSTARD',
  SESAME_SEEDS: 'SESAME_SEEDS',
  SULPHUR_DIOXIDE_SULPHITES: 'SULPHUR_DIOXIDE_SULPHITES',
  LUPIN: 'LUPIN',
  MOLLUSCS: 'MOLLUSCS',
} as const;

/**
 * Nutritional Information
 */
export interface NutritionalInfo {
  /** Kilojoules */
  kilojoules?: NutritionalInfoKilojoules;
  /** Carbohydrates */
  carbohydrates?: NutritionalInfoCarbohydrates;
  /** List of dietary restrictions in the product. Allow single value. */
  dietaryRestriction?: NutritionalInfoDietaryRestriction;
  /** Saturated Fat */
  saturatedFat?: NutritionalInfoSaturatedFat;
  /** Salt */
  salt?: NutritionalInfoSalt;
  /** List of spiciness in the product.Allow single value. */
  spiciness?: NutritionalInfoSpiciness;
  /** Protein */
  protein?: NutritionalInfoProtein;
  /** Calories */
  calories?: NutritionalInfoCalories;
  /** Sugar */
  sugar?: NutritionalInfoSugar;
  /** List of additive in the product. Allow multiple values */
  additive?: NutritionalInfoAdditiveItem[];
  /** List of allergens in the product. Allow multiple values */
  allergens?: NutritionalInfoAllergensItem[];
}

/**
 * The strategy to use when auto selecting a quote for dispatch
 */
export type LocationEntityDeliveryAutoDispatchSelectionStrategy = typeof LocationEntityDeliveryAutoDispatchSelectionStrategy[keyof typeof LocationEntityDeliveryAutoDispatchSelectionStrategy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LocationEntityDeliveryAutoDispatchSelectionStrategy = {
  PRICE: 'PRICE',
  RANK: 'RANK',
} as const;

/**
 * Reference to the schema defining the business hours.
 */
export type LocationEntityAvailability = {
  delivery?: ServiceAvailability;
  collection?: ServiceAvailability;
};

/**
 * The default action to take when a delivery fails (e.g., "RETURN" or "DISPOSE").
 */
export type LocationEntityDeliveryDefaultFailureAction = typeof LocationEntityDeliveryDefaultFailureAction[keyof typeof LocationEntityDeliveryDefaultFailureAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LocationEntityDeliveryDefaultFailureAction = {
  RETURN: 'RETURN',
  DISPOSE: 'DISPOSE',
} as const;

export interface LocationEntity {
  /**
   * The number of seconds after the order has "started" that the order should be auto closed. This is only applicable if autoCloseOrders is enabled. (min: 3 hours, max: 24 hours, default is 3 hours)
   * @minimum 1800
   * @maximum 86400
   */
  autoCloseOrdersAfter?: number;
  /** Contact Person's Last Name */
  lastName?: string;
  /** The strategy to use when auto selecting a quote for dispatch */
  deliveryAutoDispatchSelectionStrategy?: LocationEntityDeliveryAutoDispatchSelectionStrategy;
  /** Timezone of the location (e.g., "Europe/London"). */
  timezone: string;
  /** Reference to the schema defining the business hours. */
  availability?: LocationEntityAvailability;
  /** A list of application ids that determine the rank (when RANK selection strategy is used) */
  deliveryAutoDispatchSelectionRanking?: string[];
  /** Timestamp when the location was created. */
  createdAt: string;
  /** List of tax rates applicable to the location */
  taxRates?: TaxRate[];
  /** When enabled, a delivery will be created automatically for self delivery orders */
  autoCreateDeliveryOnDeliveryOrder?: boolean;
  countryCode?: CountryCode;
  currency?: CurrencyCode;
  /** Unique identifier for the location */
  id: string;
  /** List of payment types accepted at the location */
  paymentTypes?: PaymentType[];
  /** Contact Person's Email Address */
  email?: string;
  /** Timestamp when the location was last updated. */
  updatedAt: string;
  /** The default action to take when a delivery fails (e.g., "RETURN" or "DISPOSE"). */
  deliveryDefaultFailureAction?: LocationEntityDeliveryDefaultFailureAction;
  address: Address;
  /** Indicates if orders should be automatically closed after a certain period of time. */
  autoCloseOrders?: boolean;
  /** When enabled, if the first provider fails to honor the pickup time we will search for another provider */
  deliveryAutoDispatchFailoverEnabled?: boolean;
  businessHours?: ServiceAvailability;
  /** Indicates if deliveries should be automatically dispatched when created. */
  deliveryAutoDispatchEnabled?: boolean;
  /** Identifier for the associated reseller */
  resellerId: string;
  /** Identifier for the associated account */
  accountId: string;
  /** Contact Person's First Name */
  firstName?: string;
  /** Valid E.164 phone number (e.g., +14155552671). */
  phoneNumber: string;
  /**
   * The number of seconds after the estimated pickup time to trigger the auto dispatch
   * @minimum 0
   * @maximum 900
   */
  deliveryAutoDispatchFailoverGraceTime?: number;
  /** Name of the location (e.g., "Acme Inc - London"). */
  name: string;
  /** Default instructions for the pickup location. */
  deliveryDefaultPickupInstructions?: string;
  /** Indicates if proof of delivery is required by default for deliveries. */
  deliveryDefaultProofRequired?: boolean;
  /** The identifier for this location within the POS system. */
  posReference?: string;
}

/**
 * Type of product, either product, variant or modifier
 */
export type MenuItemCreateEntityType = typeof MenuItemCreateEntityType[keyof typeof MenuItemCreateEntityType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MenuItemCreateEntityType = {
  PRODUCT: 'PRODUCT',
  VARIANT: 'VARIANT',
  MODIFIER: 'MODIFIER',
} as const;

/**
 * Menu Variant Parent Identifier
 */
export type MenuItemCreateEntityParentId = { [key: string]: unknown };

export interface MenuItemCreateEntity {
  nutritionalInfo?: NutritionalInfo;
  /** Menu Item Contains Alcohol */
  containsAlcohol?: boolean;
  /** Identifier of the catalog product this item corresponds to */
  catalogProductId: string;
  /** Menu Item Description */
  description?: string;
  fulfillmentTypes?: FulfillmentTypes;
  /** Type of product, either product, variant or modifier */
  type?: MenuItemCreateEntityType;
  modifierGroups: string[];
  /** Menu Variant Parent Identifier */
  parentId?: MenuItemCreateEntityParentId;
  /** Menu Item is Bike Friendly */
  isBikeFriendly?: boolean;
  /** Menu Item Online Availability */
  showOnline?: boolean;
  /** Selections for the menu item */
  selections?: MenuItemSelection[];
  /**
   * Menu Item Price
   * @minimum 0
   * @maximum 999999999
   */
  price: number;
  /** Menu Item Image */
  imageUrl?: string;
  /** Menu Item Name */
  name: string;
  /** Menu Item Contains Tobacco */
  containsTobacco?: boolean;
  serviceAvailability?: ServiceAvailability;
  /** Ids of menu categories the item is mapped to */
  categories?: string[];
  /** Position of the menu item */
  position?: number;
  /**
   * When provided, the inStorePrice value will be shared with partners that are able to offer a different price for ‚ÄúIn Store‚Äù orders.
   * @minimum 0
   * @maximum 999999999
   */
  inStorePrice?: number;
}

/**
 * Discount Name
 */
export type OrderDiscountName = typeof OrderDiscountName[keyof typeof OrderDiscountName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderDiscountName = {
  LOYALTY: 'LOYALTY',
  OTHER: 'OTHER',
} as const;

/**
 * Discount type
 */
export type OrderDiscountType = typeof OrderDiscountType[keyof typeof OrderDiscountType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderDiscountType = {
  FIXED: 'FIXED',
  PERCENTAGE: 'PERCENTAGE',
} as const;

/**
 * Order Discount
 */
export interface OrderDiscount {
  /** Discount Amount (e.g: 1000 = ¬£10.00) */
  amount: number;
  /** Display name */
  displayName?: string;
  /** Discount Name */
  name: OrderDiscountName;
  /** Discount type */
  type?: OrderDiscountType;
}

export interface GetAccountCatalogExportResponse {
  data?: CatalogExportEntity;
}

/**
 * This schema defines how a list of entities are returned, A list of entities is returned with a token to retrieve the next page of results.
 */
export interface ListOrdersResponse {
  /** Token to retrieve the next page of results, this can eb sent back to the server to get the next page. */
  nextPageKey?: string;
  /** The list of entities returned */
  data: OrderEntity[];
  /** Boolean indicating if there is a next page available. */
  hasNextPage: boolean;
}

/**
 * The type of event that is being triggered
 */
export type LocationWebhookEventEventType = typeof LocationWebhookEventEventType[keyof typeof LocationWebhookEventEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LocationWebhookEventEventType = {
  INSERT: 'INSERT',
  MODIFY: 'MODIFY',
  REMOVE: 'REMOVE',
} as const;

/**
 * The type of object that the event is for
 */
export type LocationWebhookEventObjectType = typeof LocationWebhookEventObjectType[keyof typeof LocationWebhookEventObjectType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LocationWebhookEventObjectType = {
  LOCATION: 'LOCATION',
} as const;

export interface LocationWebhookEvent {
  /** The unique identifier for the event */
  eventId: string;
  /** If event occured within the context of an account, this will be the account ID */
  accountId?: string;
  /** The client ID that the event is for */
  clientId: string;
  /** If event occured within the context of an order, this will be the order ID */
  orderId?: string;
  /** If event occured within the context of a location, this will be the location ID */
  locationId?: string;
  /** The time the event was created */
  eventTime: string;
  /** The unique connection id between the source and your application */
  connectionId: string;
  /** The type of event that is being triggered */
  eventType: LocationWebhookEventEventType;
  newState?: LocationEntity;
  /** The type of object that the event is for */
  objectType: LocationWebhookEventObjectType;
  previousState?: LocationEntity;
}

/**
 * The type of event that is being triggered
 */
export type OrderWebhookEventEventType = typeof OrderWebhookEventEventType[keyof typeof OrderWebhookEventEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderWebhookEventEventType = {
  INSERT: 'INSERT',
  MODIFY: 'MODIFY',
  REMOVE: 'REMOVE',
} as const;

/**
 * The type of object that the event is for
 */
export type OrderWebhookEventObjectType = typeof OrderWebhookEventObjectType[keyof typeof OrderWebhookEventObjectType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderWebhookEventObjectType = {
  ORDER: 'ORDER',
} as const;

export interface OrderWebhookEvent {
  /** The unique identifier for the event */
  eventId: string;
  /** If event occured within the context of an account, this will be the account ID */
  accountId?: string;
  /** The client ID that the event is for */
  clientId: string;
  /** If event occured within the context of an order, this will be the order ID */
  orderId?: string;
  /** If event occured within the context of a location, this will be the location ID */
  locationId?: string;
  /** The time the event was created */
  eventTime: string;
  /** The unique connection id between the source and your application */
  connectionId: string;
  /** The type of event that is being triggered */
  eventType: OrderWebhookEventEventType;
  newState?: OrderEntity;
  /** The type of object that the event is for */
  objectType: OrderWebhookEventObjectType;
  previousState?: OrderEntity;
}

/**
 * The type of event that is being triggered
 */
export type AccountWebhookEventEventType = typeof AccountWebhookEventEventType[keyof typeof AccountWebhookEventEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountWebhookEventEventType = {
  INSERT: 'INSERT',
  MODIFY: 'MODIFY',
  REMOVE: 'REMOVE',
} as const;

/**
 * The type of object that the event is for
 */
export type AccountWebhookEventObjectType = typeof AccountWebhookEventObjectType[keyof typeof AccountWebhookEventObjectType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountWebhookEventObjectType = {
  ACCOUNT: 'ACCOUNT',
} as const;

export interface AccountWebhookEvent {
  /** The unique identifier for the event */
  eventId: string;
  /** If event occured within the context of an account, this will be the account ID */
  accountId?: string;
  /** The client ID that the event is for */
  clientId: string;
  /** If event occured within the context of an order, this will be the order ID */
  orderId?: string;
  /** If event occured within the context of a location, this will be the location ID */
  locationId?: string;
  /** The time the event was created */
  eventTime: string;
  /** The unique connection id between the source and your application */
  connectionId: string;
  /** The type of event that is being triggered */
  eventType: AccountWebhookEventEventType;
  newState?: AccountEntity;
  /** The type of object that the event is for */
  objectType: AccountWebhookEventObjectType;
  previousState?: AccountEntity;
}

/**
 * The type of event that is being triggered
 */
export type MenuWebhookEventEventType = typeof MenuWebhookEventEventType[keyof typeof MenuWebhookEventEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MenuWebhookEventEventType = {
  INSERT: 'INSERT',
  MODIFY: 'MODIFY',
  REMOVE: 'REMOVE',
} as const;

/**
 * The type of object that the event is for
 */
export type MenuWebhookEventObjectType = typeof MenuWebhookEventObjectType[keyof typeof MenuWebhookEventObjectType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MenuWebhookEventObjectType = {
  MENU: 'MENU',
} as const;

export interface MenuWebhookEvent {
  /** The unique identifier for the event */
  eventId: string;
  /** If event occured within the context of an account, this will be the account ID */
  accountId?: string;
  /** The client ID that the event is for */
  clientId: string;
  /** If event occured within the context of an order, this will be the order ID */
  orderId?: string;
  /** If event occured within the context of a location, this will be the location ID */
  locationId?: string;
  /** The time the event was created */
  eventTime: string;
  /** The unique connection id between the source and your application */
  connectionId: string;
  /** The type of event that is being triggered */
  eventType: MenuWebhookEventEventType;
  newState?: MenuEntity;
  /** The type of object that the event is for */
  objectType: MenuWebhookEventObjectType;
  previousState?: MenuEntity;
}

/**
 * The type of event that is being triggered
 */
export type DeliveryWebhookEventEventType = typeof DeliveryWebhookEventEventType[keyof typeof DeliveryWebhookEventEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryWebhookEventEventType = {
  INSERT: 'INSERT',
  MODIFY: 'MODIFY',
  REMOVE: 'REMOVE',
} as const;

/**
 * The type of object that the event is for
 */
export type DeliveryWebhookEventObjectType = typeof DeliveryWebhookEventObjectType[keyof typeof DeliveryWebhookEventObjectType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DeliveryWebhookEventObjectType = {
  DELIVERY: 'DELIVERY',
} as const;

export interface DeliveryWebhookEvent {
  /** The unique identifier for the event */
  eventId: string;
  /** If event occured within the context of an account, this will be the account ID */
  accountId?: string;
  /** The client ID that the event is for */
  clientId: string;
  /** If event occured within the context of an order, this will be the order ID */
  orderId?: string;
  /** If event occured within the context of a location, this will be the location ID */
  locationId?: string;
  /** The time the event was created */
  eventTime: string;
  /** The unique connection id between the source and your application */
  connectionId: string;
  /** The type of event that is being triggered */
  eventType: DeliveryWebhookEventEventType;
  newState?: DeliveryEntity;
  /** The type of object that the event is for */
  objectType: DeliveryWebhookEventObjectType;
  previousState?: DeliveryEntity;
}

/**
 * The type of event that is being triggered
 */
export type ConnectionWebhookEventEventType = typeof ConnectionWebhookEventEventType[keyof typeof ConnectionWebhookEventEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionWebhookEventEventType = {
  INSERT: 'INSERT',
  MODIFY: 'MODIFY',
  REMOVE: 'REMOVE',
} as const;

/**
 * The type of object that the event is for
 */
export type ConnectionWebhookEventObjectType = typeof ConnectionWebhookEventObjectType[keyof typeof ConnectionWebhookEventObjectType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ConnectionWebhookEventObjectType = {
  CONNECTION: 'CONNECTION',
} as const;

export interface ConnectionWebhookEvent {
  /** The unique identifier for the event */
  eventId: string;
  /** If event occured within the context of an account, this will be the account ID */
  accountId?: string;
  /** The client ID that the event is for */
  clientId: string;
  /** If event occured within the context of an order, this will be the order ID */
  orderId?: string;
  /** If event occured within the context of a location, this will be the location ID */
  locationId?: string;
  /** The time the event was created */
  eventTime: string;
  /** The unique connection id between the source and your application */
  connectionId: string;
  /** The type of event that is being triggered */
  eventType: ConnectionWebhookEventEventType;
  newState?: ConnectionEntity;
  /** The type of object that the event is for */
  objectType: ConnectionWebhookEventObjectType;
  previousState?: ConnectionEntity;
}

/**
 * The type of event that is being triggered
 */
export type CatalogProductWebhookEventEventType = typeof CatalogProductWebhookEventEventType[keyof typeof CatalogProductWebhookEventEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogProductWebhookEventEventType = {
  INSERT: 'INSERT',
  MODIFY: 'MODIFY',
  REMOVE: 'REMOVE',
} as const;

/**
 * The type of object that the event is for
 */
export type CatalogProductWebhookEventObjectType = typeof CatalogProductWebhookEventObjectType[keyof typeof CatalogProductWebhookEventObjectType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogProductWebhookEventObjectType = {
  CATALOG_PRODUCT: 'CATALOG_PRODUCT',
} as const;

export interface CatalogProductWebhookEvent {
  /** The unique identifier for the event */
  eventId: string;
  /** If event occured within the context of an account, this will be the account ID */
  accountId?: string;
  /** The client ID that the event is for */
  clientId: string;
  /** If event occured within the context of an order, this will be the order ID */
  orderId?: string;
  /** If event occured within the context of a location, this will be the location ID */
  locationId?: string;
  /** The time the event was created */
  eventTime: string;
  /** The unique connection id between the source and your application */
  connectionId: string;
  /** The type of event that is being triggered */
  eventType: CatalogProductWebhookEventEventType;
  newState?: CatalogProductEntity;
  /** The type of object that the event is for */
  objectType: CatalogProductWebhookEventObjectType;
  previousState?: CatalogProductEntity;
}

/**
 * The type of event that is being triggered
 */
export type CatalogCategoryWebhookEventEventType = typeof CatalogCategoryWebhookEventEventType[keyof typeof CatalogCategoryWebhookEventEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogCategoryWebhookEventEventType = {
  INSERT: 'INSERT',
  MODIFY: 'MODIFY',
  REMOVE: 'REMOVE',
} as const;

/**
 * The type of object that the event is for
 */
export type CatalogCategoryWebhookEventObjectType = typeof CatalogCategoryWebhookEventObjectType[keyof typeof CatalogCategoryWebhookEventObjectType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogCategoryWebhookEventObjectType = {
  CATALOG_CATEGORY: 'CATALOG_CATEGORY',
} as const;

export interface CatalogCategoryWebhookEvent {
  /** The unique identifier for the event */
  eventId: string;
  /** If event occured within the context of an account, this will be the account ID */
  accountId?: string;
  /** The client ID that the event is for */
  clientId: string;
  /** If event occured within the context of an order, this will be the order ID */
  orderId?: string;
  /** If event occured within the context of a location, this will be the location ID */
  locationId?: string;
  /** The time the event was created */
  eventTime: string;
  /** The unique connection id between the source and your application */
  connectionId: string;
  /** The type of event that is being triggered */
  eventType: CatalogCategoryWebhookEventEventType;
  newState?: CatalogCategoryEntity;
  /** The type of object that the event is for */
  objectType: CatalogCategoryWebhookEventObjectType;
  previousState?: CatalogCategoryEntity;
}

/**
 * The type of event that is being triggered
 */
export type CatalogModifierGroupWebhookEventEventType = typeof CatalogModifierGroupWebhookEventEventType[keyof typeof CatalogModifierGroupWebhookEventEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogModifierGroupWebhookEventEventType = {
  INSERT: 'INSERT',
  MODIFY: 'MODIFY',
  REMOVE: 'REMOVE',
} as const;

/**
 * The type of object that the event is for
 */
export type CatalogModifierGroupWebhookEventObjectType = typeof CatalogModifierGroupWebhookEventObjectType[keyof typeof CatalogModifierGroupWebhookEventObjectType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogModifierGroupWebhookEventObjectType = {
  CATALOG_MODIFIER_GROUP: 'CATALOG_MODIFIER_GROUP',
} as const;

export interface CatalogModifierGroupWebhookEvent {
  /** The unique identifier for the event */
  eventId: string;
  /** If event occured within the context of an account, this will be the account ID */
  accountId?: string;
  /** The client ID that the event is for */
  clientId: string;
  /** If event occured within the context of an order, this will be the order ID */
  orderId?: string;
  /** If event occured within the context of a location, this will be the location ID */
  locationId?: string;
  /** The time the event was created */
  eventTime: string;
  /** The unique connection id between the source and your application */
  connectionId: string;
  /** The type of event that is being triggered */
  eventType: CatalogModifierGroupWebhookEventEventType;
  newState?: CatalogModifierGroupEntity;
  /** The type of object that the event is for */
  objectType: CatalogModifierGroupWebhookEventObjectType;
  previousState?: CatalogModifierGroupEntity;
}

/**
 * The type of event that is being triggered
 */
export type CatalogModifierWebhookEventEventType = typeof CatalogModifierWebhookEventEventType[keyof typeof CatalogModifierWebhookEventEventType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogModifierWebhookEventEventType = {
  INSERT: 'INSERT',
  MODIFY: 'MODIFY',
  REMOVE: 'REMOVE',
} as const;

/**
 * The type of object that the event is for
 */
export type CatalogModifierWebhookEventObjectType = typeof CatalogModifierWebhookEventObjectType[keyof typeof CatalogModifierWebhookEventObjectType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CatalogModifierWebhookEventObjectType = {
  CATALOG_MODIFIER: 'CATALOG_MODIFIER',
} as const;

export interface CatalogModifierWebhookEvent {
  /** The unique identifier for the event */
  eventId: string;
  /** If event occured within the context of an account, this will be the account ID */
  accountId?: string;
  /** The client ID that the event is for */
  clientId: string;
  /** If event occured within the context of an order, this will be the order ID */
  orderId?: string;
  /** If event occured within the context of a location, this will be the location ID */
  locationId?: string;
  /** The time the event was created */
  eventTime: string;
  /** The unique connection id between the source and your application */
  connectionId: string;
  /** The type of event that is being triggered */
  eventType: CatalogModifierWebhookEventEventType;
  newState?: CatalogModifierEntity;
  /** The type of object that the event is for */
  objectType: CatalogModifierWebhookEventObjectType;
  previousState?: CatalogModifierEntity;
}

export type GetV1ResellersResellerIdLocationsParams = {
nextPageKey?: string;
query?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdConnectionsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1ResellersResellerIdOrdersOrderIdAuditsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1ResellersResellerIdMetricsParams = {
range?: string;
};

export type GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetOauth2AuthorizeParams = {
/**
 * The response type
 */
response_type: string;
/**
 * An opaque value used by the client to maintain state between the request and callback
 */
state: string;
/**
 * The scopes to request access to
 */
scope: string;
/**
 * The client identifier issued to the client during the registration process
 */
client_id: string;
/**
 * The redirect URI to redirect the user to after authorization
 */
redirect_uri: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdMenusParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1UsersUserIdApplicationsApplicationIdAuditsParams = {
resourcePath?: string;
requestMethod?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
nextPageKey?: string;
responseCode?: string;
};

export type GetV1ResellersResellerIdAccountsParams = {
nextPageKey?: string;
query?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1ResellersResellerIdOrdersParams = {
fulfillmentType?: string;
query?: string;
status?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
nextPageKey?: string;
};

export type GetV1ResellersParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1UsersUserIdApplicationsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdDeliveriesParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdOrdersOrderIdAuditsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdOrdersParams = {
query?: string;
status?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
fulfillmentMethod?: string;
nextPageKey?: string;
/**
 * Filters orders by external partnerId
 */
partnerId?: string;
};

export type GetV1ResellersResellerIdDeliveriesParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams = {
fulfillmentType?: string;
query?: string;
status?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
nextPageKey?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdApplicationsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdMetricsParams = {
range?: string;
};

export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1ResellersResellerIdAccountsAccountIdLocationsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdAuditsParams = {
resourcePath?: string;
requestMethod?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
nextPageKey?: string;
responseCode?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdConnectionsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1ResellersResellerIdAuditsParams = {
query?: string;
resourcePath?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
clientId?: string;
accountId?: string;
requestMethod?: string;
nextPageKey?: string;
responseCode?: string;
};

export type GetV1AccountsAccountIdOrdersParams = {
query?: string;
status?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
fulfillmentMethod?: string;
nextPageKey?: string;
};

export type GetV1ResellersResellerIdUsersParams = {
nextPageKey?: string;
query?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

export type GetV1ResellersResellerIdAccountsAccountIdMetricsParams = {
range?: string;
};

export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams = {
nextPageKey?: string;
/**
 * *Pagination:* The number of items to return per page (max 50)
 */
limit?: string;
};

