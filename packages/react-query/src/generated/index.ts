/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * POS Hub API
 * ## Introduction

Welcome to the POS Hub API documentation. This guide is designed to provide you with all the necessary information to seamlessly integrate your application with the POS Hub platform. Whether you're integrating a point-of-sale system, a reporting tool, an order management system, or any other application that interacts with the POS Hub API, this documentation will serve as your comprehensive resource.

Within this documentation, you will find detailed explanations of the API standards, authentication processes, common integration patterns, and pagination techniques employed by the POS Hub API. We will guide you through the steps of authenticating your application, making authenticated requests, and managing token expiration and refresh processes.

By following this documentation, you will be able to harness the full potential of the POS Hub API to optimize your business operations, access valuable data, and deliver a seamless experience to your users.

Let‚Äôs get started!

## API

The API section provides a thorough overview of the standards adhered to by the POS Hub API. These standards are in place to ensure consistency and compatibility across all endpoints.

### API Features

- Detailed documentation is generated directly from our implementation code, ensuring accuracy and up-to-date information.
- OAuth2 standards are used for authenticating users and applications, as well as performing application onboarding via the authorization flow.
- Resource-oriented endpoints provide GET, POST, PUT, PATCH, and DELETE functionality across various entities.
- All HTTP communication is conducted exclusively over SSL, both internally between systems and externally with partners.
- Requests and responses are strictly formatted using application/json, including all error responses.
- Our endpoints support cursor-based pagination, enabling efficient data retrieval within a resource.
- We adhere to relevant ISO standards for common values, including ISO 8601 for dates/times, ISO 4217 for currency codes, and ISO 639-1 for language codes and E.164 to represent global phone numbers.

### API Contracts

It is important to understand that the POS Hub API defines schemas for both request, response and webhook payloads. These schemas serve as a contract between POS Hub and API consumers. Compliance with these schemas is crucial, as all fields, data types, required flags, enumerations, and other specifications are validated against this documentation. Careful adherence to this documentation is essential for successful integration with our API.

Our schemas define the following information:

- Property Names: (e.g., orderId, status)
- Property Types: (e.g., string, number, boolean, or another schema)
- Allowed Values: Specified by enumeration tags
- String Length and Numeric Size: Minimum and maximum values
- Value Formatting: Such as uuid, uri, or date-time
- Field Requirements: Required or optional fields

### Authentication

There are multiple methods of authentication depending on what your trying to, typically applications will be using the `client_credentials` flow, however we have outlined the different types below.

#### Password Grant

the `password` grant type is used if you as the account owner wishes to authenticate to gain user level access, this requires a username and password to autheneticate, this is useful for resellers who wish to build in house custom tooling, allowing them to create a user within the reseller and authenticate to perform api calls as that user.

Note: the `password` grant requires POS Hub team to authorize this grant for your application, this is typically only done for enterprise customers, if you need this grant please reach out to one of our team.

#### Client Credentials Grant

the `client_credentials` grant os the grant used when an application wishes to get an an application level access token, this is by applications that need to perform authenticated requests on a location, such as inject an order, update a catalog or pull a menu.

Application credentials allows the application acces to all the locations that it has been authorized for, and the access is further limited to the scopes that the application is allowed and/or requested within the token request.

Example Request

```shell
curl -X POST -H "Content-Type: application/x-www-form-urlencoded" -d "grant_type=client_credentials&client_id=<CLIENT_ID>&client_secret=<CLIENT_SECRET>" "{path}/oauth2/token"
```

Example Response

```json
{ "access_token": "[access-token]", "token_type": "Bearer", "expires_in": 3600 }
```

#### Authorization Code Grant

The `authorization_code` grant is used when an application wishes to initiate the onboarding to a location, the application will prepare an
`/authorize` url which will inlcude the client id, client secret, redirect uri and required scopes, the application should redirect the user to the authoization url, once the user has been redirect to the url, they will be promted to authenticate and authorize your acccess to a selected location of their choosing.

Once the user has authorzed the request, they will be redirected back to the redirect uri with an intermediate token called the `code`, this code contains the users intent to authorize your application, taking this `code` property you can make a follow up call to the token endpoint with this intermediate code
to complete the onboarding steps.

Once the authorization flow us complete, the aplication credentials that are generated with the `client_credentials` flow will now have permission for this new store.

### Client Registration

Before your application can authenticate and access the POS Hub API, you must first create an application within your [POS Hub Developer's](https://tryposhub.com) area. Once your application is created, you will be issued a unique client ID and client secret, which are essential credentials for establishing a secure connection with the API. These credentials ensure that only authorized applications can interact with the POS Hub API, maintaining the integrity and privacy of your data.

### API Security Defintions

<SecurityDefinitions />

### Authenticating Requests

To securely access the POS Hub API, you need to include a valid access token in the Authorization header of your API requests. This access token allows your application to interact with API resources and perform operations on behalf of the user.

To include the access token in your requests, use the Bearer token type in the Authorization header:

```
Authorization: Bearer [access-token]
```

Here's an example of an authenticated request to retrieve a list of orders for an onboarded application:

```
curl -X GET https://api.trypos hub.com/accounts/{accountId}/locations/{locationId}/order/{orderId} \
  -H "Authorization: Bearer [access-token]"
```

**Note: Replace [access-token] with the actual access token you received in the token response.**

### Refresh Token Grant Flow

To ensure secure and uninterrupted access to the POS Hub API, it's important to understand and utilize the refresh token grant flow. This flow allows you to obtain new access tokens without the need to provide client credentials again.

When you obtain an access token through the client credentials grant flow, it has a limited lifespan for security reasons. The duration of the token's validity is typically set to 1 hour, as indicated by the "expires_in" field in the response.

To refresh an expiring access token, your application should make a token refresh request to the `/oauth2/token` endpoint using the refresh token grant type. This request will provide you with a new access token and a new refresh token.

Once you receive the new tokens, replace the old access token and refresh token in your authenticated requests with the new ones. This ensures seamless access to the POS Hub API without interruption.

By proactively managing token expiration and utilizing the refresh token grant flow, you can maintain secure and continuous access to authorized resources in your integrations with the POS Hub API.

## Common Patterns

Our API Is designed to have common and consistent patterns across all the endpoints, patterns such as pagination, filtering, and response envolopes.

### Response

There are two types of responses this API produces:

1. Object Response
   An object response is the structure that is returned when you working with a single item, such as an GET, POST, PUT or patch on an endpoint that ends with an id parameter, such as `/v1/accounts/{accountId}`, these response will always return a JSON Object with a single data field, the value of the data field is the single object you are reading or mutating.

2. List Response
   A list response is the structure that is returned when your working with list of items, such as a `GET` request on an api endpoint that returns a list of objects, such as `/v1/accounts` or `/v1/accounts/{accountId}/locations`.

The fields in the response are:

| property    | description                                                                                                                      |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------- |
| nextPageKey | A `string` that contains a unique pagination key, this can be passed back to the api on subsequent events to fetch the next page |
| hasNextPage | A `boolean` flag that indicates if there is another page of data available based on your current query request                   |
| data        | A `Array<Entity>` list that has the list of entities within the current page of data                                             |

### Pagination

POS Hub employs "Cursor-Based Pagination" instead of the traditional "Offset-Based Pagination" for several key reasons:

1. **Efficiency:** Cursor-based pagination offers faster and more efficient data retrieval, particularly with large datasets. Unlike offset-based pagination, which skips a fixed number of records, cursor-based pagination retrieves the next set of records using a unique identifier (cursor). This approach avoids the overhead of scanning through and skipping records, leading to quicker response times.

2. **Stability:** Cursor-based pagination is more reliable with frequently changing data. In offset-based pagination, adding or removing records between requests can lead to inconsistent results. Cursor-based pagination uses unique cursors, ensuring data remains consistent and accurate even if changes occur.

3. **Predictability:** Cursor-based pagination provides predictable results. When requesting the next page of data using a cursor, you will receive the same records as long as the dataset remains unchanged. This predictability is essential for maintaining data integrity and consistency in your applications.

### Example Flow of Cursor-Based Pagination

1. **Initial Request:** Specify the number of records per page and any filters or sorting criteria in your initial API request. The API will respond with the first page of results and provide a cursor indicating where the next page begins.

```bash
curl -X GET -H "Authorization: Bearer [access-token]" "{path}/orders?limit=10"
```

**Response:**

```json
{ "data": [...], "hasNextPage": true, "nextPageKey": "[next-page-token]" }
```

2. **Subsequent Requests:** To retrieve the next page of results, use the `nextPageKey` value from the previous response in your next request.

```bash
curl -X GET -H "Authorization: Bearer [access-token]" "{path}/orders?limit=10&nextPageKey=[next-page-token]"
```

**Response:**

```json
{ "data": [...], "hasNextPage": true, "nextPageKey": "[next-page-token]" }
```

3. **Repeat:** Continue retrieving subsequent pages by including the `nextPageKey` in your requests until no more pages are available (i.e., `hasNextPage` is false or `nextPageKey` is not present).

 * OpenAPI spec version: 1.8.9.5
 */
import {
  useInfiniteQuery,
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  AccountMenuModifierByIdResponse,
  AccountMenuModifierGroupByIdResponse,
  AccountPatchEntity,
  ApplicationCreateEntity,
  ApplicationPatchEntity,
  CatalogCategoryCreateEntity,
  CatalogCategoryPatchEntity,
  CatalogImportEntity,
  CatalogModifierCreateEntity,
  CatalogModifierGroupCreateEntity,
  CatalogModifierGroupPatchEntity,
  CatalogModifierPatchEntity,
  CatalogProductCreateEntity,
  CatalogProductPatchEntity,
  ConnectionPatchEntity,
  DeliveryCreateEntity,
  DeliveryEntity,
  DeliveryPatchEntity,
  ErrorResponse,
  GetAccountByIdResponse,
  GetAccountCatalogCategoryByIdResponse,
  GetAccountCatalogExportResponse,
  GetAccountCatalogModifierByIdResponse,
  GetAccountMenuByIdResponse,
  GetAccountMenuCategoryByIdResponse,
  GetAccountMenuExportResponse,
  GetAccountProductByIdResponse,
  GetAccountProductVariantsResponse,
  GetApplicationByIdResponse,
  GetApplicationInfoResponse,
  GetConnectionByIdResponse,
  GetDeliveryByIdResponse,
  GetDispatchedByIdResponse,
  GetLocationByIdResponse,
  GetOauth2AuthorizeParams,
  GetOrderByIdResponse,
  GetResellerByIdResponse,
  GetUserByIdResponse,
  GetV1AccountsAccountIdConnectionsParams,
  GetV1AccountsAccountIdDeliveriesParams,
  GetV1AccountsAccountIdLocationsLocationIdApplicationsParams,
  GetV1AccountsAccountIdLocationsLocationIdAuditsParams,
  GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams,
  GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams,
  GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams,
  GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams,
  GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams,
  GetV1AccountsAccountIdLocationsLocationIdConnectionsParams,
  GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams,
  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams,
  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams,
  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams,
  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams,
  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams,
  GetV1AccountsAccountIdLocationsLocationIdMenusParams,
  GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams,
  GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams,
  GetV1AccountsAccountIdLocationsLocationIdOrdersParams,
  GetV1AccountsAccountIdLocationsParams,
  GetV1AccountsAccountIdMetricsParams,
  GetV1AccountsAccountIdOrdersOrderIdAuditsParams,
  GetV1AccountsAccountIdOrdersParams,
  GetV1AccountsParams,
  GetV1ResellersParams,
  GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams,
  GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams,
  GetV1ResellersResellerIdAccountsAccountIdLocationsParams,
  GetV1ResellersResellerIdAccountsAccountIdMetricsParams,
  GetV1ResellersResellerIdAccountsParams,
  GetV1ResellersResellerIdAuditsParams,
  GetV1ResellersResellerIdDeliveriesParams,
  GetV1ResellersResellerIdLocationsParams,
  GetV1ResellersResellerIdMetricsParams,
  GetV1ResellersResellerIdOrdersOrderIdAuditsParams,
  GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams,
  GetV1ResellersResellerIdOrdersParams,
  GetV1ResellersResellerIdUsersParams,
  GetV1UsersUserIdApplicationsApplicationIdAuditsParams,
  GetV1UsersUserIdApplicationsParams,
  ListAccountCatalogModifierGroupByIdResponse,
  ListAccountCatalogModifierGroupsResponse,
  ListAccountMenuCategoriesResponse,
  ListAccountMenuItemByIdResponse,
  ListAccountMenuItemVariantsResponse,
  ListAccountMenuItemsResponse,
  ListAccountMenuModifierGroupsResponse,
  ListAccountMenuModifiersResponse,
  ListAccountMenusResponse,
  ListAccountsResponse,
  ListApplicationsInfoResponse,
  ListApplicationsResponse,
  ListAuditsResponse,
  ListCatalogCategoriesResponse,
  ListCatalogModifiersResponse,
  ListConnectionsResponse,
  ListDeliveriesResponse,
  ListLocationsResponse,
  ListOrdersResponse,
  ListProductsResponse,
  ListResellersResponse,
  ListUsersResponse,
  LocationCreateEntity,
  LocationPatchEntity,
  MenuCategoryCreateEntity,
  MenuCategoryPatchEntity,
  MenuCreateEntity,
  MenuItemCreateEntity,
  MenuItemPatchEntity,
  MenuModifierCreateEntity,
  MenuModifierGroupCreateEntity,
  MenuModifierGroupPatchEntity,
  MenuModifierPatchEntity,
  MenuPatchEntity,
  MenuPublishCreateEntity,
  MenuRearrangeRequest,
  OAuth2ErrorResponse,
  OrderCreateEntity,
  OrderPatchEntity,
  ResellerAccountCreateEntity,
  ResellerAccountPatchEntity,
  ResellerDeliveryCreateEntity,
  ResellerLocationCreateEntity,
  ResellerLocationPatchEntity,
  ResellerUserPatchEntity,
  SignedUrlRequest,
  SignedUrlResponse,
  TokenRequest,
  TokenResponse,
  UserCreateEntity,
  UserPatchEntity
} from './index.schemas';





/**
 * This endpoint lists all locations that are associated with a specific reseller identified by the resellerId parameter. The data returned includes location identifiers, names, and other relevant details. This endpoint is useful for managing and monitoring the various locations under a reseller's control.
 * @summary List Locations
 */
export const getV1ResellersResellerIdLocations = (
    resellerId: string,
    params?: GetV1ResellersResellerIdLocationsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListLocationsResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/locations`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdLocationsQueryKey = (resellerId: string,
    params?: GetV1ResellersResellerIdLocationsParams,) => {
    return [`/v1/resellers/${resellerId}/locations`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdLocationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, GetV1ResellersResellerIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, QueryKey, GetV1ResellersResellerIdLocationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdLocationsQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, QueryKey, GetV1ResellersResellerIdLocationsParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdLocations(resellerId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, QueryKey, GetV1ResellersResellerIdLocationsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdLocationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>>
export type GetV1ResellersResellerIdLocationsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, GetV1ResellersResellerIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdLocationsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, QueryKey, GetV1ResellersResellerIdLocationsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, GetV1ResellersResellerIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, QueryKey, GetV1ResellersResellerIdLocationsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, GetV1ResellersResellerIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, QueryKey, GetV1ResellersResellerIdLocationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Locations
 */

export function useGetV1ResellersResellerIdLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, GetV1ResellersResellerIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, QueryKey, GetV1ResellersResellerIdLocationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdLocationsInfiniteQueryOptions(resellerId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdLocationsQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdLocationsQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>> = ({ signal }) => getV1ResellersResellerIdLocations(resellerId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdLocationsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>>
export type GetV1ResellersResellerIdLocationsQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdLocations<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdLocationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdLocations<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdLocations<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Locations
 */

export function useGetV1ResellersResellerIdLocations<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdLocationsQueryOptions(resellerId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new location under a specific reseller. Administrators can define the location's details, such as its name, address, and other attributes. Once created, the location will be associated with the reseller and available for management within the system.
 * @summary Create Location
 */
export const postV1ResellersResellerIdLocations = (
    resellerId: string,
    resellerLocationCreateEntity: ResellerLocationCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetLocationByIdResponse>> => {
    
    
    return axios.post(
      `/v1/resellers/${resellerId}/locations`,
      resellerLocationCreateEntity,options
    );
  }



export const getPostV1ResellersResellerIdLocationsMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdLocations>>, TError,{resellerId: string;data: ResellerLocationCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdLocations>>, TError,{resellerId: string;data: ResellerLocationCreateEntity}, TContext> => {
    
const mutationKey = ['postV1ResellersResellerIdLocations'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ResellersResellerIdLocations>>, {resellerId: string;data: ResellerLocationCreateEntity}> = (props) => {
          const {resellerId,data} = props ?? {};

          return  postV1ResellersResellerIdLocations(resellerId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ResellersResellerIdLocationsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ResellersResellerIdLocations>>>
    export type PostV1ResellersResellerIdLocationsMutationBody = ResellerLocationCreateEntity
    export type PostV1ResellersResellerIdLocationsMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Location
 */
export const usePostV1ResellersResellerIdLocations = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdLocations>>, TError,{resellerId: string;data: ResellerLocationCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1ResellersResellerIdLocations>>,
        TError,
        {resellerId: string;data: ResellerLocationCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1ResellersResellerIdLocationsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific user associated with a reseller, identified by the userId parameter. It returns comprehensive data about the user, including their role, status, and associated accounts, making it useful for managing individual user details.
 * @summary Get User
 */
export const getV1ResellersResellerIdUsersUserId = (
    resellerId: string,
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserByIdResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/users/${userId}`,options
    );
  }


export const getGetV1ResellersResellerIdUsersUserIdQueryKey = (resellerId: string,
    userId: string,) => {
    return [`/v1/resellers/${resellerId}/users/${userId}`] as const;
    }

    
export const getGetV1ResellersResellerIdUsersUserIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    userId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdUsersUserIdQueryKey(resellerId,userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>> = ({ signal }) => getV1ResellersResellerIdUsersUserId(resellerId,userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && userId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdUsersUserIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>>
export type GetV1ResellersResellerIdUsersUserIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdUsersUserIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    userId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdUsersUserIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    userId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdUsersUserIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    userId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User
 */

export function useGetV1ResellersResellerIdUsersUserIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    userId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdUsersUserIdInfiniteQueryOptions(resellerId,userId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdUsersUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdUsersUserIdQueryKey(resellerId,userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>> = ({ signal }) => getV1ResellersResellerIdUsersUserId(resellerId,userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && userId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdUsersUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>>
export type GetV1ResellersResellerIdUsersUserIdQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdUsersUserId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdUsersUserId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdUsersUserId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User
 */

export function useGetV1ResellersResellerIdUsersUserId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsersUserId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdUsersUserIdQueryOptions(resellerId,userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for updating the information of a specific user under a reseller. Administrators can modify various aspects of the user's profile, such as their role, status, or other attributes, ensuring that the user's information remains current and accurate.
 * @summary Update User
 */
export const patchV1ResellersResellerIdUsersUserId = (
    resellerId: string,
    userId: string,
    resellerUserPatchEntity: ResellerUserPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/resellers/${resellerId}/users/${userId}`,
      resellerUserPatchEntity,options
    );
  }



export const getPatchV1ResellersResellerIdUsersUserIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerIdUsersUserId>>, TError,{resellerId: string;userId: string;data: ResellerUserPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerIdUsersUserId>>, TError,{resellerId: string;userId: string;data: ResellerUserPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1ResellersResellerIdUsersUserId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1ResellersResellerIdUsersUserId>>, {resellerId: string;userId: string;data: ResellerUserPatchEntity}> = (props) => {
          const {resellerId,userId,data} = props ?? {};

          return  patchV1ResellersResellerIdUsersUserId(resellerId,userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1ResellersResellerIdUsersUserIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1ResellersResellerIdUsersUserId>>>
    export type PatchV1ResellersResellerIdUsersUserIdMutationBody = ResellerUserPatchEntity
    export type PatchV1ResellersResellerIdUsersUserIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update User
 */
export const usePatchV1ResellersResellerIdUsersUserId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerIdUsersUserId>>, TError,{resellerId: string;userId: string;data: ResellerUserPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1ResellersResellerIdUsersUserId>>,
        TError,
        {resellerId: string;userId: string;data: ResellerUserPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1ResellersResellerIdUsersUserIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all connections associated with a specific account. The data returned includes connection identifiers, types, and statuses, providing a comprehensive overview of the external systems and services linked to the account. Users can use this information to manage and monitor connections, ensuring they remain active and properly configured.
 * @summary Get Connections
 */
export const getV1AccountsAccountIdConnections = (
    accountId: string,
    params?: GetV1AccountsAccountIdConnectionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListConnectionsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/connections`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdConnectionsQueryKey = (accountId: string,
    params?: GetV1AccountsAccountIdConnectionsParams,) => {
    return [`/v1/accounts/${accountId}/connections`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdConnectionsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, GetV1AccountsAccountIdConnectionsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    params?: GetV1AccountsAccountIdConnectionsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, QueryKey, GetV1AccountsAccountIdConnectionsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdConnectionsQueryKey(accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, QueryKey, GetV1AccountsAccountIdConnectionsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdConnections(accountId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, QueryKey, GetV1AccountsAccountIdConnectionsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdConnectionsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>>
export type GetV1AccountsAccountIdConnectionsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdConnectionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, GetV1AccountsAccountIdConnectionsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params: undefined |  GetV1AccountsAccountIdConnectionsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, QueryKey, GetV1AccountsAccountIdConnectionsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdConnectionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, GetV1AccountsAccountIdConnectionsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdConnectionsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, QueryKey, GetV1AccountsAccountIdConnectionsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdConnectionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, GetV1AccountsAccountIdConnectionsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdConnectionsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, QueryKey, GetV1AccountsAccountIdConnectionsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Connections
 */

export function useGetV1AccountsAccountIdConnectionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, GetV1AccountsAccountIdConnectionsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdConnectionsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, QueryKey, GetV1AccountsAccountIdConnectionsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdConnectionsInfiniteQueryOptions(accountId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdConnectionsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    params?: GetV1AccountsAccountIdConnectionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdConnectionsQueryKey(accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>> = ({ signal }) => getV1AccountsAccountIdConnections(accountId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdConnectionsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>>
export type GetV1AccountsAccountIdConnectionsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdConnections<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params: undefined |  GetV1AccountsAccountIdConnectionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdConnections<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdConnectionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdConnections<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdConnectionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Connections
 */

export function useGetV1AccountsAccountIdConnections<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdConnectionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnections>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdConnectionsQueryOptions(accountId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves a list of all audits associated with a specific order under a reseller. The data includes audit identifiers, actions, and other relevant details, providing a comprehensive overview of the order audits managed by the reseller.
 * @summary Get Order Audits
 */
export const getV1ResellersResellerIdOrdersOrderIdAudits = (
    resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdAuditsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAuditsResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/orders/${orderId}/audits`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdOrdersOrderIdAuditsQueryKey = (resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdAuditsParams,) => {
    return [`/v1/resellers/${resellerId}/orders/${orderId}/audits`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdOrdersOrderIdAuditsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, GetV1ResellersResellerIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdOrdersOrderIdAuditsQueryKey(resellerId,orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdAuditsParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdOrdersOrderIdAudits(resellerId,orderId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && orderId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdAuditsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdOrdersOrderIdAuditsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>>
export type GetV1ResellersResellerIdOrdersOrderIdAuditsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdOrdersOrderIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, GetV1ResellersResellerIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params: undefined |  GetV1ResellersResellerIdOrdersOrderIdAuditsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdAuditsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, GetV1ResellersResellerIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdAuditsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, GetV1ResellersResellerIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Order Audits
 */

export function useGetV1ResellersResellerIdOrdersOrderIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, GetV1ResellersResellerIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdOrdersOrderIdAuditsInfiniteQueryOptions(resellerId,orderId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdOrdersOrderIdAuditsQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdOrdersOrderIdAuditsQueryKey(resellerId,orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>> = ({ signal }) => getV1ResellersResellerIdOrdersOrderIdAudits(resellerId,orderId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && orderId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdOrdersOrderIdAuditsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>>
export type GetV1ResellersResellerIdOrdersOrderIdAuditsQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdOrdersOrderIdAudits<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params: undefined |  GetV1ResellersResellerIdOrdersOrderIdAuditsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdAudits<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdAudits<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Order Audits
 */

export function useGetV1ResellersResellerIdOrdersOrderIdAudits<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdOrdersOrderIdAuditsQueryOptions(resellerId,orderId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint provides metrics and statistical data for a specific reseller. It allows administrators to view performance metrics, trends, and other analytical information related to the reseller's activities. This data is essential for monitoring the reseller's performance over time.
 * @summary Get Metrics
 */
export const getV1ResellersResellerIdMetrics = (
    resellerId: string,
    params?: GetV1ResellersResellerIdMetricsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/metrics`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdMetricsQueryKey = (resellerId: string,
    params?: GetV1ResellersResellerIdMetricsParams,) => {
    return [`/v1/resellers/${resellerId}/metrics`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdMetricsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, GetV1ResellersResellerIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdMetricsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, QueryKey, GetV1ResellersResellerIdMetricsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdMetricsQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, QueryKey, GetV1ResellersResellerIdMetricsParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdMetrics(resellerId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, QueryKey, GetV1ResellersResellerIdMetricsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdMetricsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>>
export type GetV1ResellersResellerIdMetricsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, GetV1ResellersResellerIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdMetricsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, QueryKey, GetV1ResellersResellerIdMetricsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, GetV1ResellersResellerIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdMetricsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, QueryKey, GetV1ResellersResellerIdMetricsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, GetV1ResellersResellerIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdMetricsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, QueryKey, GetV1ResellersResellerIdMetricsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Metrics
 */

export function useGetV1ResellersResellerIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, GetV1ResellersResellerIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdMetricsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, QueryKey, GetV1ResellersResellerIdMetricsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdMetricsInfiniteQueryOptions(resellerId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdMetricsQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdMetricsQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>> = ({ signal }) => getV1ResellersResellerIdMetrics(resellerId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdMetricsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>>
export type GetV1ResellersResellerIdMetricsQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdMetrics<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdMetricsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdMetrics<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdMetrics<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Metrics
 */

export function useGetV1ResellersResellerIdMetrics<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdMetricsQueryOptions(resellerId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves a list of all deliveries associated with a specific order under a reseller. The data returned includes delivery identifiers, statuses, and other relevant details, providing a comprehensive overview of all deliveries managed by the reseller.
 * @summary List Order Deliveries
 */
export const getV1ResellersResellerIdOrdersOrderIdDeliveries = (
    resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListDeliveriesResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/orders/${orderId}/deliveries`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdOrdersOrderIdDeliveriesQueryKey = (resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams,) => {
    return [`/v1/resellers/${resellerId}/orders/${orderId}/deliveries`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdOrdersOrderIdDeliveriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdOrdersOrderIdDeliveriesQueryKey(resellerId,orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdOrdersOrderIdDeliveries(resellerId,orderId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && orderId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdOrdersOrderIdDeliveriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>>
export type GetV1ResellersResellerIdOrdersOrderIdDeliveriesInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdOrdersOrderIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params: undefined |  GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Order Deliveries
 */

export function useGetV1ResellersResellerIdOrdersOrderIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, QueryKey, GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdOrdersOrderIdDeliveriesInfiniteQueryOptions(resellerId,orderId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdOrdersOrderIdDeliveriesQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdOrdersOrderIdDeliveriesQueryKey(resellerId,orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>> = ({ signal }) => getV1ResellersResellerIdOrdersOrderIdDeliveries(resellerId,orderId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && orderId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdOrdersOrderIdDeliveriesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>>
export type GetV1ResellersResellerIdOrdersOrderIdDeliveriesQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdOrdersOrderIdDeliveries<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params: undefined |  GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdDeliveries<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdDeliveries<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Order Deliveries
 */

export function useGetV1ResellersResellerIdOrdersOrderIdDeliveries<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    params?: GetV1ResellersResellerIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdOrdersOrderIdDeliveriesQueryOptions(resellerId,orderId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves detailed information about a specific delivery associated with a reseller, identified by the deliveryId parameter. It returns comprehensive data about the delivery, including pickup time, status, and other relevant details.
 * @summary Get Delivery
 */
export const getV1ResellersResellerIdDeliveriesDeliveryId = (
    resellerId: string,
    deliveryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/deliveries/${deliveryId}`,options
    );
  }


export const getGetV1ResellersResellerIdDeliveriesDeliveryIdQueryKey = (resellerId: string,
    deliveryId: string,) => {
    return [`/v1/resellers/${resellerId}/deliveries/${deliveryId}`] as const;
    }

    
export const getGetV1ResellersResellerIdDeliveriesDeliveryIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdDeliveriesDeliveryIdQueryKey(resellerId,deliveryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>> = ({ signal }) => getV1ResellersResellerIdDeliveriesDeliveryId(resellerId,deliveryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && deliveryId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdDeliveriesDeliveryIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>>
export type GetV1ResellersResellerIdDeliveriesDeliveryIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    deliveryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Delivery
 */

export function useGetV1ResellersResellerIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdDeliveriesDeliveryIdInfiniteQueryOptions(resellerId,deliveryId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdDeliveriesDeliveryIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdDeliveriesDeliveryIdQueryKey(resellerId,deliveryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>> = ({ signal }) => getV1ResellersResellerIdDeliveriesDeliveryId(resellerId,deliveryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && deliveryId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdDeliveriesDeliveryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>>
export type GetV1ResellersResellerIdDeliveriesDeliveryIdQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    deliveryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Delivery
 */

export function useGetV1ResellersResellerIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdDeliveriesDeliveryIdQueryOptions(resellerId,deliveryId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for exporting a specific menu at a location. The menu data will be provided in a downloadable format, such as CSV or JSON, making it easy for administrators to back up or transfer menu information to other systems.
 * @summary Export Menu
 */
export const getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport = (
    accountId: string,
    locationId: string,
    menuId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountMenuExportResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/export`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportQueryKey = (accountId: string,
    locationId: string,
    menuId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/export`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportQueryKey(accountId,locationId,menuId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport(accountId,locationId,menuId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Export Menu
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportInfiniteQueryOptions(accountId,locationId,menuId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportQueryKey(accountId,locationId,menuId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport(accountId,locationId,menuId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Export Menu
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdExport>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdExportQueryOptions(accountId,locationId,menuId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint is used to authorize a client application via the OAuth2 protocol. It initiates the OAuth2 authorization process, allowing the client to request permission from the resource owner to access protected resources. The response typically includes an authorization code that can be exchanged for an access token, this is used when onboarding a new client application.
 * @summary Authorize
 */
export const getOauth2Authorize = (
    params: GetOauth2AuthorizeParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.get(
      `/oauth2/authorize`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetOauth2AuthorizeQueryKey = (params: GetOauth2AuthorizeParams,) => {
    return [`/oauth2/authorize`, ...(params ? [params]: [])] as const;
    }

    
export const getGetOauth2AuthorizeInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getOauth2Authorize>>, GetOauth2AuthorizeParams['nextPageKey']>, TError = AxiosError<OAuth2ErrorResponse>>(params: GetOauth2AuthorizeParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOauth2Authorize>>, TError, TData, Awaited<ReturnType<typeof getOauth2Authorize>>, QueryKey, GetOauth2AuthorizeParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOauth2AuthorizeQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOauth2Authorize>>, QueryKey, GetOauth2AuthorizeParams['nextPageKey']> = ({ signal, pageParam }) => getOauth2Authorize({...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOauth2Authorize>>, TError, TData, Awaited<ReturnType<typeof getOauth2Authorize>>, QueryKey, GetOauth2AuthorizeParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOauth2AuthorizeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getOauth2Authorize>>>
export type GetOauth2AuthorizeInfiniteQueryError = AxiosError<OAuth2ErrorResponse>


export function useGetOauth2AuthorizeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOauth2Authorize>>, GetOauth2AuthorizeParams['nextPageKey']>, TError = AxiosError<OAuth2ErrorResponse>>(
 params: GetOauth2AuthorizeParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOauth2Authorize>>, TError, TData, Awaited<ReturnType<typeof getOauth2Authorize>>, QueryKey, GetOauth2AuthorizeParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOauth2Authorize>>,
          TError,
          Awaited<ReturnType<typeof getOauth2Authorize>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOauth2AuthorizeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOauth2Authorize>>, GetOauth2AuthorizeParams['nextPageKey']>, TError = AxiosError<OAuth2ErrorResponse>>(
 params: GetOauth2AuthorizeParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOauth2Authorize>>, TError, TData, Awaited<ReturnType<typeof getOauth2Authorize>>, QueryKey, GetOauth2AuthorizeParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOauth2Authorize>>,
          TError,
          Awaited<ReturnType<typeof getOauth2Authorize>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOauth2AuthorizeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOauth2Authorize>>, GetOauth2AuthorizeParams['nextPageKey']>, TError = AxiosError<OAuth2ErrorResponse>>(
 params: GetOauth2AuthorizeParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOauth2Authorize>>, TError, TData, Awaited<ReturnType<typeof getOauth2Authorize>>, QueryKey, GetOauth2AuthorizeParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Authorize
 */

export function useGetOauth2AuthorizeInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getOauth2Authorize>>, GetOauth2AuthorizeParams['nextPageKey']>, TError = AxiosError<OAuth2ErrorResponse>>(
 params: GetOauth2AuthorizeParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getOauth2Authorize>>, TError, TData, Awaited<ReturnType<typeof getOauth2Authorize>>, QueryKey, GetOauth2AuthorizeParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOauth2AuthorizeInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetOauth2AuthorizeQueryOptions = <TData = Awaited<ReturnType<typeof getOauth2Authorize>>, TError = AxiosError<OAuth2ErrorResponse>>(params: GetOauth2AuthorizeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOauth2Authorize>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOauth2AuthorizeQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOauth2Authorize>>> = ({ signal }) => getOauth2Authorize(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOauth2Authorize>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOauth2AuthorizeQueryResult = NonNullable<Awaited<ReturnType<typeof getOauth2Authorize>>>
export type GetOauth2AuthorizeQueryError = AxiosError<OAuth2ErrorResponse>


export function useGetOauth2Authorize<TData = Awaited<ReturnType<typeof getOauth2Authorize>>, TError = AxiosError<OAuth2ErrorResponse>>(
 params: GetOauth2AuthorizeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOauth2Authorize>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOauth2Authorize>>,
          TError,
          Awaited<ReturnType<typeof getOauth2Authorize>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOauth2Authorize<TData = Awaited<ReturnType<typeof getOauth2Authorize>>, TError = AxiosError<OAuth2ErrorResponse>>(
 params: GetOauth2AuthorizeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOauth2Authorize>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOauth2Authorize>>,
          TError,
          Awaited<ReturnType<typeof getOauth2Authorize>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOauth2Authorize<TData = Awaited<ReturnType<typeof getOauth2Authorize>>, TError = AxiosError<OAuth2ErrorResponse>>(
 params: GetOauth2AuthorizeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOauth2Authorize>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Authorize
 */

export function useGetOauth2Authorize<TData = Awaited<ReturnType<typeof getOauth2Authorize>>, TError = AxiosError<OAuth2ErrorResponse>>(
 params: GetOauth2AuthorizeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOauth2Authorize>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOauth2AuthorizeQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves detailed information about a specific delivery associated with a location, identified by the deliveryId parameter. It provides comprehensive data about the delivery, including items, status, and other relevant details, making it useful for managing individual deliveries.
 * @summary Get Delivery
 */
export const getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId = (
    accountId: string,
    locationId: string,
    deliveryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/deliveries/${deliveryId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdQueryKey = (accountId: string,
    locationId: string,
    deliveryId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/deliveries/${deliveryId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdQueryKey(accountId,locationId,deliveryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId(accountId,locationId,deliveryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && deliveryId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>>
export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Delivery
 */

export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdInfiniteQueryOptions(accountId,locationId,deliveryId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdQueryKey(accountId,locationId,deliveryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId(accountId,locationId,deliveryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && deliveryId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>>
export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Delivery
 */

export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdQueryOptions(accountId,locationId,deliveryId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves a list of all menus associated with a specific location under an account. The data includes menu identifiers, names, and other relevant details, providing an overview of the menus that are available or active at the location.
 * @summary List Menus
 */
export const getV1AccountsAccountIdLocationsLocationIdMenus = (
    accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountMenusResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/menus`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMenusQueryKey = (accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/menus`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMenusInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, GetV1AccountsAccountIdLocationsLocationIdMenusParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdMenus(accountId,locationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, GetV1AccountsAccountIdLocationsLocationIdMenusParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdMenusParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, GetV1AccountsAccountIdLocationsLocationIdMenusParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, GetV1AccountsAccountIdLocationsLocationIdMenusParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Menus
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, GetV1AccountsAccountIdLocationsLocationIdMenusParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusInfiniteQueryOptions(accountId,locationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMenusQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenus(accountId,locationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenus<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdMenusParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenus<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenus<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Menus
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenus<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusQueryOptions(accountId,locationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new menu under a specific location associated with an account. Administrators can define the menu's details, including its name, items, and categories. Once created, the menu will be linked to the location and managed accordingly.
 * @summary Create Menu
 */
export const postV1AccountsAccountIdLocationsLocationIdMenus = (
    accountId: string,
    locationId: string,
    menuCreateEntity: MenuCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountMenuByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/menus`,
      menuCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdMenusMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenus>>, TError,{accountId: string;locationId: string;data: MenuCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenus>>, TError,{accountId: string;locationId: string;data: MenuCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdMenus'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenus>>, {accountId: string;locationId: string;data: MenuCreateEntity}> = (props) => {
          const {accountId,locationId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdMenus(accountId,locationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdMenusMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenus>>>
    export type PostV1AccountsAccountIdLocationsLocationIdMenusMutationBody = MenuCreateEntity
    export type PostV1AccountsAccountIdLocationsLocationIdMenusMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Menu
 */
export const usePostV1AccountsAccountIdLocationsLocationIdMenus = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenus>>, TError,{accountId: string;locationId: string;data: MenuCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenus>>,
        TError,
        {accountId: string;locationId: string;data: MenuCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdMenusMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific reseller identified by the resellerId parameter. It returns data such as the reseller's name, contact details, and any other associated information. This endpoint is useful for viewing or managing a particular reseller's details.
 * @summary Get Reseller
 */
export const getV1ResellersResellerId = (
    resellerId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetResellerByIdResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}`,options
    );
  }


export const getGetV1ResellersResellerIdQueryKey = (resellerId: string,) => {
    return [`/v1/resellers/${resellerId}`] as const;
    }

    
export const getGetV1ResellersResellerIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerId>>>, TError = AxiosError<ErrorResponse>>(resellerId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdQueryKey(resellerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerId>>> = ({ signal }) => getV1ResellersResellerId(resellerId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerId>>>
export type GetV1ResellersResellerIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Reseller
 */

export function useGetV1ResellersResellerIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdInfiniteQueryOptions(resellerId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError = AxiosError<ErrorResponse>>(resellerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdQueryKey(resellerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerId>>> = ({ signal }) => getV1ResellersResellerId(resellerId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerId>>>
export type GetV1ResellersResellerIdQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerId<TData = Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerId<TData = Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerId<TData = Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Reseller
 */

export function useGetV1ResellersResellerId<TData = Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdQueryOptions(resellerId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for updating the information of a specific reseller identified by the resellerId parameter. Administrators can use this endpoint to modify details such as contact information, status, or other attributes related to the reseller.
 * @summary Update Reseller
 */
export const patchV1ResellersResellerId = (
    resellerId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetResellerByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/resellers/${resellerId}`,undefined,options
    );
  }



export const getPatchV1ResellersResellerIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerId>>, TError,{resellerId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerId>>, TError,{resellerId: string}, TContext> => {
    
const mutationKey = ['patchV1ResellersResellerId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1ResellersResellerId>>, {resellerId: string}> = (props) => {
          const {resellerId} = props ?? {};

          return  patchV1ResellersResellerId(resellerId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1ResellersResellerIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1ResellersResellerId>>>
    
    export type PatchV1ResellersResellerIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Reseller
 */
export const usePatchV1ResellersResellerId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerId>>, TError,{resellerId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1ResellersResellerId>>,
        TError,
        {resellerId: string},
        TContext
      > => {

      const mutationOptions = getPatchV1ResellersResellerIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific delivery associated with an order, identified by the deliveryId parameter. It provides comprehensive data about the delivery, including its status, driver information, and delivery location, allowing for effective tracking and management of the delivery.
 * @summary Get Delivery
 */
export const getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId = (
    accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/orders/${orderId}/deliveries/${deliveryId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdQueryKey = (accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/orders/${orderId}/deliveries/${deliveryId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdQueryKey(accountId,locationId,orderId,deliveryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId(accountId,locationId,orderId,deliveryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && orderId && deliveryId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>>
export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Delivery
 */

export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdInfiniteQueryOptions(accountId,locationId,orderId,deliveryId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdQueryKey(accountId,locationId,orderId,deliveryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId(accountId,locationId,orderId,deliveryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && orderId && deliveryId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>>
export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Delivery
 */

export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdQueryOptions(accountId,locationId,orderId,deliveryId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for updating the information of a specific delivery associated with an order. Users can modify details such as the delivery's status, driver information, or location, ensuring that the delivery remains accurate and aligned with the order's requirements.
 * @summary Update Delivery
 */
export const patchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId = (
    accountId: string,
    locationId: string,
    orderId: string,
    deliveryId: string,
    deliveryPatchEntity: DeliveryPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/orders/${orderId}/deliveries/${deliveryId}`,
      deliveryPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError,{accountId: string;locationId: string;orderId: string;deliveryId: string;data: DeliveryPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError,{accountId: string;locationId: string;orderId: string;deliveryId: string;data: DeliveryPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, {accountId: string;locationId: string;orderId: string;deliveryId: string;data: DeliveryPatchEntity}> = (props) => {
          const {accountId,locationId,orderId,deliveryId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId(accountId,locationId,orderId,deliveryId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdMutationBody = DeliveryPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Delivery
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>, TError,{accountId: string;locationId: string;orderId: string;deliveryId: string;data: DeliveryPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryId>>,
        TError,
        {accountId: string;locationId: string;orderId: string;deliveryId: string;data: DeliveryPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesDeliveryIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific modifier group within a catalog at a location, identified by the modifierGroupId parameter. It provides comprehensive data about the modifier group, including its modifiers and status, allowing for effective management and updates.
 * @summary Get Modifier Group
 */
export const getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId = (
    accountId: string,
    locationId: string,
    modifierGroupId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountCatalogModifierGroupByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/modifier-groups/${modifierGroupId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdQueryKey = (accountId: string,
    locationId: string,
    modifierGroupId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/catalog/modifier-groups/${modifierGroupId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    modifierGroupId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdQueryKey(accountId,locationId,modifierGroupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId(accountId,locationId,modifierGroupId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && modifierGroupId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierGroupId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierGroupId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierGroupId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Modifier Group
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierGroupId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdInfiniteQueryOptions(accountId,locationId,modifierGroupId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    modifierGroupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdQueryKey(accountId,locationId,modifierGroupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId(accountId,locationId,modifierGroupId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && modifierGroupId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierGroupId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierGroupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierGroupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Modifier Group
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierGroupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdQueryOptions(accountId,locationId,modifierGroupId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific modifier group within a catalog at a location. The modifierGroupId parameter identifies the group to be deleted, which will remove it from the system and disassociate it from the catalog.
 * @summary Delete Modifier Group
 */
export const deleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId = (
    accountId: string,
    locationId: string,
    modifierGroupId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/modifier-groups/${modifierGroupId}`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError,{accountId: string;locationId: string;modifierGroupId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError,{accountId: string;locationId: string;modifierGroupId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, {accountId: string;locationId: string;modifierGroupId: string}> = (props) => {
          const {accountId,locationId,modifierGroupId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId(accountId,locationId,modifierGroupId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Modifier Group
 */
export const useDeleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError,{accountId: string;locationId: string;modifierGroupId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>,
        TError,
        {accountId: string;locationId: string;modifierGroupId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the information of a specific modifier group within a catalog at a location. Users can modify the modifier group's details, such as its name, modifiers, or availability, ensuring that the group remains current and aligned with the catalog's customization options.
 * @summary Update Modifier Group
 */
export const patchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId = (
    accountId: string,
    locationId: string,
    modifierGroupId: string,
    catalogModifierGroupPatchEntity: CatalogModifierGroupPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountCatalogModifierGroupByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/modifier-groups/${modifierGroupId}`,
      catalogModifierGroupPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError,{accountId: string;locationId: string;modifierGroupId: string;data: CatalogModifierGroupPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError,{accountId: string;locationId: string;modifierGroupId: string;data: CatalogModifierGroupPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, {accountId: string;locationId: string;modifierGroupId: string;data: CatalogModifierGroupPatchEntity}> = (props) => {
          const {accountId,locationId,modifierGroupId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId(accountId,locationId,modifierGroupId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdMutationBody = CatalogModifierGroupPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Modifier Group
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>, TError,{accountId: string;locationId: string;modifierGroupId: string;data: CatalogModifierGroupPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupId>>,
        TError,
        {accountId: string;locationId: string;modifierGroupId: string;data: CatalogModifierGroupPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsModifierGroupIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all products within a catalog associated with a specific location under an account. The data includes product identifiers, names, descriptions, and pricing, providing an overview of the products available in the catalog. This information is essential for managing the catalog's inventory and offerings.
 * @summary Get Catalog Products
 */
export const getV1AccountsAccountIdLocationsLocationIdCatalogProducts = (
    accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListProductsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/products`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsQueryKey = (accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/catalog/products`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdCatalogProducts(accountId,locationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Products
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsInfiniteQueryOptions(accountId,locationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogProducts(accountId,locationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProducts<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProducts<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProducts<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Products
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProducts<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsQueryOptions(accountId,locationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new product within a catalog at a specific location. Users can define the product's details, including its name, description, pricing, and associated categories. Once created, the product will be available for sale within the catalog, enhancing the catalog's inventory and offerings.
 * @summary Create Catalog Product
 */
export const postV1AccountsAccountIdLocationsLocationIdCatalogProducts = (
    accountId: string,
    locationId: string,
    catalogProductCreateEntity: CatalogProductCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountProductByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/products`,
      catalogProductCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdCatalogProductsMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError,{accountId: string;locationId: string;data: CatalogProductCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError,{accountId: string;locationId: string;data: CatalogProductCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdCatalogProducts'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, {accountId: string;locationId: string;data: CatalogProductCreateEntity}> = (props) => {
          const {accountId,locationId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdCatalogProducts(accountId,locationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdCatalogProductsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogProducts>>>
    export type PostV1AccountsAccountIdLocationsLocationIdCatalogProductsMutationBody = CatalogProductCreateEntity
    export type PostV1AccountsAccountIdLocationsLocationIdCatalogProductsMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Catalog Product
 */
export const usePostV1AccountsAccountIdLocationsLocationIdCatalogProducts = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogProducts>>, TError,{accountId: string;locationId: string;data: CatalogProductCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogProducts>>,
        TError,
        {accountId: string;locationId: string;data: CatalogProductCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdCatalogProductsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves audit logs for a specific application associated with a user. The logs provide detailed records of actions and changes made within the application, allowing administrators to review and analyze user activity for compliance and security purposes.
 * @summary Get Audits
 */
export const getV1UsersUserIdApplicationsApplicationIdAudits = (
    userId: string,
    applicationId: string,
    params?: GetV1UsersUserIdApplicationsApplicationIdAuditsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAuditsResponse>> => {
    
    
    return axios.get(
      `/v1/users/${userId}/applications/${applicationId}/audits`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1UsersUserIdApplicationsApplicationIdAuditsQueryKey = (userId: string,
    applicationId: string,
    params?: GetV1UsersUserIdApplicationsApplicationIdAuditsParams,) => {
    return [`/v1/users/${userId}/applications/${applicationId}/audits`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1UsersUserIdApplicationsApplicationIdAuditsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, GetV1UsersUserIdApplicationsApplicationIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(userId: string,
    applicationId: string,
    params?: GetV1UsersUserIdApplicationsApplicationIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, QueryKey, GetV1UsersUserIdApplicationsApplicationIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1UsersUserIdApplicationsApplicationIdAuditsQueryKey(userId,applicationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, QueryKey, GetV1UsersUserIdApplicationsApplicationIdAuditsParams['nextPageKey']> = ({ signal, pageParam }) => getV1UsersUserIdApplicationsApplicationIdAudits(userId,applicationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId && applicationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, QueryKey, GetV1UsersUserIdApplicationsApplicationIdAuditsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1UsersUserIdApplicationsApplicationIdAuditsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>>
export type GetV1UsersUserIdApplicationsApplicationIdAuditsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1UsersUserIdApplicationsApplicationIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, GetV1UsersUserIdApplicationsApplicationIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string,
    params: undefined |  GetV1UsersUserIdApplicationsApplicationIdAuditsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, QueryKey, GetV1UsersUserIdApplicationsApplicationIdAuditsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsApplicationIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, GetV1UsersUserIdApplicationsApplicationIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string,
    params?: GetV1UsersUserIdApplicationsApplicationIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, QueryKey, GetV1UsersUserIdApplicationsApplicationIdAuditsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsApplicationIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, GetV1UsersUserIdApplicationsApplicationIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string,
    params?: GetV1UsersUserIdApplicationsApplicationIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, QueryKey, GetV1UsersUserIdApplicationsApplicationIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Audits
 */

export function useGetV1UsersUserIdApplicationsApplicationIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, GetV1UsersUserIdApplicationsApplicationIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string,
    params?: GetV1UsersUserIdApplicationsApplicationIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, QueryKey, GetV1UsersUserIdApplicationsApplicationIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1UsersUserIdApplicationsApplicationIdAuditsInfiniteQueryOptions(userId,applicationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1UsersUserIdApplicationsApplicationIdAuditsQueryOptions = <TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError = AxiosError<ErrorResponse>>(userId: string,
    applicationId: string,
    params?: GetV1UsersUserIdApplicationsApplicationIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1UsersUserIdApplicationsApplicationIdAuditsQueryKey(userId,applicationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>> = ({ signal }) => getV1UsersUserIdApplicationsApplicationIdAudits(userId,applicationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId && applicationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1UsersUserIdApplicationsApplicationIdAuditsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>>
export type GetV1UsersUserIdApplicationsApplicationIdAuditsQueryError = AxiosError<ErrorResponse>


export function useGetV1UsersUserIdApplicationsApplicationIdAudits<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string,
    params: undefined |  GetV1UsersUserIdApplicationsApplicationIdAuditsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsApplicationIdAudits<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string,
    params?: GetV1UsersUserIdApplicationsApplicationIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsApplicationIdAudits<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string,
    params?: GetV1UsersUserIdApplicationsApplicationIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Audits
 */

export function useGetV1UsersUserIdApplicationsApplicationIdAudits<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string,
    params?: GetV1UsersUserIdApplicationsApplicationIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1UsersUserIdApplicationsApplicationIdAuditsQueryOptions(userId,applicationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves detailed information about a specific application, identified by the applicationId parameter. It provides comprehensive data such as the application's name, description, and status, making it useful for managing or auditing the application.
 * @summary Get Application
 */
export const getV1ApplicationsApplicationId = (
    applicationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetApplicationInfoResponse>> => {
    
    
    return axios.get(
      `/v1/applications/${applicationId}`,options
    );
  }


export const getGetV1ApplicationsApplicationIdQueryKey = (applicationId: string,) => {
    return [`/v1/applications/${applicationId}`] as const;
    }

    
export const getGetV1ApplicationsApplicationIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>>, TError = AxiosError<ErrorResponse>>(applicationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ApplicationsApplicationIdQueryKey(applicationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>> = ({ signal }) => getV1ApplicationsApplicationId(applicationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(applicationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ApplicationsApplicationIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>>
export type GetV1ApplicationsApplicationIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ApplicationsApplicationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>>, TError = AxiosError<ErrorResponse>>(
 applicationId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>,
          TError,
          Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ApplicationsApplicationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>>, TError = AxiosError<ErrorResponse>>(
 applicationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>,
          TError,
          Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ApplicationsApplicationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>>, TError = AxiosError<ErrorResponse>>(
 applicationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Application
 */

export function useGetV1ApplicationsApplicationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>>, TError = AxiosError<ErrorResponse>>(
 applicationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ApplicationsApplicationIdInfiniteQueryOptions(applicationId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ApplicationsApplicationIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError = AxiosError<ErrorResponse>>(applicationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ApplicationsApplicationIdQueryKey(applicationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>> = ({ signal }) => getV1ApplicationsApplicationId(applicationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(applicationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ApplicationsApplicationIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>>
export type GetV1ApplicationsApplicationIdQueryError = AxiosError<ErrorResponse>


export function useGetV1ApplicationsApplicationId<TData = Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError = AxiosError<ErrorResponse>>(
 applicationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>,
          TError,
          Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ApplicationsApplicationId<TData = Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError = AxiosError<ErrorResponse>>(
 applicationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>,
          TError,
          Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ApplicationsApplicationId<TData = Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError = AxiosError<ErrorResponse>>(
 applicationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Application
 */

export function useGetV1ApplicationsApplicationId<TData = Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError = AxiosError<ErrorResponse>>(
 applicationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ApplicationsApplicationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ApplicationsApplicationIdQueryOptions(applicationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the cancellation of a dispatched delivery, this endpoint is typically used by the delivery application that is managing the delivery process.
 * @summary Cancel Dispatched Delivery
 */
export const postV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancel = (
    resellerId: string,
    deliveryId: string,
    dispatchId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.post(
      `/v1/resellers/${resellerId}/deliveries/${deliveryId}/dispatch/${dispatchId}/cancel`,undefined,options
    );
  }



export const getPostV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancelMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancel>>, TError,{resellerId: string;deliveryId: string;dispatchId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancel>>, TError,{resellerId: string;deliveryId: string;dispatchId: string}, TContext> => {
    
const mutationKey = ['postV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancel>>, {resellerId: string;deliveryId: string;dispatchId: string}> = (props) => {
          const {resellerId,deliveryId,dispatchId} = props ?? {};

          return  postV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancel(resellerId,deliveryId,dispatchId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancelMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancel>>>
    
    export type PostV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancelMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Cancel Dispatched Delivery
 */
export const usePostV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancel = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancel>>, TError,{resellerId: string;deliveryId: string;dispatchId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancel>>,
        TError,
        {resellerId: string;deliveryId: string;dispatchId: string},
        TContext
      > => {

      const mutationOptions = getPostV1ResellersResellerIdDeliveriesDeliveryIdDispatchDispatchIdCancelMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint triggers a pull from a specific connection associated with a location under an account. The pull process retrieves the latest catalog data from the connected system or service, updating the account with the most recent information. Proper authorization is required to perform this action, and it is typically used by users to synchronize data across systems.
 * @summary Pull the catalog from a given POS connection
 */
export const postV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPull = (
    accountId: string,
    locationId: string,
    connectionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/connections/${connectionId}/pull`,undefined,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPullMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPull>>, TError,{accountId: string;locationId: string;connectionId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPull>>, TError,{accountId: string;locationId: string;connectionId: string}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPull'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPull>>, {accountId: string;locationId: string;connectionId: string}> = (props) => {
          const {accountId,locationId,connectionId} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPull(accountId,locationId,connectionId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPullMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPull>>>
    
    export type PostV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPullMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Pull the catalog from a given POS connection
 */
export const usePostV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPull = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPull>>, TError,{accountId: string;locationId: string;connectionId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPull>>,
        TError,
        {accountId: string;locationId: string;connectionId: string},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdPullMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific delivery associated with an account, identified by the deliveryId parameter. It provides comprehensive data about the delivery, including items, status, and other relevant details, making it useful for managing individual deliveries.
 * @summary Get Delivery
 */
export const getV1AccountsAccountIdDeliveriesDeliveryId = (
    accountId: string,
    deliveryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/deliveries/${deliveryId}`,options
    );
  }


export const getGetV1AccountsAccountIdDeliveriesDeliveryIdQueryKey = (accountId: string,
    deliveryId: string,) => {
    return [`/v1/accounts/${accountId}/deliveries/${deliveryId}`] as const;
    }

    
export const getGetV1AccountsAccountIdDeliveriesDeliveryIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdDeliveriesDeliveryIdQueryKey(accountId,deliveryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>> = ({ signal }) => getV1AccountsAccountIdDeliveriesDeliveryId(accountId,deliveryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && deliveryId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdDeliveriesDeliveryIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>>
export type GetV1AccountsAccountIdDeliveriesDeliveryIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    deliveryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Delivery
 */

export function useGetV1AccountsAccountIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdDeliveriesDeliveryIdInfiniteQueryOptions(accountId,deliveryId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdDeliveriesDeliveryIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdDeliveriesDeliveryIdQueryKey(accountId,deliveryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>> = ({ signal }) => getV1AccountsAccountIdDeliveriesDeliveryId(accountId,deliveryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && deliveryId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdDeliveriesDeliveryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>>
export type GetV1AccountsAccountIdDeliveriesDeliveryIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    deliveryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Delivery
 */

export function useGetV1AccountsAccountIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdDeliveriesDeliveryIdQueryOptions(accountId,deliveryId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for updating the information of a specific delivery associated with an account. Users can modify various aspects of the delivery, such as its status, items, or other attributes, ensuring that the delivery remains current and accurate.
 * @summary Update Delivery
 */
export const patchV1AccountsAccountIdDeliveriesDeliveryId = (
    accountId: string,
    deliveryId: string,
    deliveryPatchEntity: DeliveryPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/deliveries/${deliveryId}`,
      deliveryPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdDeliveriesDeliveryIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdDeliveriesDeliveryId>>, TError,{accountId: string;deliveryId: string;data: DeliveryPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdDeliveriesDeliveryId>>, TError,{accountId: string;deliveryId: string;data: DeliveryPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdDeliveriesDeliveryId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdDeliveriesDeliveryId>>, {accountId: string;deliveryId: string;data: DeliveryPatchEntity}> = (props) => {
          const {accountId,deliveryId,data} = props ?? {};

          return  patchV1AccountsAccountIdDeliveriesDeliveryId(accountId,deliveryId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdDeliveriesDeliveryIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdDeliveriesDeliveryId>>>
    export type PatchV1AccountsAccountIdDeliveriesDeliveryIdMutationBody = DeliveryPatchEntity
    export type PatchV1AccountsAccountIdDeliveriesDeliveryIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Delivery
 */
export const usePatchV1AccountsAccountIdDeliveriesDeliveryId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdDeliveriesDeliveryId>>, TError,{accountId: string;deliveryId: string;data: DeliveryPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdDeliveriesDeliveryId>>,
        TError,
        {accountId: string;deliveryId: string;data: DeliveryPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdDeliveriesDeliveryIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all accounts associated with a specific reseller. The data returned includes account identifiers, names, and other relevant details. This endpoint is particularly useful for resellers and administrators who need to manage or monitor accounts under their jurisdiction.
 * @summary List Accounts
 */
export const getV1ResellersResellerIdAccounts = (
    resellerId: string,
    params?: GetV1ResellersResellerIdAccountsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountsResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/accounts`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdAccountsQueryKey = (resellerId: string,
    params?: GetV1ResellersResellerIdAccountsParams,) => {
    return [`/v1/resellers/${resellerId}/accounts`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdAccountsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, GetV1ResellersResellerIdAccountsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdAccountsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, QueryKey, GetV1ResellersResellerIdAccountsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, QueryKey, GetV1ResellersResellerIdAccountsParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdAccounts(resellerId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, QueryKey, GetV1ResellersResellerIdAccountsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>>
export type GetV1ResellersResellerIdAccountsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, GetV1ResellersResellerIdAccountsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdAccountsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, QueryKey, GetV1ResellersResellerIdAccountsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, GetV1ResellersResellerIdAccountsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdAccountsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, QueryKey, GetV1ResellersResellerIdAccountsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, GetV1ResellersResellerIdAccountsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdAccountsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, QueryKey, GetV1ResellersResellerIdAccountsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Accounts
 */

export function useGetV1ResellersResellerIdAccountsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, GetV1ResellersResellerIdAccountsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdAccountsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, QueryKey, GetV1ResellersResellerIdAccountsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsInfiniteQueryOptions(resellerId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdAccountsQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdAccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>> = ({ signal }) => getV1ResellersResellerIdAccounts(resellerId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>>
export type GetV1ResellersResellerIdAccountsQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccounts<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdAccountsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccounts<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdAccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccounts<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdAccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Accounts
 */

export function useGetV1ResellersResellerIdAccounts<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdAccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccounts>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsQueryOptions(resellerId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new account under a specific reseller. Administrators can define the account's details, such as its name, contact information, and other attributes. Once created, the account will be associated with the reseller and can be managed through the system.
 * @summary Create Account
 */
export const postV1ResellersResellerIdAccounts = (
    resellerId: string,
    resellerAccountCreateEntity: ResellerAccountCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountByIdResponse>> => {
    
    
    return axios.post(
      `/v1/resellers/${resellerId}/accounts`,
      resellerAccountCreateEntity,options
    );
  }



export const getPostV1ResellersResellerIdAccountsMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdAccounts>>, TError,{resellerId: string;data: ResellerAccountCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdAccounts>>, TError,{resellerId: string;data: ResellerAccountCreateEntity}, TContext> => {
    
const mutationKey = ['postV1ResellersResellerIdAccounts'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ResellersResellerIdAccounts>>, {resellerId: string;data: ResellerAccountCreateEntity}> = (props) => {
          const {resellerId,data} = props ?? {};

          return  postV1ResellersResellerIdAccounts(resellerId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ResellersResellerIdAccountsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ResellersResellerIdAccounts>>>
    export type PostV1ResellersResellerIdAccountsMutationBody = ResellerAccountCreateEntity
    export type PostV1ResellersResellerIdAccountsMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Account
 */
export const usePostV1ResellersResellerIdAccounts = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdAccounts>>, TError,{resellerId: string;data: ResellerAccountCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1ResellersResellerIdAccounts>>,
        TError,
        {resellerId: string;data: ResellerAccountCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1ResellersResellerIdAccountsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves metrics and performance data for a specific location associated with an account. It allows administrators to monitor the location's usage, operational efficiency, and other key performance indicators, providing insights for better management and decision-making.
 * @summary Get Metrics
 */
export const getV1AccountsAccountIdLocationsLocationIdMetrics = (
    accountId: string,
    locationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/metrics`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMetricsQueryKey = (accountId: string,
    locationId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/metrics`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMetricsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMetricsQueryKey(accountId,locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMetrics(accountId,locationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMetricsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>>
export type GetV1AccountsAccountIdLocationsLocationIdMetricsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Metrics
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMetricsInfiniteQueryOptions(accountId,locationId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMetricsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMetricsQueryKey(accountId,locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMetrics(accountId,locationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMetricsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>>
export type GetV1AccountsAccountIdLocationsLocationIdMetricsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMetrics<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMetrics<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMetrics<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Metrics
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMetrics<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMetricsQueryOptions(accountId,locationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves a list of all accounts in the system. The data returned includes account identifiers, names, and other relevant details, providing a comprehensive overview of the account base within the platform.
 * @summary List Accounts
 */
export const getV1Accounts = (
    params?: GetV1AccountsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsQueryKey = (params?: GetV1AccountsParams,) => {
    return [`/v1/accounts`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1Accounts>>, GetV1AccountsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(params?: GetV1AccountsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Accounts>>, TError, TData, Awaited<ReturnType<typeof getV1Accounts>>, QueryKey, GetV1AccountsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Accounts>>, QueryKey, GetV1AccountsParams['nextPageKey']> = ({ signal, pageParam }) => getV1Accounts({...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Accounts>>, TError, TData, Awaited<ReturnType<typeof getV1Accounts>>, QueryKey, GetV1AccountsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Accounts>>>
export type GetV1AccountsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1Accounts>>, GetV1AccountsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  GetV1AccountsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Accounts>>, TError, TData, Awaited<ReturnType<typeof getV1Accounts>>, QueryKey, GetV1AccountsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Accounts>>,
          TError,
          Awaited<ReturnType<typeof getV1Accounts>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1Accounts>>, GetV1AccountsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 params?: GetV1AccountsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Accounts>>, TError, TData, Awaited<ReturnType<typeof getV1Accounts>>, QueryKey, GetV1AccountsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Accounts>>,
          TError,
          Awaited<ReturnType<typeof getV1Accounts>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1Accounts>>, GetV1AccountsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 params?: GetV1AccountsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Accounts>>, TError, TData, Awaited<ReturnType<typeof getV1Accounts>>, QueryKey, GetV1AccountsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Accounts
 */

export function useGetV1AccountsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1Accounts>>, GetV1AccountsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 params?: GetV1AccountsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Accounts>>, TError, TData, Awaited<ReturnType<typeof getV1Accounts>>, QueryKey, GetV1AccountsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsQueryOptions = <TData = Awaited<ReturnType<typeof getV1Accounts>>, TError = AxiosError<ErrorResponse>>(params?: GetV1AccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Accounts>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Accounts>>> = ({ signal }) => getV1Accounts(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1Accounts>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Accounts>>>
export type GetV1AccountsQueryError = AxiosError<ErrorResponse>


export function useGetV1Accounts<TData = Awaited<ReturnType<typeof getV1Accounts>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  GetV1AccountsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Accounts>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Accounts>>,
          TError,
          Awaited<ReturnType<typeof getV1Accounts>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Accounts<TData = Awaited<ReturnType<typeof getV1Accounts>>, TError = AxiosError<ErrorResponse>>(
 params?: GetV1AccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Accounts>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Accounts>>,
          TError,
          Awaited<ReturnType<typeof getV1Accounts>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Accounts<TData = Awaited<ReturnType<typeof getV1Accounts>>, TError = AxiosError<ErrorResponse>>(
 params?: GetV1AccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Accounts>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Accounts
 */

export function useGetV1Accounts<TData = Awaited<ReturnType<typeof getV1Accounts>>, TError = AxiosError<ErrorResponse>>(
 params?: GetV1AccountsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Accounts>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new account in the system, providing essential details such as the account's name, contact information, and other attributes. Once created, the account will be available for management and monitoring within the platform.
 * @summary Create Account
 */
export const postV1Accounts = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts`,undefined,options
    );
  }



export const getPostV1AccountsMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1Accounts>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1Accounts>>, TError,void, TContext> => {
    
const mutationKey = ['postV1Accounts'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1Accounts>>, void> = () => {
          

          return  postV1Accounts(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1Accounts>>>
    
    export type PostV1AccountsMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Account
 */
export const usePostV1Accounts = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1Accounts>>, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1Accounts>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPostV1AccountsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all orders associated with a specific reseller. It returns order identifiers, status, and other relevant details. This endpoint is useful for resellers and administrators to monitor and manage orders across all accounts under their jurisdiction.
 * @summary List Reseller Orders
 */
export const getV1ResellersResellerIdOrders = (
    resellerId: string,
    params?: GetV1ResellersResellerIdOrdersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListOrdersResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/orders`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdOrdersQueryKey = (resellerId: string,
    params?: GetV1ResellersResellerIdOrdersParams,) => {
    return [`/v1/resellers/${resellerId}/orders`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdOrdersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, GetV1ResellersResellerIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, QueryKey, GetV1ResellersResellerIdOrdersParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdOrdersQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, QueryKey, GetV1ResellersResellerIdOrdersParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdOrders(resellerId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, QueryKey, GetV1ResellersResellerIdOrdersParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>>
export type GetV1ResellersResellerIdOrdersInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, GetV1ResellersResellerIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdOrdersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, QueryKey, GetV1ResellersResellerIdOrdersParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, GetV1ResellersResellerIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, QueryKey, GetV1ResellersResellerIdOrdersParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, GetV1ResellersResellerIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, QueryKey, GetV1ResellersResellerIdOrdersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Reseller Orders
 */

export function useGetV1ResellersResellerIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, GetV1ResellersResellerIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, QueryKey, GetV1ResellersResellerIdOrdersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdOrdersInfiniteQueryOptions(resellerId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdOrdersQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>> = ({ signal }) => getV1ResellersResellerIdOrders(resellerId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>>
export type GetV1ResellersResellerIdOrdersQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdOrders<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdOrdersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrders<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrders<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Reseller Orders
 */

export function useGetV1ResellersResellerIdOrders<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrders>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdOrdersQueryOptions(resellerId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint lists all the resellers that your have access to. The data returned includes reseller identifiers, names, and other relevant details. This endpoint is useful for managing and monitoring the resellers that you have access to.
 * @summary List Resellers
 */
export const getV1Resellers = (
    params?: GetV1ResellersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListResellersResponse>> => {
    
    
    return axios.get(
      `/v1/resellers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersQueryKey = (params?: GetV1ResellersParams,) => {
    return [`/v1/resellers`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1Resellers>>, GetV1ResellersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(params?: GetV1ResellersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Resellers>>, TError, TData, Awaited<ReturnType<typeof getV1Resellers>>, QueryKey, GetV1ResellersParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Resellers>>, QueryKey, GetV1ResellersParams['nextPageKey']> = ({ signal, pageParam }) => getV1Resellers({...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Resellers>>, TError, TData, Awaited<ReturnType<typeof getV1Resellers>>, QueryKey, GetV1ResellersParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Resellers>>>
export type GetV1ResellersInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1Resellers>>, GetV1ResellersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  GetV1ResellersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Resellers>>, TError, TData, Awaited<ReturnType<typeof getV1Resellers>>, QueryKey, GetV1ResellersParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Resellers>>,
          TError,
          Awaited<ReturnType<typeof getV1Resellers>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1Resellers>>, GetV1ResellersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 params?: GetV1ResellersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Resellers>>, TError, TData, Awaited<ReturnType<typeof getV1Resellers>>, QueryKey, GetV1ResellersParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Resellers>>,
          TError,
          Awaited<ReturnType<typeof getV1Resellers>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1Resellers>>, GetV1ResellersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 params?: GetV1ResellersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Resellers>>, TError, TData, Awaited<ReturnType<typeof getV1Resellers>>, QueryKey, GetV1ResellersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Resellers
 */

export function useGetV1ResellersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1Resellers>>, GetV1ResellersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 params?: GetV1ResellersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Resellers>>, TError, TData, Awaited<ReturnType<typeof getV1Resellers>>, QueryKey, GetV1ResellersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersInfiniteQueryOptions(params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersQueryOptions = <TData = Awaited<ReturnType<typeof getV1Resellers>>, TError = AxiosError<ErrorResponse>>(params?: GetV1ResellersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Resellers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Resellers>>> = ({ signal }) => getV1Resellers(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1Resellers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Resellers>>>
export type GetV1ResellersQueryError = AxiosError<ErrorResponse>


export function useGetV1Resellers<TData = Awaited<ReturnType<typeof getV1Resellers>>, TError = AxiosError<ErrorResponse>>(
 params: undefined |  GetV1ResellersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Resellers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Resellers>>,
          TError,
          Awaited<ReturnType<typeof getV1Resellers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Resellers<TData = Awaited<ReturnType<typeof getV1Resellers>>, TError = AxiosError<ErrorResponse>>(
 params?: GetV1ResellersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Resellers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Resellers>>,
          TError,
          Awaited<ReturnType<typeof getV1Resellers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Resellers<TData = Awaited<ReturnType<typeof getV1Resellers>>, TError = AxiosError<ErrorResponse>>(
 params?: GetV1ResellersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Resellers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Resellers
 */

export function useGetV1Resellers<TData = Awaited<ReturnType<typeof getV1Resellers>>, TError = AxiosError<ErrorResponse>>(
 params?: GetV1ResellersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Resellers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves detailed information about a specific dispatch associated with a delivery at a location, identified by the dispatchId parameter. It provides comprehensive data about the dispatch, including status, driver information, and other relevant details.
 * @summary Get Dispatched delivery by dispatch id
 */
export const getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId = (
    accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDispatchedByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/deliveries/${deliveryId}/dispatch/${dispatchId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdQueryKey = (accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/deliveries/${deliveryId}/dispatch/${dispatchId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdQueryKey(accountId,locationId,deliveryId,dispatchId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId(accountId,locationId,deliveryId,dispatchId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && deliveryId && dispatchId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>>
export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Dispatched delivery by dispatch id
 */

export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdInfiniteQueryOptions(accountId,locationId,deliveryId,dispatchId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdQueryKey(accountId,locationId,deliveryId,dispatchId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId(accountId,locationId,deliveryId,dispatchId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && deliveryId && dispatchId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>>
export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Dispatched delivery by dispatch id
 */

export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdQueryOptions(accountId,locationId,deliveryId,dispatchId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for updating the information of a specific dispatch associated with a delivery at a location. Administrators can modify various aspects of the dispatch, such as its status, driver information, or other attributes, ensuring that the dispatch remains current and accurate.
 * @summary Update Dispatch Delivery
 */
export const patchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId = (
    accountId: string,
    locationId: string,
    deliveryId: string,
    dispatchId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDispatchedByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/deliveries/${deliveryId}/dispatch/${dispatchId}`,undefined,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError,{accountId: string;locationId: string;deliveryId: string;dispatchId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError,{accountId: string;locationId: string;deliveryId: string;dispatchId: string}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, {accountId: string;locationId: string;deliveryId: string;dispatchId: string}> = (props) => {
          const {accountId,locationId,deliveryId,dispatchId} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId(accountId,locationId,deliveryId,dispatchId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>>
    
    export type PatchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Dispatch Delivery
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>, TError,{accountId: string;locationId: string;deliveryId: string;dispatchId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchId>>,
        TError,
        {accountId: string;locationId: string;deliveryId: string;dispatchId: string},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdDeliveriesDeliveryIdDispatchDispatchIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all items associated with a specific menu at a location. The data includes item identifiers, names, and other relevant details, providing an overview of the items available within the menu at the specified location.
 * @summary List Items
 */
export const getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems = (
    accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountMenuItemsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/items`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsQueryKey = (accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/items`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsQueryKey(accountId,locationId,menuId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems(accountId,locationId,menuId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Items
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsInfiniteQueryOptions(accountId,locationId,menuId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsQueryKey(accountId,locationId,menuId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems(accountId,locationId,menuId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Items
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsQueryOptions(accountId,locationId,menuId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new item within a specific menu at a location. Administrators can define the item's details, including its name, description, and pricing. Once created, the item will be part of the menu and available to customers.
 * @summary Create Item
 */
export const postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems = (
    accountId: string,
    locationId: string,
    menuId: string,
    menuItemCreateEntity: MenuItemCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountMenuItemByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/items`,
      menuItemCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuItemCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuItemCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, {accountId: string;locationId: string;menuId: string;data: MenuItemCreateEntity}> = (props) => {
          const {accountId,locationId,menuId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems(accountId,locationId,menuId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>>
    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsMutationBody = MenuItemCreateEntity
    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Item
 */
export const usePostV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuItemCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItems>>,
        TError,
        {accountId: string;locationId: string;menuId: string;data: MenuItemCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for the refresh of a specific delivery associated with an order under a reseller. The deliveryId parameter identifies the delivery to be refreshed. This operation will update the delivery status and make it available for further processing.
 * @summary Refresh Order Delivery
 */
export const postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefresh = (
    resellerId: string,
    orderId: string,
    deliveryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.post(
      `/v1/resellers/${resellerId}/orders/${orderId}/deliveries/${deliveryId}/refresh`,undefined,options
    );
  }



export const getPostV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefreshMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefresh>>, TError,{resellerId: string;orderId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefresh>>, TError,{resellerId: string;orderId: string;deliveryId: string}, TContext> => {
    
const mutationKey = ['postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefresh'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefresh>>, {resellerId: string;orderId: string;deliveryId: string}> = (props) => {
          const {resellerId,orderId,deliveryId} = props ?? {};

          return  postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefresh(resellerId,orderId,deliveryId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefresh>>>
    
    export type PostV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefreshMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Refresh Order Delivery
 */
export const usePostV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefresh = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefresh>>, TError,{resellerId: string;orderId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefresh>>,
        TError,
        {resellerId: string;orderId: string;deliveryId: string},
        TContext
      > => {

      const mutationOptions = getPostV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdRefreshMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves audit logs for a specific order associated with a location. The logs provide detailed records of actions and changes made to the order, allowing users to review and analyze order history for compliance, troubleshooting, and quality assurance purposes.
 * @summary Get Order Audits
 */
export const getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits = (
    accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAuditsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/orders/${orderId}/audits`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsQueryKey = (accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/orders/${orderId}/audits`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsQueryKey(accountId,locationId,orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits(accountId,locationId,orderId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && orderId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>>
export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Order Audits
 */

export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsInfiniteQueryOptions(accountId,locationId,orderId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsQueryKey(accountId,locationId,orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits(accountId,locationId,orderId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && orderId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>>
export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Order Audits
 */

export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdAuditsQueryOptions(accountId,locationId,orderId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves a list of all applications associated with a specific user. The data includes application identifiers, names, and other relevant details, providing a comprehensive overview of the applications that the user can access or manage.
 * @summary List Applications
 */
export const getV1UsersUserIdApplications = (
    userId: string,
    params?: GetV1UsersUserIdApplicationsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListApplicationsResponse>> => {
    
    
    return axios.get(
      `/v1/users/${userId}/applications`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1UsersUserIdApplicationsQueryKey = (userId: string,
    params?: GetV1UsersUserIdApplicationsParams,) => {
    return [`/v1/users/${userId}/applications`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1UsersUserIdApplicationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, GetV1UsersUserIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(userId: string,
    params?: GetV1UsersUserIdApplicationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, QueryKey, GetV1UsersUserIdApplicationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1UsersUserIdApplicationsQueryKey(userId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, QueryKey, GetV1UsersUserIdApplicationsParams['nextPageKey']> = ({ signal, pageParam }) => getV1UsersUserIdApplications(userId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, QueryKey, GetV1UsersUserIdApplicationsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1UsersUserIdApplicationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>>
export type GetV1UsersUserIdApplicationsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1UsersUserIdApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, GetV1UsersUserIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    params: undefined |  GetV1UsersUserIdApplicationsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, QueryKey, GetV1UsersUserIdApplicationsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplications>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, GetV1UsersUserIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    params?: GetV1UsersUserIdApplicationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, QueryKey, GetV1UsersUserIdApplicationsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplications>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, GetV1UsersUserIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    params?: GetV1UsersUserIdApplicationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, QueryKey, GetV1UsersUserIdApplicationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Applications
 */

export function useGetV1UsersUserIdApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, GetV1UsersUserIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    params?: GetV1UsersUserIdApplicationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, QueryKey, GetV1UsersUserIdApplicationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1UsersUserIdApplicationsInfiniteQueryOptions(userId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1UsersUserIdApplicationsQueryOptions = <TData = Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError = AxiosError<ErrorResponse>>(userId: string,
    params?: GetV1UsersUserIdApplicationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1UsersUserIdApplicationsQueryKey(userId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>> = ({ signal }) => getV1UsersUserIdApplications(userId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1UsersUserIdApplicationsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>>
export type GetV1UsersUserIdApplicationsQueryError = AxiosError<ErrorResponse>


export function useGetV1UsersUserIdApplications<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    params: undefined |  GetV1UsersUserIdApplicationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplications>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplications<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    params?: GetV1UsersUserIdApplicationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplications>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplications<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    params?: GetV1UsersUserIdApplicationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Applications
 */

export function useGetV1UsersUserIdApplications<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    params?: GetV1UsersUserIdApplicationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplications>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1UsersUserIdApplicationsQueryOptions(userId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new application associated with a specific user. Administrators can configure the application's details, including its name and settings, providing the user with access to the application's features and capabilities.
 * @summary Create Application
 */
export const postV1UsersUserIdApplications = (
    userId: string,
    applicationCreateEntity: ApplicationCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetApplicationByIdResponse>> => {
    
    
    return axios.post(
      `/v1/users/${userId}/applications`,
      applicationCreateEntity,options
    );
  }



export const getPostV1UsersUserIdApplicationsMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1UsersUserIdApplications>>, TError,{userId: string;data: ApplicationCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1UsersUserIdApplications>>, TError,{userId: string;data: ApplicationCreateEntity}, TContext> => {
    
const mutationKey = ['postV1UsersUserIdApplications'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1UsersUserIdApplications>>, {userId: string;data: ApplicationCreateEntity}> = (props) => {
          const {userId,data} = props ?? {};

          return  postV1UsersUserIdApplications(userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1UsersUserIdApplicationsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1UsersUserIdApplications>>>
    export type PostV1UsersUserIdApplicationsMutationBody = ApplicationCreateEntity
    export type PostV1UsersUserIdApplicationsMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Application
 */
export const usePostV1UsersUserIdApplications = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1UsersUserIdApplications>>, TError,{userId: string;data: ApplicationCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1UsersUserIdApplications>>,
        TError,
        {userId: string;data: ApplicationCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1UsersUserIdApplicationsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves metrics and performance data for a specific application associated with a user. It allows administrators to monitor the application's usage and effectiveness, providing insights that can inform decisions about resource allocation and user engagement.
 * @summary Get Metrics
 */
export const getV1UsersUserIdApplicationsApplicationIdMetrics = (
    userId: string,
    applicationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.get(
      `/v1/users/${userId}/applications/${applicationId}/metrics`,options
    );
  }


export const getGetV1UsersUserIdApplicationsApplicationIdMetricsQueryKey = (userId: string,
    applicationId: string,) => {
    return [`/v1/users/${userId}/applications/${applicationId}/metrics`] as const;
    }

    
export const getGetV1UsersUserIdApplicationsApplicationIdMetricsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>>, TError = AxiosError<ErrorResponse>>(userId: string,
    applicationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1UsersUserIdApplicationsApplicationIdMetricsQueryKey(userId,applicationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>> = ({ signal }) => getV1UsersUserIdApplicationsApplicationIdMetrics(userId,applicationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId && applicationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1UsersUserIdApplicationsApplicationIdMetricsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>>
export type GetV1UsersUserIdApplicationsApplicationIdMetricsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1UsersUserIdApplicationsApplicationIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsApplicationIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsApplicationIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Metrics
 */

export function useGetV1UsersUserIdApplicationsApplicationIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1UsersUserIdApplicationsApplicationIdMetricsInfiniteQueryOptions(userId,applicationId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1UsersUserIdApplicationsApplicationIdMetricsQueryOptions = <TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError = AxiosError<ErrorResponse>>(userId: string,
    applicationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1UsersUserIdApplicationsApplicationIdMetricsQueryKey(userId,applicationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>> = ({ signal }) => getV1UsersUserIdApplicationsApplicationIdMetrics(userId,applicationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId && applicationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1UsersUserIdApplicationsApplicationIdMetricsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>>
export type GetV1UsersUserIdApplicationsApplicationIdMetricsQueryError = AxiosError<ErrorResponse>


export function useGetV1UsersUserIdApplicationsApplicationIdMetrics<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsApplicationIdMetrics<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsApplicationIdMetrics<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Metrics
 */

export function useGetV1UsersUserIdApplicationsApplicationIdMetrics<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1UsersUserIdApplicationsApplicationIdMetricsQueryOptions(userId,applicationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for uploading an image for a specific application associated with a user. The image can be used for branding or identification purposes within the application. Proper authorization is required to perform this action, and the image must meet the specified requirements.
 * @summary Request Image Upload
 */
export const postV1UsersUserIdApplicationsApplicationIdImage = (
    userId: string,
    applicationId: string,
    signedUrlRequest: SignedUrlRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SignedUrlResponse>> => {
    
    
    return axios.post(
      `/v1/users/${userId}/applications/${applicationId}/image`,
      signedUrlRequest,options
    );
  }



export const getPostV1UsersUserIdApplicationsApplicationIdImageMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1UsersUserIdApplicationsApplicationIdImage>>, TError,{userId: string;applicationId: string;data: SignedUrlRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1UsersUserIdApplicationsApplicationIdImage>>, TError,{userId: string;applicationId: string;data: SignedUrlRequest}, TContext> => {
    
const mutationKey = ['postV1UsersUserIdApplicationsApplicationIdImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1UsersUserIdApplicationsApplicationIdImage>>, {userId: string;applicationId: string;data: SignedUrlRequest}> = (props) => {
          const {userId,applicationId,data} = props ?? {};

          return  postV1UsersUserIdApplicationsApplicationIdImage(userId,applicationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1UsersUserIdApplicationsApplicationIdImageMutationResult = NonNullable<Awaited<ReturnType<typeof postV1UsersUserIdApplicationsApplicationIdImage>>>
    export type PostV1UsersUserIdApplicationsApplicationIdImageMutationBody = SignedUrlRequest
    export type PostV1UsersUserIdApplicationsApplicationIdImageMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Request Image Upload
 */
export const usePostV1UsersUserIdApplicationsApplicationIdImage = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1UsersUserIdApplicationsApplicationIdImage>>, TError,{userId: string;applicationId: string;data: SignedUrlRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1UsersUserIdApplicationsApplicationIdImage>>,
        TError,
        {userId: string;applicationId: string;data: SignedUrlRequest},
        TContext
      > => {

      const mutationOptions = getPostV1UsersUserIdApplicationsApplicationIdImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for the deletion of an image associated with a specific application linked to a user. Once deleted, the image will no longer be displayed in the application, and users will need to upload a new image if necessary.
 * @summary Delete Image
 */
export const deleteV1UsersUserIdApplicationsApplicationIdImage = (
    userId: string,
    applicationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/users/${userId}/applications/${applicationId}/image`,options
    );
  }



export const getDeleteV1UsersUserIdApplicationsApplicationIdImageMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1UsersUserIdApplicationsApplicationIdImage>>, TError,{userId: string;applicationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1UsersUserIdApplicationsApplicationIdImage>>, TError,{userId: string;applicationId: string}, TContext> => {
    
const mutationKey = ['deleteV1UsersUserIdApplicationsApplicationIdImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1UsersUserIdApplicationsApplicationIdImage>>, {userId: string;applicationId: string}> = (props) => {
          const {userId,applicationId} = props ?? {};

          return  deleteV1UsersUserIdApplicationsApplicationIdImage(userId,applicationId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1UsersUserIdApplicationsApplicationIdImageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1UsersUserIdApplicationsApplicationIdImage>>>
    
    export type DeleteV1UsersUserIdApplicationsApplicationIdImageMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Image
 */
export const useDeleteV1UsersUserIdApplicationsApplicationIdImage = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1UsersUserIdApplicationsApplicationIdImage>>, TError,{userId: string;applicationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1UsersUserIdApplicationsApplicationIdImage>>,
        TError,
        {userId: string;applicationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1UsersUserIdApplicationsApplicationIdImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all modifiers associated with a specific menu at a location. The data includes modifier identifiers, names, and other relevant details, providing an overview of the modifiers available within the menu at the specified location.
 * @summary List Modifiers
 */
export const getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers = (
    accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountMenuModifiersResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifiers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersQueryKey = (accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifiers`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersQueryKey(accountId,locationId,menuId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers(accountId,locationId,menuId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Modifiers
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersInfiniteQueryOptions(accountId,locationId,menuId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersQueryKey(accountId,locationId,menuId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers(accountId,locationId,menuId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Modifiers
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersQueryOptions(accountId,locationId,menuId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new modifier within a specific menu at a location. Users can define the modifier's details, including its name, description, and pricing. Once created, the modifier will be part of the menu and available for use in customizing menu items.
 * @summary Create Modifier
 */
export const postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers = (
    accountId: string,
    locationId: string,
    menuId: string,
    menuModifierCreateEntity: MenuModifierCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountMenuModifierByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifiers`,
      menuModifierCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuModifierCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuModifierCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, {accountId: string;locationId: string;menuId: string;data: MenuModifierCreateEntity}> = (props) => {
          const {accountId,locationId,menuId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers(accountId,locationId,menuId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>>
    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersMutationBody = MenuModifierCreateEntity
    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Modifier
 */
export const usePostV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuModifierCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiers>>,
        TError,
        {accountId: string;locationId: string;menuId: string;data: MenuModifierCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific product within a catalog at a location, identified by the productId parameter. It provides comprehensive data about the product, including its description, pricing, and availability, allowing for effective management and updates.
 * @summary Get Catalog Product
 */
export const getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId = (
    accountId: string,
    locationId: string,
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountProductByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/products/${productId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdQueryKey = (accountId: string,
    locationId: string,
    productId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/catalog/products/${productId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    productId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdQueryKey(accountId,locationId,productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId(accountId,locationId,productId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && productId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Product
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdInfiniteQueryOptions(accountId,locationId,productId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdQueryKey(accountId,locationId,productId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId(accountId,locationId,productId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && productId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Product
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdQueryOptions(accountId,locationId,productId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific product within a catalog at a location. The productId parameter identifies the product to be deleted, which will remove it from the system and disassociate it from the catalog.
 * @summary Delete Catalog Product
 */
export const deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId = (
    accountId: string,
    locationId: string,
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/products/${productId}`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError,{accountId: string;locationId: string;productId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError,{accountId: string;locationId: string;productId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, {accountId: string;locationId: string;productId: string}> = (props) => {
          const {accountId,locationId,productId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId(accountId,locationId,productId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Catalog Product
 */
export const useDeleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError,{accountId: string;locationId: string;productId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>,
        TError,
        {accountId: string;locationId: string;productId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the information of a specific product within a catalog at a location. Users can modify the product's details, such as its name, description, pricing, or availability, ensuring that the product remains current and aligned with the catalog's inventory and offerings.
 * @summary Update Catalog Product
 */
export const patchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId = (
    accountId: string,
    locationId: string,
    productId: string,
    catalogProductPatchEntity: CatalogProductPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountProductByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/products/${productId}`,
      catalogProductPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError,{accountId: string;locationId: string;productId: string;data: CatalogProductPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError,{accountId: string;locationId: string;productId: string;data: CatalogProductPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, {accountId: string;locationId: string;productId: string;data: CatalogProductPatchEntity}> = (props) => {
          const {accountId,locationId,productId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId(accountId,locationId,productId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdMutationBody = CatalogProductPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Catalog Product
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>, TError,{accountId: string;locationId: string;productId: string;data: CatalogProductPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductId>>,
        TError,
        {accountId: string;locationId: string;productId: string;data: CatalogProductPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific application associated with a user. It provides data such as the application's name, description, and status, making it useful for managing the user's access to the application.
 * @summary Get Application
 */
export const getV1UsersUserIdApplicationsApplicationId = (
    userId: string,
    applicationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetApplicationByIdResponse>> => {
    
    
    return axios.get(
      `/v1/users/${userId}/applications/${applicationId}`,options
    );
  }


export const getGetV1UsersUserIdApplicationsApplicationIdQueryKey = (userId: string,
    applicationId: string,) => {
    return [`/v1/users/${userId}/applications/${applicationId}`] as const;
    }

    
export const getGetV1UsersUserIdApplicationsApplicationIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>>, TError = AxiosError<ErrorResponse>>(userId: string,
    applicationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1UsersUserIdApplicationsApplicationIdQueryKey(userId,applicationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>> = ({ signal }) => getV1UsersUserIdApplicationsApplicationId(userId,applicationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId && applicationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1UsersUserIdApplicationsApplicationIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>>
export type GetV1UsersUserIdApplicationsApplicationIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1UsersUserIdApplicationsApplicationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsApplicationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsApplicationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Application
 */

export function useGetV1UsersUserIdApplicationsApplicationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1UsersUserIdApplicationsApplicationIdInfiniteQueryOptions(userId,applicationId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1UsersUserIdApplicationsApplicationIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError = AxiosError<ErrorResponse>>(userId: string,
    applicationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1UsersUserIdApplicationsApplicationIdQueryKey(userId,applicationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>> = ({ signal }) => getV1UsersUserIdApplicationsApplicationId(userId,applicationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId && applicationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1UsersUserIdApplicationsApplicationIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>>
export type GetV1UsersUserIdApplicationsApplicationIdQueryError = AxiosError<ErrorResponse>


export function useGetV1UsersUserIdApplicationsApplicationId<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsApplicationId<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdApplicationsApplicationId<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Application
 */

export function useGetV1UsersUserIdApplicationsApplicationId<TData = Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError = AxiosError<ErrorResponse>>(
 userId: string,
    applicationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserIdApplicationsApplicationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1UsersUserIdApplicationsApplicationIdQueryOptions(userId,applicationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific application associated with a user. The applicationId parameter identifies the application to be removed, and once deleted, the user will no longer have access to that application.
 * @summary Delete Application
 */
export const deleteV1UsersUserIdApplicationsApplicationId = (
    userId: string,
    applicationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/users/${userId}/applications/${applicationId}`,options
    );
  }



export const getDeleteV1UsersUserIdApplicationsApplicationIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1UsersUserIdApplicationsApplicationId>>, TError,{userId: string;applicationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1UsersUserIdApplicationsApplicationId>>, TError,{userId: string;applicationId: string}, TContext> => {
    
const mutationKey = ['deleteV1UsersUserIdApplicationsApplicationId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1UsersUserIdApplicationsApplicationId>>, {userId: string;applicationId: string}> = (props) => {
          const {userId,applicationId} = props ?? {};

          return  deleteV1UsersUserIdApplicationsApplicationId(userId,applicationId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1UsersUserIdApplicationsApplicationIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1UsersUserIdApplicationsApplicationId>>>
    
    export type DeleteV1UsersUserIdApplicationsApplicationIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Application
 */
export const useDeleteV1UsersUserIdApplicationsApplicationId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1UsersUserIdApplicationsApplicationId>>, TError,{userId: string;applicationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1UsersUserIdApplicationsApplicationId>>,
        TError,
        {userId: string;applicationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1UsersUserIdApplicationsApplicationIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the details of a specific application associated with a user. Administrators can modify the application's settings, ensuring that it aligns with the user's needs and access rights.
 * @summary Update Application
 */
export const patchV1UsersUserIdApplicationsApplicationId = (
    userId: string,
    applicationId: string,
    applicationPatchEntity: ApplicationPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetApplicationByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/users/${userId}/applications/${applicationId}`,
      applicationPatchEntity,options
    );
  }



export const getPatchV1UsersUserIdApplicationsApplicationIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1UsersUserIdApplicationsApplicationId>>, TError,{userId: string;applicationId: string;data: ApplicationPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1UsersUserIdApplicationsApplicationId>>, TError,{userId: string;applicationId: string;data: ApplicationPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1UsersUserIdApplicationsApplicationId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1UsersUserIdApplicationsApplicationId>>, {userId: string;applicationId: string;data: ApplicationPatchEntity}> = (props) => {
          const {userId,applicationId,data} = props ?? {};

          return  patchV1UsersUserIdApplicationsApplicationId(userId,applicationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1UsersUserIdApplicationsApplicationIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1UsersUserIdApplicationsApplicationId>>>
    export type PatchV1UsersUserIdApplicationsApplicationIdMutationBody = ApplicationPatchEntity
    export type PatchV1UsersUserIdApplicationsApplicationIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Application
 */
export const usePatchV1UsersUserIdApplicationsApplicationId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1UsersUserIdApplicationsApplicationId>>, TError,{userId: string;applicationId: string;data: ApplicationPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1UsersUserIdApplicationsApplicationId>>,
        TError,
        {userId: string;applicationId: string;data: ApplicationPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1UsersUserIdApplicationsApplicationIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific connection associated with an account, identified by the connectionId parameter. It provides comprehensive data about the connection, including its configuration, status, and associated services, allowing for effective management and troubleshooting.
 * @summary Get Connection Details
 */
export const getV1AccountsAccountIdConnectionsConnectionId = (
    accountId: string,
    connectionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetConnectionByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/connections/${connectionId}`,options
    );
  }


export const getGetV1AccountsAccountIdConnectionsConnectionIdQueryKey = (accountId: string,
    connectionId: string,) => {
    return [`/v1/accounts/${accountId}/connections/${connectionId}`] as const;
    }

    
export const getGetV1AccountsAccountIdConnectionsConnectionIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    connectionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdConnectionsConnectionIdQueryKey(accountId,connectionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>> = ({ signal }) => getV1AccountsAccountIdConnectionsConnectionId(accountId,connectionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && connectionId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdConnectionsConnectionIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>>
export type GetV1AccountsAccountIdConnectionsConnectionIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdConnectionsConnectionIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    connectionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdConnectionsConnectionIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    connectionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdConnectionsConnectionIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    connectionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Connection Details
 */

export function useGetV1AccountsAccountIdConnectionsConnectionIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    connectionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdConnectionsConnectionIdInfiniteQueryOptions(accountId,connectionId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdConnectionsConnectionIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    connectionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdConnectionsConnectionIdQueryKey(accountId,connectionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>> = ({ signal }) => getV1AccountsAccountIdConnectionsConnectionId(accountId,connectionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && connectionId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdConnectionsConnectionIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>>
export type GetV1AccountsAccountIdConnectionsConnectionIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdConnectionsConnectionId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    connectionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdConnectionsConnectionId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    connectionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdConnectionsConnectionId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    connectionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Connection Details
 */

export function useGetV1AccountsAccountIdConnectionsConnectionId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    connectionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdConnectionsConnectionId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdConnectionsConnectionIdQueryOptions(accountId,connectionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the refresh of a specific delivery associated with an order under a reseller. The deliveryId parameter identifies the delivery to be refreshed. This operation will update the delivery status and make it available for further processing.
 * @summary Refresh Delivery Quotes
 */
export const postV1ResellersResellerIdDeliveriesDeliveryIdRefresh = (
    resellerId: string,
    deliveryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.post(
      `/v1/resellers/${resellerId}/deliveries/${deliveryId}/refresh`,undefined,options
    );
  }



export const getPostV1ResellersResellerIdDeliveriesDeliveryIdRefreshMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdRefresh>>, TError,{resellerId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdRefresh>>, TError,{resellerId: string;deliveryId: string}, TContext> => {
    
const mutationKey = ['postV1ResellersResellerIdDeliveriesDeliveryIdRefresh'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdRefresh>>, {resellerId: string;deliveryId: string}> = (props) => {
          const {resellerId,deliveryId} = props ?? {};

          return  postV1ResellersResellerIdDeliveriesDeliveryIdRefresh(resellerId,deliveryId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ResellersResellerIdDeliveriesDeliveryIdRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdRefresh>>>
    
    export type PostV1ResellersResellerIdDeliveriesDeliveryIdRefreshMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Refresh Delivery Quotes
 */
export const usePostV1ResellersResellerIdDeliveriesDeliveryIdRefresh = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdRefresh>>, TError,{resellerId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdRefresh>>,
        TError,
        {resellerId: string;deliveryId: string},
        TContext
      > => {

      const mutationOptions = getPostV1ResellersResellerIdDeliveriesDeliveryIdRefreshMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all deliveries associated with a specific account. The data returned includes delivery identifiers, statuses, and other relevant details, providing a comprehensive overview of all deliveries managed by the account.
 * @summary List Deliveries
 */
export const getV1AccountsAccountIdDeliveries = (
    accountId: string,
    params?: GetV1AccountsAccountIdDeliveriesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListDeliveriesResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/deliveries`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdDeliveriesQueryKey = (accountId: string,
    params?: GetV1AccountsAccountIdDeliveriesParams,) => {
    return [`/v1/accounts/${accountId}/deliveries`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdDeliveriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, GetV1AccountsAccountIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    params?: GetV1AccountsAccountIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, QueryKey, GetV1AccountsAccountIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdDeliveriesQueryKey(accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, QueryKey, GetV1AccountsAccountIdDeliveriesParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdDeliveries(accountId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, QueryKey, GetV1AccountsAccountIdDeliveriesParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdDeliveriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>>
export type GetV1AccountsAccountIdDeliveriesInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, GetV1AccountsAccountIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params: undefined |  GetV1AccountsAccountIdDeliveriesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, QueryKey, GetV1AccountsAccountIdDeliveriesParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, GetV1AccountsAccountIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, QueryKey, GetV1AccountsAccountIdDeliveriesParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, GetV1AccountsAccountIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, QueryKey, GetV1AccountsAccountIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Deliveries
 */

export function useGetV1AccountsAccountIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, GetV1AccountsAccountIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, QueryKey, GetV1AccountsAccountIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdDeliveriesInfiniteQueryOptions(accountId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdDeliveriesQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    params?: GetV1AccountsAccountIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdDeliveriesQueryKey(accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>> = ({ signal }) => getV1AccountsAccountIdDeliveries(accountId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdDeliveriesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>>
export type GetV1AccountsAccountIdDeliveriesQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdDeliveries<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params: undefined |  GetV1AccountsAccountIdDeliveriesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdDeliveries<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdDeliveries<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Deliveries
 */

export function useGetV1AccountsAccountIdDeliveries<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdDeliveriesQueryOptions(accountId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new delivery under a specific account. Users can define the delivery details, such as items, pickup time, and other attributes. Once created, the delivery will be associated with the account and managed accordingly.
 * @summary Create Delivery
 */
export const postV1AccountsAccountIdDeliveries = (
    accountId: string,
    deliveryCreateEntity: DeliveryCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/deliveries`,
      deliveryCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdDeliveriesMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveries>>, TError,{accountId: string;data: DeliveryCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveries>>, TError,{accountId: string;data: DeliveryCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdDeliveries'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveries>>, {accountId: string;data: DeliveryCreateEntity}> = (props) => {
          const {accountId,data} = props ?? {};

          return  postV1AccountsAccountIdDeliveries(accountId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdDeliveriesMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveries>>>
    export type PostV1AccountsAccountIdDeliveriesMutationBody = DeliveryCreateEntity
    export type PostV1AccountsAccountIdDeliveriesMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Delivery
 */
export const usePostV1AccountsAccountIdDeliveries = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveries>>, TError,{accountId: string;data: DeliveryCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveries>>,
        TError,
        {accountId: string;data: DeliveryCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdDeliveriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all applications available in the system. The data returned includes application identifiers, names, and descriptions, providing an overview of the applications that can be managed or integrated with the platform.
 * @summary List Applications
 */
export const getV1Applications = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListApplicationsInfoResponse>> => {
    
    
    return axios.get(
      `/v1/applications`,options
    );
  }


export const getGetV1ApplicationsQueryKey = () => {
    return [`/v1/applications`] as const;
    }

    
export const getGetV1ApplicationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1Applications>>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Applications>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ApplicationsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Applications>>> = ({ signal }) => getV1Applications({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Applications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ApplicationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Applications>>>
export type GetV1ApplicationsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1Applications>>>, TError = AxiosError<ErrorResponse>>(
  options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Applications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Applications>>,
          TError,
          Awaited<ReturnType<typeof getV1Applications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1Applications>>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Applications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Applications>>,
          TError,
          Awaited<ReturnType<typeof getV1Applications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1Applications>>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Applications>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Applications
 */

export function useGetV1ApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1Applications>>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1Applications>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ApplicationsInfiniteQueryOptions(options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ApplicationsQueryOptions = <TData = Awaited<ReturnType<typeof getV1Applications>>, TError = AxiosError<ErrorResponse>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Applications>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ApplicationsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1Applications>>> = ({ signal }) => getV1Applications({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn,   staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1Applications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ApplicationsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1Applications>>>
export type GetV1ApplicationsQueryError = AxiosError<ErrorResponse>


export function useGetV1Applications<TData = Awaited<ReturnType<typeof getV1Applications>>, TError = AxiosError<ErrorResponse>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Applications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Applications>>,
          TError,
          Awaited<ReturnType<typeof getV1Applications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Applications<TData = Awaited<ReturnType<typeof getV1Applications>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Applications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1Applications>>,
          TError,
          Awaited<ReturnType<typeof getV1Applications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1Applications<TData = Awaited<ReturnType<typeof getV1Applications>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Applications>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Applications
 */

export function useGetV1Applications<TData = Awaited<ReturnType<typeof getV1Applications>>, TError = AxiosError<ErrorResponse>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1Applications>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ApplicationsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves detailed information about a specific user identified by the userId parameter. It provides comprehensive data about the user, including their personal details, role, and account associations. This information is crucial for managing user permissions and access.
 * @summary Get User
 */
export const getV1UsersUserId = (
    userId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserByIdResponse>> => {
    
    
    return axios.get(
      `/v1/users/${userId}`,options
    );
  }


export const getGetV1UsersUserIdQueryKey = (userId: string,) => {
    return [`/v1/users/${userId}`] as const;
    }

    
export const getGetV1UsersUserIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserId>>>, TError = AxiosError<ErrorResponse>>(userId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1UsersUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1UsersUserId>>> = ({ signal }) => getV1UsersUserId(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1UsersUserIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1UsersUserId>>>
export type GetV1UsersUserIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1UsersUserIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserId>>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserId>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserId>>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserId>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserId>>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User
 */

export function useGetV1UsersUserIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1UsersUserId>>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1UsersUserId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1UsersUserIdInfiniteQueryOptions(userId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1UsersUserIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1UsersUserId>>, TError = AxiosError<ErrorResponse>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1UsersUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1UsersUserId>>> = ({ signal }) => getV1UsersUserId(userId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1UsersUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1UsersUserId>>>
export type GetV1UsersUserIdQueryError = AxiosError<ErrorResponse>


export function useGetV1UsersUserId<TData = Awaited<ReturnType<typeof getV1UsersUserId>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserId>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserId<TData = Awaited<ReturnType<typeof getV1UsersUserId>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1UsersUserId>>,
          TError,
          Awaited<ReturnType<typeof getV1UsersUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1UsersUserId<TData = Awaited<ReturnType<typeof getV1UsersUserId>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User
 */

export function useGetV1UsersUserId<TData = Awaited<ReturnType<typeof getV1UsersUserId>>, TError = AxiosError<ErrorResponse>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1UsersUserId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1UsersUserIdQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for updating the information of a specific user in the system. Administrators can modify the user's details, such as their role, status, or personal information, ensuring that their profile remains up-to-date and accurately reflects their access rights.
 * @summary Update User
 */
export const patchV1UsersUserId = (
    userId: string,
    userPatchEntity: UserPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/users/${userId}`,
      userPatchEntity,options
    );
  }



export const getPatchV1UsersUserIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1UsersUserId>>, TError,{userId: string;data: UserPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1UsersUserId>>, TError,{userId: string;data: UserPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1UsersUserId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1UsersUserId>>, {userId: string;data: UserPatchEntity}> = (props) => {
          const {userId,data} = props ?? {};

          return  patchV1UsersUserId(userId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1UsersUserIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1UsersUserId>>>
    export type PatchV1UsersUserIdMutationBody = UserPatchEntity
    export type PatchV1UsersUserIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update User
 */
export const usePatchV1UsersUserId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1UsersUserId>>, TError,{userId: string;data: UserPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1UsersUserId>>,
        TError,
        {userId: string;data: UserPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1UsersUserIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all deliveries associated with a specific location under an account. The data returned includes delivery identifiers, statuses, and other relevant details, providing a comprehensive overview of all deliveries managed by the location.
 * @summary List Deliveries
 */
export const getV1AccountsAccountIdLocationsLocationIdDeliveries = (
    accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListDeliveriesResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/deliveries`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdDeliveriesQueryKey = (accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/deliveries`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdDeliveriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdDeliveriesQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdDeliveries(accountId,locationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>>
export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Deliveries
 */

export function useGetV1AccountsAccountIdLocationsLocationIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdDeliveriesInfiniteQueryOptions(accountId,locationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdDeliveriesQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdDeliveriesQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdDeliveries(accountId,locationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>>
export type GetV1AccountsAccountIdLocationsLocationIdDeliveriesQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdDeliveries<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdDeliveries<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdDeliveries<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Deliveries
 */

export function useGetV1AccountsAccountIdLocationsLocationIdDeliveries<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdDeliveriesQueryOptions(accountId,locationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves a list of all modifier groups associated with a specific menu at a location. The data includes modifier group identifiers, names, and other relevant details, providing an overview of the modifier groups available within the menu at the specified location.
 * @summary List Modifier Groups
 */
export const getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups = (
    accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountMenuModifierGroupsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifier-groups`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsQueryKey = (accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifier-groups`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsQueryKey(accountId,locationId,menuId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups(accountId,locationId,menuId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Modifier Groups
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsInfiniteQueryOptions(accountId,locationId,menuId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsQueryKey(accountId,locationId,menuId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups(accountId,locationId,menuId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Modifier Groups
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsQueryOptions(accountId,locationId,menuId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new modifier group within a specific menu at a location. Administrators can define the modifier group's details, including its name and associated modifiers. Once created, the modifier group will be part of the menu and available for use in customizing menu items.
 * @summary Create Modifier Group
 */
export const postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups = (
    accountId: string,
    locationId: string,
    menuId: string,
    menuModifierGroupCreateEntity: MenuModifierGroupCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountMenuModifierGroupByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifier-groups`,
      menuModifierGroupCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuModifierGroupCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuModifierGroupCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, {accountId: string;locationId: string;menuId: string;data: MenuModifierGroupCreateEntity}> = (props) => {
          const {accountId,locationId,menuId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups(accountId,locationId,menuId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>>
    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsMutationBody = MenuModifierGroupCreateEntity
    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Modifier Group
 */
export const usePostV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuModifierGroupCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroups>>,
        TError,
        {accountId: string;locationId: string;menuId: string;data: MenuModifierGroupCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for the cancellation of a specific delivery associated with an account. The deliveryId parameter identifies the delivery to be canceled, which will update its status and make it unavailable for further processing.
 * @summary Cancel Delivery
 */
export const postV1AccountsAccountIdDeliveriesDeliveryIdCancel = (
    accountId: string,
    deliveryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/deliveries/${deliveryId}/cancel`,undefined,options
    );
  }



export const getPostV1AccountsAccountIdDeliveriesDeliveryIdCancelMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdCancel>>, TError,{accountId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdCancel>>, TError,{accountId: string;deliveryId: string}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdDeliveriesDeliveryIdCancel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdCancel>>, {accountId: string;deliveryId: string}> = (props) => {
          const {accountId,deliveryId} = props ?? {};

          return  postV1AccountsAccountIdDeliveriesDeliveryIdCancel(accountId,deliveryId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdDeliveriesDeliveryIdCancelMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdCancel>>>
    
    export type PostV1AccountsAccountIdDeliveriesDeliveryIdCancelMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Cancel Delivery
 */
export const usePostV1AccountsAccountIdDeliveriesDeliveryIdCancel = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdCancel>>, TError,{accountId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdCancel>>,
        TError,
        {accountId: string;deliveryId: string},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdDeliveriesDeliveryIdCancelMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific location associated with a reseller, identified by the locationId parameter. It returns comprehensive data about the location, such as its address, status, and operational details. This is useful for viewing or managing a specific location's details.
 * @summary Get Location
 */
export const getV1ResellersResellerIdLocationsLocationId = (
    resellerId: string,
    locationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetLocationByIdResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/locations/${locationId}`,options
    );
  }


export const getGetV1ResellersResellerIdLocationsLocationIdQueryKey = (resellerId: string,
    locationId: string,) => {
    return [`/v1/resellers/${resellerId}/locations/${locationId}`] as const;
    }

    
export const getGetV1ResellersResellerIdLocationsLocationIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdLocationsLocationIdQueryKey(resellerId,locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>> = ({ signal }) => getV1ResellersResellerIdLocationsLocationId(resellerId,locationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdLocationsLocationIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>>
export type GetV1ResellersResellerIdLocationsLocationIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdLocationsLocationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    locationId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdLocationsLocationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdLocationsLocationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Location
 */

export function useGetV1ResellersResellerIdLocationsLocationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdLocationsLocationIdInfiniteQueryOptions(resellerId,locationId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdLocationsLocationIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdLocationsLocationIdQueryKey(resellerId,locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>> = ({ signal }) => getV1ResellersResellerIdLocationsLocationId(resellerId,locationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdLocationsLocationIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>>
export type GetV1ResellersResellerIdLocationsLocationIdQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdLocationsLocationId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    locationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdLocationsLocationId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdLocationsLocationId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Location
 */

export function useGetV1ResellersResellerIdLocationsLocationId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdLocationsLocationIdQueryOptions(resellerId,locationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific location associated with a reseller. The locationId parameter identifies the location to be deleted. This operation will remove the location from the system, and it will no longer be available for any operations.
 * @summary Delete Location
 */
export const deleteV1ResellersResellerIdLocationsLocationId = (
    resellerId: string,
    locationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/resellers/${resellerId}/locations/${locationId}`,options
    );
  }



export const getDeleteV1ResellersResellerIdLocationsLocationIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1ResellersResellerIdLocationsLocationId>>, TError,{resellerId: string;locationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1ResellersResellerIdLocationsLocationId>>, TError,{resellerId: string;locationId: string}, TContext> => {
    
const mutationKey = ['deleteV1ResellersResellerIdLocationsLocationId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1ResellersResellerIdLocationsLocationId>>, {resellerId: string;locationId: string}> = (props) => {
          const {resellerId,locationId} = props ?? {};

          return  deleteV1ResellersResellerIdLocationsLocationId(resellerId,locationId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1ResellersResellerIdLocationsLocationIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1ResellersResellerIdLocationsLocationId>>>
    
    export type DeleteV1ResellersResellerIdLocationsLocationIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Location
 */
export const useDeleteV1ResellersResellerIdLocationsLocationId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1ResellersResellerIdLocationsLocationId>>, TError,{resellerId: string;locationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1ResellersResellerIdLocationsLocationId>>,
        TError,
        {resellerId: string;locationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1ResellersResellerIdLocationsLocationIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the information of a specific location under a reseller, identified by the locationId parameter. Administrators can modify various aspects of the location, such as its address, hours of operation, or other relevant details.
 * @summary Update Location
 */
export const patchV1ResellersResellerIdLocationsLocationId = (
    resellerId: string,
    locationId: string,
    resellerLocationPatchEntity: ResellerLocationPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetLocationByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/resellers/${resellerId}/locations/${locationId}`,
      resellerLocationPatchEntity,options
    );
  }



export const getPatchV1ResellersResellerIdLocationsLocationIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerIdLocationsLocationId>>, TError,{resellerId: string;locationId: string;data: ResellerLocationPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerIdLocationsLocationId>>, TError,{resellerId: string;locationId: string;data: ResellerLocationPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1ResellersResellerIdLocationsLocationId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1ResellersResellerIdLocationsLocationId>>, {resellerId: string;locationId: string;data: ResellerLocationPatchEntity}> = (props) => {
          const {resellerId,locationId,data} = props ?? {};

          return  patchV1ResellersResellerIdLocationsLocationId(resellerId,locationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1ResellersResellerIdLocationsLocationIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1ResellersResellerIdLocationsLocationId>>>
    export type PatchV1ResellersResellerIdLocationsLocationIdMutationBody = ResellerLocationPatchEntity
    export type PatchV1ResellersResellerIdLocationsLocationIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Location
 */
export const usePatchV1ResellersResellerIdLocationsLocationId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerIdLocationsLocationId>>, TError,{resellerId: string;locationId: string;data: ResellerLocationPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1ResellersResellerIdLocationsLocationId>>,
        TError,
        {resellerId: string;locationId: string;data: ResellerLocationPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1ResellersResellerIdLocationsLocationIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific modifier within a menu at a location, identified by the modifierId parameter. It provides comprehensive data about the modifier, including its description, pricing, and availability, allowing for effective management and updates.
 * @summary Get Modifier
 */
export const getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId = (
    accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountMenuModifierByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifiers/${modifierId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdQueryKey = (accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifiers/${modifierId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdQueryKey(accountId,locationId,menuId,modifierId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId(accountId,locationId,menuId,modifierId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId && modifierId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Modifier
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdInfiniteQueryOptions(accountId,locationId,menuId,modifierId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdQueryKey(accountId,locationId,menuId,modifierId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId(accountId,locationId,menuId,modifierId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId && modifierId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Modifier
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdQueryOptions(accountId,locationId,menuId,modifierId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific modifier within a menu at a location. The modifierId parameter identifies the modifier to be deleted, which will remove it from the system and disassociate it from the menu.
 * @summary Delete Modifier
 */
export const deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId = (
    accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifiers/${modifierId}`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError,{accountId: string;locationId: string;menuId: string;modifierId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError,{accountId: string;locationId: string;menuId: string;modifierId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, {accountId: string;locationId: string;menuId: string;modifierId: string}> = (props) => {
          const {accountId,locationId,menuId,modifierId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId(accountId,locationId,menuId,modifierId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Modifier
 */
export const useDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError,{accountId: string;locationId: string;menuId: string;modifierId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>,
        TError,
        {accountId: string;locationId: string;menuId: string;modifierId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the information of a specific modifier within a menu at a location. Users can modify various aspects of the modifier, such as its description, pricing, or availability, ensuring that the modifier remains current and aligned with the menu's offerings.
 * @summary Update Modifier
 */
export const patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId = (
    accountId: string,
    locationId: string,
    menuId: string,
    modifierId: string,
    menuModifierPatchEntity: MenuModifierPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountMenuModifierByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifiers/${modifierId}`,
      menuModifierPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError,{accountId: string;locationId: string;menuId: string;modifierId: string;data: MenuModifierPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError,{accountId: string;locationId: string;menuId: string;modifierId: string;data: MenuModifierPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, {accountId: string;locationId: string;menuId: string;modifierId: string;data: MenuModifierPatchEntity}> = (props) => {
          const {accountId,locationId,menuId,modifierId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId(accountId,locationId,menuId,modifierId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdMutationBody = MenuModifierPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Modifier
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>, TError,{accountId: string;locationId: string;menuId: string;modifierId: string;data: MenuModifierPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierId>>,
        TError,
        {accountId: string;locationId: string;menuId: string;modifierId: string;data: MenuModifierPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifiersModifierIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific account identified by the accountId parameter. It provides comprehensive data about the account, including its contact details, status, and associated resources, making it useful for managing individual accounts.
 * @summary Get Account
 */
export const getV1AccountsAccountId = (
    accountId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}`,options
    );
  }


export const getGetV1AccountsAccountIdQueryKey = (accountId: string,) => {
    return [`/v1/accounts/${accountId}`] as const;
    }

    
export const getGetV1AccountsAccountIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountId>>>, TError = AxiosError<ErrorResponse>>(accountId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdQueryKey(accountId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountId>>> = ({ signal }) => getV1AccountsAccountId(accountId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountId>>>
export type GetV1AccountsAccountIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Account
 */

export function useGetV1AccountsAccountIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdInfiniteQueryOptions(accountId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError = AxiosError<ErrorResponse>>(accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdQueryKey(accountId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountId>>> = ({ signal }) => getV1AccountsAccountId(accountId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountId>>>
export type GetV1AccountsAccountIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountId<TData = Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountId<TData = Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountId<TData = Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Account
 */

export function useGetV1AccountsAccountId<TData = Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdQueryOptions(accountId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for updating the information of a specific account in the system. the owner can modify various aspects of the account, such as its contact information, status, or other relevant details, ensuring that the account's information remains current and accurate.
 * @summary Update Account
 */
export const patchV1AccountsAccountId = (
    accountId: string,
    accountPatchEntity: AccountPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}`,
      accountPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountId>>, TError,{accountId: string;data: AccountPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountId>>, TError,{accountId: string;data: AccountPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountId>>, {accountId: string;data: AccountPatchEntity}> = (props) => {
          const {accountId,data} = props ?? {};

          return  patchV1AccountsAccountId(accountId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountId>>>
    export type PatchV1AccountsAccountIdMutationBody = AccountPatchEntity
    export type PatchV1AccountsAccountIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Account
 */
export const usePatchV1AccountsAccountId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountId>>, TError,{accountId: string;data: AccountPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountId>>,
        TError,
        {accountId: string;data: AccountPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves audit logs for a specific order associated with an account. The logs provide detailed records of actions and changes made to the order, allowing users to review and analyze activity for compliance and security purposes.
 * @summary Get Audits
 */
export const getV1AccountsAccountIdOrdersOrderIdAudits = (
    accountId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdOrdersOrderIdAuditsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAuditsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/orders/${orderId}/audits`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdOrdersOrderIdAuditsQueryKey = (accountId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdOrdersOrderIdAuditsParams,) => {
    return [`/v1/accounts/${accountId}/orders/${orderId}/audits`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdOrdersOrderIdAuditsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, GetV1AccountsAccountIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdOrdersOrderIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdOrdersOrderIdAuditsQueryKey(accountId,orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdOrdersOrderIdAuditsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdOrdersOrderIdAudits(accountId,orderId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && orderId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdOrdersOrderIdAuditsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdOrdersOrderIdAuditsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>>
export type GetV1AccountsAccountIdOrdersOrderIdAuditsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdOrdersOrderIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, GetV1AccountsAccountIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string,
    params: undefined |  GetV1AccountsAccountIdOrdersOrderIdAuditsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdOrdersOrderIdAuditsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdOrdersOrderIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, GetV1AccountsAccountIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdOrdersOrderIdAuditsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdOrdersOrderIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, GetV1AccountsAccountIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdOrdersOrderIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Audits
 */

export function useGetV1AccountsAccountIdOrdersOrderIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, GetV1AccountsAccountIdOrdersOrderIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, QueryKey, GetV1AccountsAccountIdOrdersOrderIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdOrdersOrderIdAuditsInfiniteQueryOptions(accountId,orderId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdOrdersOrderIdAuditsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdOrdersOrderIdAuditsQueryKey(accountId,orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>> = ({ signal }) => getV1AccountsAccountIdOrdersOrderIdAudits(accountId,orderId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && orderId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdOrdersOrderIdAuditsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>>
export type GetV1AccountsAccountIdOrdersOrderIdAuditsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdOrdersOrderIdAudits<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string,
    params: undefined |  GetV1AccountsAccountIdOrdersOrderIdAuditsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdOrdersOrderIdAudits<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdOrdersOrderIdAudits<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Audits
 */

export function useGetV1AccountsAccountIdOrdersOrderIdAudits<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdOrdersOrderIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdOrdersOrderIdAuditsQueryOptions(accountId,orderId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves a list of all modifiers within a catalog associated with a specific location under an account. The data includes modifier identifiers, names, and other relevant details, providing an overview of the modifiers available in the catalog. This information is essential for managing the catalog's customization options and enhancing the customer experience.
 * @summary Get Catalog Modifiers
 */
export const getV1AccountsAccountIdLocationsLocationIdCatalogModifiers = (
    accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListCatalogModifiersResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/modifiers`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersQueryKey = (accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/catalog/modifiers`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdCatalogModifiers(accountId,locationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Modifiers
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersInfiniteQueryOptions(accountId,locationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogModifiers(accountId,locationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiers<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiers<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiers<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Modifiers
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiers<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersQueryOptions(accountId,locationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new modifier within a catalog at a specific location. Users can define the modifier's details, including its name, description, and pricing. Once created, the modifier will be available for use in customizing products within the catalog, enhancing the catalog's offerings and customer satisfaction.
 * @summary Create Catalog Modifier
 */
export const postV1AccountsAccountIdLocationsLocationIdCatalogModifiers = (
    accountId: string,
    locationId: string,
    catalogModifierCreateEntity: CatalogModifierCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountCatalogModifierByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/modifiers`,
      catalogModifierCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdCatalogModifiersMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError,{accountId: string;locationId: string;data: CatalogModifierCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError,{accountId: string;locationId: string;data: CatalogModifierCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdCatalogModifiers'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, {accountId: string;locationId: string;data: CatalogModifierCreateEntity}> = (props) => {
          const {accountId,locationId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdCatalogModifiers(accountId,locationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdCatalogModifiersMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>>
    export type PostV1AccountsAccountIdLocationsLocationIdCatalogModifiersMutationBody = CatalogModifierCreateEntity
    export type PostV1AccountsAccountIdLocationsLocationIdCatalogModifiersMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Catalog Modifier
 */
export const usePostV1AccountsAccountIdLocationsLocationIdCatalogModifiers = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>, TError,{accountId: string;locationId: string;data: CatalogModifierCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogModifiers>>,
        TError,
        {accountId: string;locationId: string;data: CatalogModifierCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdCatalogModifiersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific location under an account, identified by the locationId parameter. The response includes comprehensive data such as the location's name, address, and operational status, allowing administrators to manage the location effectively.
 * @summary Get Location
 */
export const getV1ResellersResellerIdAccountsAccountIdLocationsLocationId = (
    resellerId: string,
    accountId: string,
    locationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetLocationByIdResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/accounts/${accountId}/locations/${locationId}`,options
    );
  }


export const getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdQueryKey = (resellerId: string,
    accountId: string,
    locationId: string,) => {
    return [`/v1/resellers/${resellerId}/accounts/${accountId}/locations/${locationId}`] as const;
    }

    
export const getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdQueryKey(resellerId,accountId,locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>> = ({ signal }) => getV1ResellersResellerIdAccountsAccountIdLocationsLocationId(resellerId,accountId,locationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>>
export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Location
 */

export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdInfiniteQueryOptions(resellerId,accountId,locationId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdQueryKey(resellerId,accountId,locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>> = ({ signal }) => getV1ResellersResellerIdAccountsAccountIdLocationsLocationId(resellerId,accountId,locationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>>
export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Location
 */

export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdQueryOptions(resellerId,accountId,locationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific location under an account. The locationId parameter identifies the location to be deleted, which will remove it from the system and disassociate it from the account.
 * @summary Delete Location
 */
export const deleteV1ResellersResellerIdAccountsAccountIdLocationsLocationId = (
    resellerId: string,
    accountId: string,
    locationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/resellers/${resellerId}/accounts/${accountId}/locations/${locationId}`,options
    );
  }



export const getDeleteV1ResellersResellerIdAccountsAccountIdLocationsLocationIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError,{resellerId: string;accountId: string;locationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError,{resellerId: string;accountId: string;locationId: string}, TContext> => {
    
const mutationKey = ['deleteV1ResellersResellerIdAccountsAccountIdLocationsLocationId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, {resellerId: string;accountId: string;locationId: string}> = (props) => {
          const {resellerId,accountId,locationId} = props ?? {};

          return  deleteV1ResellersResellerIdAccountsAccountIdLocationsLocationId(resellerId,accountId,locationId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1ResellersResellerIdAccountsAccountIdLocationsLocationIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>>
    
    export type DeleteV1ResellersResellerIdAccountsAccountIdLocationsLocationIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Location
 */
export const useDeleteV1ResellersResellerIdAccountsAccountIdLocationsLocationId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError,{resellerId: string;accountId: string;locationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>,
        TError,
        {resellerId: string;accountId: string;locationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1ResellersResellerIdAccountsAccountIdLocationsLocationIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the information of a specific location under an account associated with a reseller. Administrators can modify details such as the location's address, hours of operation, or other attributes to keep the information current and accurate.
 * @summary Update Location
 */
export const patchV1ResellersResellerIdAccountsAccountIdLocationsLocationId = (
    resellerId: string,
    accountId: string,
    locationId: string,
    locationPatchEntity: LocationPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetLocationByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/resellers/${resellerId}/accounts/${accountId}/locations/${locationId}`,
      locationPatchEntity,options
    );
  }



export const getPatchV1ResellersResellerIdAccountsAccountIdLocationsLocationIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError,{resellerId: string;accountId: string;locationId: string;data: LocationPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError,{resellerId: string;accountId: string;locationId: string;data: LocationPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1ResellersResellerIdAccountsAccountIdLocationsLocationId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, {resellerId: string;accountId: string;locationId: string;data: LocationPatchEntity}> = (props) => {
          const {resellerId,accountId,locationId,data} = props ?? {};

          return  patchV1ResellersResellerIdAccountsAccountIdLocationsLocationId(resellerId,accountId,locationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1ResellersResellerIdAccountsAccountIdLocationsLocationIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>>
    export type PatchV1ResellersResellerIdAccountsAccountIdLocationsLocationIdMutationBody = LocationPatchEntity
    export type PatchV1ResellersResellerIdAccountsAccountIdLocationsLocationIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Location
 */
export const usePatchV1ResellersResellerIdAccountsAccountIdLocationsLocationId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>, TError,{resellerId: string;accountId: string;locationId: string;data: LocationPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1ResellersResellerIdAccountsAccountIdLocationsLocationId>>,
        TError,
        {resellerId: string;accountId: string;locationId: string;data: LocationPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1ResellersResellerIdAccountsAccountIdLocationsLocationIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all categories associated with a specific menu at a location. The data includes category identifiers, names, and other relevant details, providing an overview of the categories available within the menu at the specified location.
 * @summary List Categories
 */
export const getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories = (
    accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountMenuCategoriesResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/categories`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesQueryKey = (accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/categories`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesQueryKey(accountId,locationId,menuId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories(accountId,locationId,menuId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Categories
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesInfiniteQueryOptions(accountId,locationId,menuId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesQueryKey(accountId,locationId,menuId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories(accountId,locationId,menuId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Categories
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesQueryOptions(accountId,locationId,menuId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new category within a specific menu associated with a location. Administrators can define the category's details, including its name and associated items. Once created, the category will be part of the menu and available to customers.
 * @summary Create Category
 */
export const postV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories = (
    accountId: string,
    locationId: string,
    menuId: string,
    menuCategoryCreateEntity: MenuCategoryCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountMenuCategoryByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/categories`,
      menuCategoryCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuCategoryCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuCategoryCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, {accountId: string;locationId: string;menuId: string;data: MenuCategoryCreateEntity}> = (props) => {
          const {accountId,locationId,menuId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories(accountId,locationId,menuId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>>
    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesMutationBody = MenuCategoryCreateEntity
    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Category
 */
export const usePostV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuCategoryCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategories>>,
        TError,
        {accountId: string;locationId: string;menuId: string;data: MenuCategoryCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all variants associated with a specific item in a menu at a location. The data includes variant identifiers, names, and other relevant details, providing an overview of the variants available for the item within the specified menu.
 * @summary List Variants
 */
export const getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants = (
    accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountMenuItemVariantsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/items/${itemId}/variants`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsQueryKey = (accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/items/${itemId}/variants`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsQueryKey(accountId,locationId,menuId,itemId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants(accountId,locationId,menuId,itemId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId && itemId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Variants
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsInfiniteQueryOptions(accountId,locationId,menuId,itemId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsQueryKey(accountId,locationId,menuId,itemId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants(accountId,locationId,menuId,itemId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId && itemId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Variants
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariants>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdVariantsQueryOptions(accountId,locationId,menuId,itemId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves detailed information about a specific modifier group within a menu at a location, identified by the modifierGroupId parameter. It provides comprehensive data about the modifier group, including its modifiers and status, allowing for effective management and updates.
 * @summary Get Modifier Group
 */
export const getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId = (
    accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountMenuModifierGroupByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifier-groups/${modifierGroupId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdQueryKey = (accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifier-groups/${modifierGroupId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdQueryKey(accountId,locationId,menuId,modifierGroupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId(accountId,locationId,menuId,modifierGroupId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId && modifierGroupId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Modifier Group
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdInfiniteQueryOptions(accountId,locationId,menuId,modifierGroupId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdQueryKey(accountId,locationId,menuId,modifierGroupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId(accountId,locationId,menuId,modifierGroupId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId && modifierGroupId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Modifier Group
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdQueryOptions(accountId,locationId,menuId,modifierGroupId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific modifier group within a menu at a location. The modifierGroupId parameter identifies the group to be deleted, which will remove it from the system and disassociate it from the menu.
 * @summary Delete Modifier Group
 */
export const deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId = (
    accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifier-groups/${modifierGroupId}`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError,{accountId: string;locationId: string;menuId: string;modifierGroupId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError,{accountId: string;locationId: string;menuId: string;modifierGroupId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, {accountId: string;locationId: string;menuId: string;modifierGroupId: string}> = (props) => {
          const {accountId,locationId,menuId,modifierGroupId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId(accountId,locationId,menuId,modifierGroupId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Modifier Group
 */
export const useDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError,{accountId: string;locationId: string;menuId: string;modifierGroupId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>,
        TError,
        {accountId: string;locationId: string;menuId: string;modifierGroupId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the information of a specific modifier group within a menu at a location. Administrators can modify various aspects of the modifier group, such as its name, modifiers, or availability, ensuring that the group remains current and aligned with the menu's offerings.
 * @summary Update Modifier Group
 */
export const patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId = (
    accountId: string,
    locationId: string,
    menuId: string,
    modifierGroupId: string,
    menuModifierGroupPatchEntity: MenuModifierGroupPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountMenuModifierGroupByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/modifier-groups/${modifierGroupId}`,
      menuModifierGroupPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError,{accountId: string;locationId: string;menuId: string;modifierGroupId: string;data: MenuModifierGroupPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError,{accountId: string;locationId: string;menuId: string;modifierGroupId: string;data: MenuModifierGroupPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, {accountId: string;locationId: string;menuId: string;modifierGroupId: string;data: MenuModifierGroupPatchEntity}> = (props) => {
          const {accountId,locationId,menuId,modifierGroupId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId(accountId,locationId,menuId,modifierGroupId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdMutationBody = MenuModifierGroupPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Modifier Group
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>, TError,{accountId: string;locationId: string;menuId: string;modifierGroupId: string;data: MenuModifierGroupPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupId>>,
        TError,
        {accountId: string;locationId: string;menuId: string;modifierGroupId: string;data: MenuModifierGroupPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdModifierGroupsModifierGroupIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for the dispatch of a specific delivery to begin the delivery process. The deliveryId parameter identifies the delivery to be dispatched, and this operation will update its status and initiate the delivery process.
 * @summary Dispatch Delivery
 */
export const postV1AccountsAccountIdDeliveriesDeliveryIdDispatch = (
    accountId: string,
    deliveryId: string,
    deliveryEntity: DeliveryEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/deliveries/${deliveryId}/dispatch`,
      deliveryEntity,options
    );
  }



export const getPostV1AccountsAccountIdDeliveriesDeliveryIdDispatchMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdDispatch>>, TError,{accountId: string;deliveryId: string;data: DeliveryEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdDispatch>>, TError,{accountId: string;deliveryId: string;data: DeliveryEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdDeliveriesDeliveryIdDispatch'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdDispatch>>, {accountId: string;deliveryId: string;data: DeliveryEntity}> = (props) => {
          const {accountId,deliveryId,data} = props ?? {};

          return  postV1AccountsAccountIdDeliveriesDeliveryIdDispatch(accountId,deliveryId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdDeliveriesDeliveryIdDispatchMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdDispatch>>>
    export type PostV1AccountsAccountIdDeliveriesDeliveryIdDispatchMutationBody = DeliveryEntity
    export type PostV1AccountsAccountIdDeliveriesDeliveryIdDispatchMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Dispatch Delivery
 */
export const usePostV1AccountsAccountIdDeliveriesDeliveryIdDispatch = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdDispatch>>, TError,{accountId: string;deliveryId: string;data: DeliveryEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdDispatch>>,
        TError,
        {accountId: string;deliveryId: string;data: DeliveryEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdDeliveriesDeliveryIdDispatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for rearranging the items, categories, modifiers and modifier groups within a specific menu associated with a location. Administrators can define the new order of items, categories, modifiers and modifier groups ensuring that the menu is structured and displayed according to their preferences.
 * @summary Rearrange Menu Items, Categories, Modifiers, and Modifier Groups
 */
export const patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrange = (
    accountId: string,
    locationId: string,
    menuId: string,
    menuRearrangeRequest: MenuRearrangeRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/rearrange`,
      menuRearrangeRequest,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrangeMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrange>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuRearrangeRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrange>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuRearrangeRequest}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrange'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrange>>, {accountId: string;locationId: string;menuId: string;data: MenuRearrangeRequest}> = (props) => {
          const {accountId,locationId,menuId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrange(accountId,locationId,menuId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrangeMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrange>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrangeMutationBody = MenuRearrangeRequest
    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrangeMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Rearrange Menu Items, Categories, Modifiers, and Modifier Groups
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrange = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrange>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuRearrangeRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrange>>,
        TError,
        {accountId: string;locationId: string;menuId: string;data: MenuRearrangeRequest},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdRearrangeMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific order associated with a reseller, identified by the orderId parameter. It returns comprehensive data about the order, including items, pricing, and status. This is useful for viewing or managing specific order details within a reseller's purview.
 * @summary Get Reseller Order
 */
export const getV1ResellersResellerIdOrdersOrderId = (
    resellerId: string,
    orderId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetOrderByIdResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/orders/${orderId}`,options
    );
  }


export const getGetV1ResellersResellerIdOrdersOrderIdQueryKey = (resellerId: string,
    orderId: string,) => {
    return [`/v1/resellers/${resellerId}/orders/${orderId}`] as const;
    }

    
export const getGetV1ResellersResellerIdOrdersOrderIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdOrdersOrderIdQueryKey(resellerId,orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>> = ({ signal }) => getV1ResellersResellerIdOrdersOrderId(resellerId,orderId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && orderId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdOrdersOrderIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>>
export type GetV1ResellersResellerIdOrdersOrderIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdOrdersOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Reseller Order
 */

export function useGetV1ResellersResellerIdOrdersOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdOrdersOrderIdInfiniteQueryOptions(resellerId,orderId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdOrdersOrderIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdOrdersOrderIdQueryKey(resellerId,orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>> = ({ signal }) => getV1ResellersResellerIdOrdersOrderId(resellerId,orderId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && orderId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdOrdersOrderIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>>
export type GetV1ResellersResellerIdOrdersOrderIdQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdOrdersOrderId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Reseller Order
 */

export function useGetV1ResellersResellerIdOrdersOrderId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdOrdersOrderIdQueryOptions(resellerId,orderId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves detailed information about a specific delivery associated with an order under a reseller, identified by the deliveryId parameter. It returns comprehensive data about the delivery, including pickup time, status, and other relevant details.
 * @summary Get Order Delivery
 */
export const getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId = (
    resellerId: string,
    orderId: string,
    deliveryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/orders/${orderId}/deliveries/${deliveryId}`,options
    );
  }


export const getGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdQueryKey = (resellerId: string,
    orderId: string,
    deliveryId: string,) => {
    return [`/v1/resellers/${resellerId}/orders/${orderId}/deliveries/${deliveryId}`] as const;
    }

    
export const getGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdQueryKey(resellerId,orderId,deliveryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>> = ({ signal }) => getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId(resellerId,orderId,deliveryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && orderId && deliveryId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>>
export type GetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    deliveryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Order Delivery
 */

export function useGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdInfiniteQueryOptions(resellerId,orderId,deliveryId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdQueryKey(resellerId,orderId,deliveryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>> = ({ signal }) => getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId(resellerId,orderId,deliveryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && orderId && deliveryId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>>
export type GetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    deliveryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Order Delivery
 */

export function useGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    orderId: string,
    deliveryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdQueryOptions(resellerId,orderId,deliveryId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for uploading an image for a specific item within a menu at a location. The image can be used to enhance the visual appeal of the menu item, making it more attractive to customers. Administrators can manage this resource to ensure it meets the platform's standards.
 * @summary Upload Image
 */
export const postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage = (
    accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    signedUrlRequest: SignedUrlRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SignedUrlResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/items/${itemId}/image`,
      signedUrlRequest,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImageMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage>>, TError,{accountId: string;locationId: string;menuId: string;itemId: string;data: SignedUrlRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage>>, TError,{accountId: string;locationId: string;menuId: string;itemId: string;data: SignedUrlRequest}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage>>, {accountId: string;locationId: string;menuId: string;itemId: string;data: SignedUrlRequest}> = (props) => {
          const {accountId,locationId,menuId,itemId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage(accountId,locationId,menuId,itemId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImageMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage>>>
    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImageMutationBody = SignedUrlRequest
    export type PostV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImageMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Upload Image
 */
export const usePostV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage>>, TError,{accountId: string;locationId: string;menuId: string;itemId: string;data: SignedUrlRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage>>,
        TError,
        {accountId: string;locationId: string;menuId: string;itemId: string;data: SignedUrlRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for the deletion of an image associated with a specific item within a menu at a location. Once deleted, the image will no longer be displayed for the menu item, and administrators will need to upload a new image if necessary.
 * @summary Delete Image
 */
export const deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage = (
    accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/items/${itemId}/image`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImageMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage>>, TError,{accountId: string;locationId: string;menuId: string;itemId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage>>, TError,{accountId: string;locationId: string;menuId: string;itemId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage>>, {accountId: string;locationId: string;menuId: string;itemId: string}> = (props) => {
          const {accountId,locationId,menuId,itemId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage(accountId,locationId,menuId,itemId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImageMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Image
 */
export const useDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage>>, TError,{accountId: string;locationId: string;menuId: string;itemId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImage>>,
        TError,
        {accountId: string;locationId: string;menuId: string;itemId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all modifier groups within a catalog associated with a specific location under an account. The data includes modifier group identifiers, names, and other relevant details, providing an overview of the modifier groups available in the catalog. This information is essential for managing the catalog's customization options and enhancing the customer experience.
 * @summary Get Modifier Groups
 */
export const getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups = (
    accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountCatalogModifierGroupsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/modifier-groups`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsQueryKey = (accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/catalog/modifier-groups`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups(accountId,locationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Modifier Groups
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsInfiniteQueryOptions(accountId,locationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups(accountId,locationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Modifier Groups
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsQueryOptions(accountId,locationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new modifier group within a catalog at a specific location. Users can define the modifier group's details, including its name and associated modifiers. Once created, the modifier group will be available for use in organizing and managing modifiers within the catalog, enhancing the catalog's structure and offerings.
 * @summary Create Modifier Group
 */
export const postV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups = (
    accountId: string,
    locationId: string,
    catalogModifierGroupCreateEntity: CatalogModifierGroupCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountCatalogModifierGroupByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/modifier-groups`,
      catalogModifierGroupCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError,{accountId: string;locationId: string;data: CatalogModifierGroupCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError,{accountId: string;locationId: string;data: CatalogModifierGroupCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, {accountId: string;locationId: string;data: CatalogModifierGroupCreateEntity}> = (props) => {
          const {accountId,locationId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups(accountId,locationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>>
    export type PostV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsMutationBody = CatalogModifierGroupCreateEntity
    export type PostV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Modifier Group
 */
export const usePostV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>, TError,{accountId: string;locationId: string;data: CatalogModifierGroupCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogModifierGroups>>,
        TError,
        {accountId: string;locationId: string;data: CatalogModifierGroupCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdCatalogModifierGroupsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all locations associated with a specific account. The data returned includes location identifiers, names, and other relevant details, providing a comprehensive overview of the locations that the account manages or monitors.
 * @summary List Locations
 */
export const getV1AccountsAccountIdLocations = (
    accountId: string,
    params?: GetV1AccountsAccountIdLocationsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListLocationsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsQueryKey = (accountId: string,
    params?: GetV1AccountsAccountIdLocationsParams,) => {
    return [`/v1/accounts/${accountId}/locations`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, GetV1AccountsAccountIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    params?: GetV1AccountsAccountIdLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, QueryKey, GetV1AccountsAccountIdLocationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsQueryKey(accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, QueryKey, GetV1AccountsAccountIdLocationsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocations(accountId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, QueryKey, GetV1AccountsAccountIdLocationsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>>
export type GetV1AccountsAccountIdLocationsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, GetV1AccountsAccountIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, QueryKey, GetV1AccountsAccountIdLocationsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, GetV1AccountsAccountIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, QueryKey, GetV1AccountsAccountIdLocationsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, GetV1AccountsAccountIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, QueryKey, GetV1AccountsAccountIdLocationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Locations
 */

export function useGetV1AccountsAccountIdLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, GetV1AccountsAccountIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, QueryKey, GetV1AccountsAccountIdLocationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsInfiniteQueryOptions(accountId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    params?: GetV1AccountsAccountIdLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsQueryKey(accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>> = ({ signal }) => getV1AccountsAccountIdLocations(accountId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>>
export type GetV1AccountsAccountIdLocationsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocations<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocations<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocations<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Locations
 */

export function useGetV1AccountsAccountIdLocations<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsQueryOptions(accountId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new location under a specific account. Administrators can define the location's details, such as its name, address, and operational hours. Once created, the location will be linked to the account and managed accordingly within the platform.
 * @summary Create Location
 */
export const postV1AccountsAccountIdLocations = (
    accountId: string,
    locationCreateEntity: LocationCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetLocationByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations`,
      locationCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdLocationsMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocations>>, TError,{accountId: string;data: LocationCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocations>>, TError,{accountId: string;data: LocationCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocations'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocations>>, {accountId: string;data: LocationCreateEntity}> = (props) => {
          const {accountId,data} = props ?? {};

          return  postV1AccountsAccountIdLocations(accountId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocations>>>
    export type PostV1AccountsAccountIdLocationsMutationBody = LocationCreateEntity
    export type PostV1AccountsAccountIdLocationsMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Location
 */
export const usePostV1AccountsAccountIdLocations = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocations>>, TError,{accountId: string;data: LocationCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocations>>,
        TError,
        {accountId: string;data: LocationCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows users to export the entire catalog associated with a specific location under an account. The export includes all categories, products, modifiers, and other relevant details, providing a comprehensive dataset that can be used for backup, analysis, or migration purposes.
 * @summary Export Catalog
 */
export const getV1AccountsAccountIdLocationsLocationIdCatalogExport = (
    accountId: string,
    locationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountCatalogExportResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/export`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdCatalogExportQueryKey = (accountId: string,
    locationId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/catalog/export`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdCatalogExportInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogExportQueryKey(accountId,locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogExport(accountId,locationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogExportInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogExportInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogExportInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogExportInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogExportInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Export Catalog
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogExportInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogExportInfiniteQueryOptions(accountId,locationId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdCatalogExportQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogExportQueryKey(accountId,locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogExport(accountId,locationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogExportQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogExportQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogExport<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogExport<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogExport<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Export Catalog
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogExport<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogExport>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogExportQueryOptions(accountId,locationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the dispatch of a specific delivery associated with an order under a reseller. The deliveryId parameter identifies the delivery to be dispatched. This operation will update the delivery status and initiate the delivery process.
 * @summary Dispatch Order Delivery
 */
export const postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatch = (
    resellerId: string,
    orderId: string,
    deliveryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.post(
      `/v1/resellers/${resellerId}/orders/${orderId}/deliveries/${deliveryId}/dispatch`,undefined,options
    );
  }



export const getPostV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatchMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatch>>, TError,{resellerId: string;orderId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatch>>, TError,{resellerId: string;orderId: string;deliveryId: string}, TContext> => {
    
const mutationKey = ['postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatch'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatch>>, {resellerId: string;orderId: string;deliveryId: string}> = (props) => {
          const {resellerId,orderId,deliveryId} = props ?? {};

          return  postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatch(resellerId,orderId,deliveryId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatchMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatch>>>
    
    export type PostV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatchMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Dispatch Order Delivery
 */
export const usePostV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatch = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatch>>, TError,{resellerId: string;orderId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatch>>,
        TError,
        {resellerId: string;orderId: string;deliveryId: string},
        TContext
      > => {

      const mutationOptions = getPostV1ResellersResellerIdOrdersOrderIdDeliveriesDeliveryIdDispatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific connection associated with a location, identified by the connectionId parameter. It provides comprehensive data about the connection, including its configuration, status, and associated services, allowing for effective management and troubleshooting.
 * @summary Get Location Connection Details
 */
export const getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId = (
    accountId: string,
    locationId: string,
    connectionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetConnectionByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/connections/${connectionId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdQueryKey = (accountId: string,
    locationId: string,
    connectionId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/connections/${connectionId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    connectionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdQueryKey(accountId,locationId,connectionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId(accountId,locationId,connectionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && connectionId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>>
export type GetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    connectionId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    connectionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    connectionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Location Connection Details
 */

export function useGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    connectionId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdInfiniteQueryOptions(accountId,locationId,connectionId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    connectionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdQueryKey(accountId,locationId,connectionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId(accountId,locationId,connectionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && connectionId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>>
export type GetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    connectionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    connectionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    connectionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Location Connection Details
 */

export function useGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    connectionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdQueryOptions(accountId,locationId,connectionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for updating the information of a specific connection associated with a location. Users can modify the connection's details, such as its configuration, status, or services, ensuring that the connection remains current and aligned with the location's requirements.
 * @summary Update Location Connection
 */
export const patchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId = (
    accountId: string,
    locationId: string,
    connectionId: string,
    connectionPatchEntity: ConnectionPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetConnectionByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/connections/${connectionId}`,
      connectionPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError,{accountId: string;locationId: string;connectionId: string;data: ConnectionPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError,{accountId: string;locationId: string;connectionId: string;data: ConnectionPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, {accountId: string;locationId: string;connectionId: string;data: ConnectionPatchEntity}> = (props) => {
          const {accountId,locationId,connectionId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId(accountId,locationId,connectionId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdMutationBody = ConnectionPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Location Connection
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>, TError,{accountId: string;locationId: string;connectionId: string;data: ConnectionPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionId>>,
        TError,
        {accountId: string;locationId: string;connectionId: string;data: ConnectionPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdConnectionsConnectionIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific category within a catalog at a location, identified by the categoryId parameter. It provides comprehensive data about the category, including its products, description, and status, allowing for effective management and updates.
 * @summary Get Catalog Category
 */
export const getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId = (
    accountId: string,
    locationId: string,
    categoryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountCatalogCategoryByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/categories/${categoryId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdQueryKey = (accountId: string,
    locationId: string,
    categoryId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/catalog/categories/${categoryId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdQueryKey(accountId,locationId,categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId(accountId,locationId,categoryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && categoryId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Category
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdInfiniteQueryOptions(accountId,locationId,categoryId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdQueryKey(accountId,locationId,categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId(accountId,locationId,categoryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && categoryId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Category
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdQueryOptions(accountId,locationId,categoryId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific category within a catalog at a location. The categoryId parameter identifies the category to be deleted, which will remove it from the system and disassociate it from the catalog.
 * @summary Delete Catalog Category
 */
export const deleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId = (
    accountId: string,
    locationId: string,
    categoryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/categories/${categoryId}`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError,{accountId: string;locationId: string;categoryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError,{accountId: string;locationId: string;categoryId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, {accountId: string;locationId: string;categoryId: string}> = (props) => {
          const {accountId,locationId,categoryId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId(accountId,locationId,categoryId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Catalog Category
 */
export const useDeleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError,{accountId: string;locationId: string;categoryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>,
        TError,
        {accountId: string;locationId: string;categoryId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the information of a specific category within a catalog at a location. Users can modify the category's details, such as its name, description, or associated products, ensuring that the category remains current and aligned with the catalog's structure and offerings.
 * @summary Update Catalog Category
 */
export const patchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId = (
    accountId: string,
    locationId: string,
    categoryId: string,
    catalogCategoryPatchEntity: CatalogCategoryPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountCatalogCategoryByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/categories/${categoryId}`,
      catalogCategoryPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError,{accountId: string;locationId: string;categoryId: string;data: CatalogCategoryPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError,{accountId: string;locationId: string;categoryId: string;data: CatalogCategoryPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, {accountId: string;locationId: string;categoryId: string;data: CatalogCategoryPatchEntity}> = (props) => {
          const {accountId,locationId,categoryId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId(accountId,locationId,categoryId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdMutationBody = CatalogCategoryPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Catalog Category
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>, TError,{accountId: string;locationId: string;categoryId: string;data: CatalogCategoryPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryId>>,
        TError,
        {accountId: string;locationId: string;categoryId: string;data: CatalogCategoryPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdCatalogCategoriesCategoryIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows the exchange of an authorization code for an access token as part of the OAuth2 flow. The access token can then be used to authenticate and make authorized API requests on behalf of the user. The endpoint also supports other OAuth2 grant types such as refresh tokens.
 * @summary Token
 */
export const postOauth2Token = (
    tokenRequest: TokenRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TokenResponse>> => {
    
    
    return axios.post(
      `/oauth2/token`,
      tokenRequest,options
    );
  }



export const getPostOauth2TokenMutationOptions = <TError = AxiosError<OAuth2ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOauth2Token>>, TError,{data: TokenRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postOauth2Token>>, TError,{data: TokenRequest}, TContext> => {
    
const mutationKey = ['postOauth2Token'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postOauth2Token>>, {data: TokenRequest}> = (props) => {
          const {data} = props ?? {};

          return  postOauth2Token(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostOauth2TokenMutationResult = NonNullable<Awaited<ReturnType<typeof postOauth2Token>>>
    export type PostOauth2TokenMutationBody = TokenRequest
    export type PostOauth2TokenMutationError = AxiosError<OAuth2ErrorResponse>

    /**
 * @summary Token
 */
export const usePostOauth2Token = <TError = AxiosError<OAuth2ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postOauth2Token>>, TError,{data: TokenRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postOauth2Token>>,
        TError,
        {data: TokenRequest},
        TContext
      > => {

      const mutationOptions = getPostOauth2TokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific item within a menu at a location, identified by the itemId parameter. It provides comprehensive data about the item, including its description, pricing, and availability, allowing for effective management and updates.
 * @summary Get Item
 */
export const getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId = (
    accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountMenuItemByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/items/${itemId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdQueryKey = (accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/items/${itemId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdQueryKey(accountId,locationId,menuId,itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId(accountId,locationId,menuId,itemId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId && itemId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Item
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdInfiniteQueryOptions(accountId,locationId,menuId,itemId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdQueryKey(accountId,locationId,menuId,itemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId(accountId,locationId,menuId,itemId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId && itemId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Item
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdQueryOptions(accountId,locationId,menuId,itemId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific item within a menu at a location. The itemId parameter identifies the item to be deleted, which will remove it from the system and disassociate it from the menu.
 * @summary Delete Item
 */
export const deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId = (
    accountId: string,
    locationId: string,
    menuId: string,
    itemId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/items/${itemId}`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError,{accountId: string;locationId: string;menuId: string;itemId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError,{accountId: string;locationId: string;menuId: string;itemId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, {accountId: string;locationId: string;menuId: string;itemId: string}> = (props) => {
          const {accountId,locationId,menuId,itemId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId(accountId,locationId,menuId,itemId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Item
 */
export const useDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError,{accountId: string;locationId: string;menuId: string;itemId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>,
        TError,
        {accountId: string;locationId: string;menuId: string;itemId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the information of a specific item within a menu at a location. Administrators can modify various aspects of the item, such as its description, pricing, or availability, ensuring that the item remains current and aligned with the menu's offerings.
 * @summary Update Item
 */
export const patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId = (
    accountId: string,
    locationId: string,
    menuId: string,
    itemId: string,
    menuItemPatchEntity: MenuItemPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAccountMenuItemByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/items/${itemId}`,
      menuItemPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError,{accountId: string;locationId: string;menuId: string;itemId: string;data: MenuItemPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError,{accountId: string;locationId: string;menuId: string;itemId: string;data: MenuItemPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, {accountId: string;locationId: string;menuId: string;itemId: string;data: MenuItemPatchEntity}> = (props) => {
          const {accountId,locationId,menuId,itemId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId(accountId,locationId,menuId,itemId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdMutationBody = MenuItemPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Item
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>, TError,{accountId: string;locationId: string;menuId: string;itemId: string;data: MenuItemPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemId>>,
        TError,
        {accountId: string;locationId: string;menuId: string;itemId: string;data: MenuItemPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdItemsItemIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all orders associated with a specific location under an account. The data returned includes order identifiers, statuses, and other relevant details, providing a comprehensive overview of all orders managed by the location. Users can use this information to monitor order processing and fulfillment.
 * @summary List Orders
 */
export const getV1AccountsAccountIdLocationsLocationIdOrders = (
    accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListOrdersResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/orders`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdOrdersQueryKey = (accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/orders`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdOrdersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, GetV1AccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdOrdersQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdOrders(accountId,locationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>>
export type GetV1AccountsAccountIdLocationsLocationIdOrdersInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, GetV1AccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdOrdersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, GetV1AccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, GetV1AccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Orders
 */

export function useGetV1AccountsAccountIdLocationsLocationIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, GetV1AccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdOrdersInfiniteQueryOptions(accountId,locationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdOrdersQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdOrders(accountId,locationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>>
export type GetV1AccountsAccountIdLocationsLocationIdOrdersQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdOrders<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdOrdersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrders<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrders<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Orders
 */

export function useGetV1AccountsAccountIdLocationsLocationIdOrders<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrders>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdOrdersQueryOptions(accountId,locationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new order under a specific location associated with an account. Applications or users can define the order's details, including the items ordered, delivery instructions, and payment information. Once created, the order will be processed and fulfilled according to the location's capabilities.
 * @summary Create Order
 */
export const postV1AccountsAccountIdLocationsLocationIdOrders = (
    accountId: string,
    locationId: string,
    orderCreateEntity: OrderCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetOrderByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/orders`,
      orderCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdOrdersMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdOrders>>, TError,{accountId: string;locationId: string;data: OrderCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdOrders>>, TError,{accountId: string;locationId: string;data: OrderCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdOrders'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdOrders>>, {accountId: string;locationId: string;data: OrderCreateEntity}> = (props) => {
          const {accountId,locationId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdOrders(accountId,locationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdOrdersMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdOrders>>>
    export type PostV1AccountsAccountIdLocationsLocationIdOrdersMutationBody = OrderCreateEntity
    export type PostV1AccountsAccountIdLocationsLocationIdOrdersMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Order
 */
export const usePostV1AccountsAccountIdLocationsLocationIdOrders = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdOrders>>, TError,{accountId: string;locationId: string;data: OrderCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdOrders>>,
        TError,
        {accountId: string;locationId: string;data: OrderCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdOrdersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for uploading an image for a specific product within a catalog at a location. The image can be used to enhance the visual appeal of the product, making it more attractive to customers. Users can manage this resource to ensure it meets the platform's standards and accurately represents the product.
 * @summary Upload Product Image
 */
export const postV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage = (
    accountId: string,
    locationId: string,
    productId: string,
    signedUrlRequest: SignedUrlRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SignedUrlResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/products/${productId}/image`,
      signedUrlRequest,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImageMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage>>, TError,{accountId: string;locationId: string;productId: string;data: SignedUrlRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage>>, TError,{accountId: string;locationId: string;productId: string;data: SignedUrlRequest}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage>>, {accountId: string;locationId: string;productId: string;data: SignedUrlRequest}> = (props) => {
          const {accountId,locationId,productId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage(accountId,locationId,productId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImageMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage>>>
    export type PostV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImageMutationBody = SignedUrlRequest
    export type PostV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImageMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Upload Product Image
 */
export const usePostV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage>>, TError,{accountId: string;locationId: string;productId: string;data: SignedUrlRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage>>,
        TError,
        {accountId: string;locationId: string;productId: string;data: SignedUrlRequest},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for the deletion of an image associated with a specific product within a catalog at a location. Once deleted, the image will no longer be displayed for the product, and Users will need to upload a new image if necessary.
 * @summary Delete Product Image
 */
export const deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage = (
    accountId: string,
    locationId: string,
    productId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/products/${productId}/image`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImageMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage>>, TError,{accountId: string;locationId: string;productId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage>>, TError,{accountId: string;locationId: string;productId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage>>, {accountId: string;locationId: string;productId: string}> = (props) => {
          const {accountId,locationId,productId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage(accountId,locationId,productId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImageMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Product Image
 */
export const useDeleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage>>, TError,{accountId: string;locationId: string;productId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImage>>,
        TError,
        {accountId: string;locationId: string;productId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdImageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all deliveries associated with a specific reseller. The data returned includes delivery identifiers, statuses, and other relevant details, providing a comprehensive overview of all deliveries managed by the reseller.
 * @summary List Deliveries
 */
export const getV1ResellersResellerIdDeliveries = (
    resellerId: string,
    params?: GetV1ResellersResellerIdDeliveriesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListDeliveriesResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/deliveries`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdDeliveriesQueryKey = (resellerId: string,
    params?: GetV1ResellersResellerIdDeliveriesParams,) => {
    return [`/v1/resellers/${resellerId}/deliveries`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdDeliveriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, GetV1ResellersResellerIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, QueryKey, GetV1ResellersResellerIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdDeliveriesQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, QueryKey, GetV1ResellersResellerIdDeliveriesParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdDeliveries(resellerId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, QueryKey, GetV1ResellersResellerIdDeliveriesParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdDeliveriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>>
export type GetV1ResellersResellerIdDeliveriesInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, GetV1ResellersResellerIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdDeliveriesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, QueryKey, GetV1ResellersResellerIdDeliveriesParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, GetV1ResellersResellerIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, QueryKey, GetV1ResellersResellerIdDeliveriesParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, GetV1ResellersResellerIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, QueryKey, GetV1ResellersResellerIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Deliveries
 */

export function useGetV1ResellersResellerIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, GetV1ResellersResellerIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, QueryKey, GetV1ResellersResellerIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdDeliveriesInfiniteQueryOptions(resellerId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdDeliveriesQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdDeliveriesQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>> = ({ signal }) => getV1ResellersResellerIdDeliveries(resellerId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdDeliveriesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>>
export type GetV1ResellersResellerIdDeliveriesQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdDeliveries<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdDeliveriesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdDeliveries<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdDeliveries<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Deliveries
 */

export function useGetV1ResellersResellerIdDeliveries<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdDeliveriesQueryOptions(resellerId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new delivery under a specific reseller. Administrators can define the delivery details, such as the pickup time, status, and other attributes. Once created, the delivery will be associated with the reseller and managed accordingly.
 * @summary Create Delivery
 */
export const postV1ResellersResellerIdDeliveries = (
    resellerId: string,
    resellerDeliveryCreateEntity: ResellerDeliveryCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.post(
      `/v1/resellers/${resellerId}/deliveries`,
      resellerDeliveryCreateEntity,options
    );
  }



export const getPostV1ResellersResellerIdDeliveriesMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveries>>, TError,{resellerId: string;data: ResellerDeliveryCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveries>>, TError,{resellerId: string;data: ResellerDeliveryCreateEntity}, TContext> => {
    
const mutationKey = ['postV1ResellersResellerIdDeliveries'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveries>>, {resellerId: string;data: ResellerDeliveryCreateEntity}> = (props) => {
          const {resellerId,data} = props ?? {};

          return  postV1ResellersResellerIdDeliveries(resellerId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ResellersResellerIdDeliveriesMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveries>>>
    export type PostV1ResellersResellerIdDeliveriesMutationBody = ResellerDeliveryCreateEntity
    export type PostV1ResellersResellerIdDeliveriesMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Delivery
 */
export const usePostV1ResellersResellerIdDeliveries = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveries>>, TError,{resellerId: string;data: ResellerDeliveryCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveries>>,
        TError,
        {resellerId: string;data: ResellerDeliveryCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1ResellersResellerIdDeliveriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific location associated with an account, identified by the locationId parameter. It provides comprehensive data about the location, such as its address, operational status, and any other relevant details needed for management.
 * @summary Get Location
 */
export const getV1AccountsAccountIdLocationsLocationId = (
    accountId: string,
    locationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetLocationByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdQueryKey = (accountId: string,
    locationId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdQueryKey(accountId,locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationId(accountId,locationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>>
export type GetV1AccountsAccountIdLocationsLocationIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Location
 */

export function useGetV1AccountsAccountIdLocationsLocationIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdInfiniteQueryOptions(accountId,locationId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdQueryKey(accountId,locationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationId(accountId,locationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>>
export type GetV1AccountsAccountIdLocationsLocationIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Location
 */

export function useGetV1AccountsAccountIdLocationsLocationId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdQueryOptions(accountId,locationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific location associated with an account. The locationId parameter identifies the location to be deleted, which will remove it from the system and disassociate it from the account.
 * @summary Delete Location
 */
export const deleteV1AccountsAccountIdLocationsLocationId = (
    accountId: string,
    locationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationId>>, TError,{accountId: string;locationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationId>>, TError,{accountId: string;locationId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationId>>, {accountId: string;locationId: string}> = (props) => {
          const {accountId,locationId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationId(accountId,locationId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationId>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Location
 */
export const useDeleteV1AccountsAccountIdLocationsLocationId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationId>>, TError,{accountId: string;locationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationId>>,
        TError,
        {accountId: string;locationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the information of a specific location under an account. Administrators can modify the location's details, such as its address, hours of operation, or other attributes, ensuring that the information remains current and accurate for effective management.
 * @summary Update Location
 */
export const patchV1AccountsAccountIdLocationsLocationId = (
    accountId: string,
    locationId: string,
    locationPatchEntity: LocationPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetLocationByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}`,
      locationPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationId>>, TError,{accountId: string;locationId: string;data: LocationPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationId>>, TError,{accountId: string;locationId: string;data: LocationPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationId>>, {accountId: string;locationId: string;data: LocationPatchEntity}> = (props) => {
          const {accountId,locationId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationId(accountId,locationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdMutationBody = LocationPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Location
 */
export const usePatchV1AccountsAccountIdLocationsLocationId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationId>>, TError,{accountId: string;locationId: string;data: LocationPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationId>>,
        TError,
        {accountId: string;locationId: string;data: LocationPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all orders associated with a specific location under an account. The data returned includes order identifiers, statuses, and other relevant details, providing a comprehensive overview of all orders managed by the location.
 * @summary List Orders
 */
export const getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders = (
    resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListOrdersResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/accounts/${accountId}/locations/${locationId}/orders`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersQueryKey = (resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams,) => {
    return [`/v1/resellers/${resellerId}/accounts/${accountId}/locations/${locationId}/orders`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersQueryKey(resellerId,accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders(resellerId,accountId,locationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>>
export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params: undefined |  GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Orders
 */

export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersInfiniteQueryOptions(resellerId,accountId,locationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersQueryKey(resellerId,accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>> = ({ signal }) => getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders(resellerId,accountId,locationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>>
export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params: undefined |  GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Orders
 */

export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrders>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdOrdersQueryOptions(resellerId,accountId,locationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint lists all applications associated with a specific location under an account. The data includes application identifiers, names, and other relevant details, allowing administrators to manage and monitor applications linked to that location.
 * @summary List Applications
 */
export const getV1AccountsAccountIdLocationsLocationIdApplications = (
    accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdApplicationsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListApplicationsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/applications`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdApplicationsQueryKey = (accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdApplicationsParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/applications`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdApplicationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, GetV1AccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdApplicationsQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdApplications(accountId,locationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdApplicationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>>
export type GetV1AccountsAccountIdLocationsLocationIdApplicationsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, GetV1AccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdApplicationsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, GetV1AccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, GetV1AccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Applications
 */

export function useGetV1AccountsAccountIdLocationsLocationIdApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, GetV1AccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdApplicationsInfiniteQueryOptions(accountId,locationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdApplicationsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdApplicationsQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdApplications(accountId,locationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdApplicationsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>>
export type GetV1AccountsAccountIdLocationsLocationIdApplicationsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdApplications<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdApplicationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdApplications<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdApplications<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Applications
 */

export function useGetV1AccountsAccountIdLocationsLocationIdApplications<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdApplications>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdApplicationsQueryOptions(accountId,locationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves a list of all categories within a catalog associated with a specific location under an account. The data includes category identifiers, names, and descriptions, providing an overview of the categories available in the catalog. Users can use this information to manage and organize products within the catalog.
 * @summary Get Catalog Categories
 */
export const getV1AccountsAccountIdLocationsLocationIdCatalogCategories = (
    accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListCatalogCategoriesResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/categories`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesQueryKey = (accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/catalog/categories`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdCatalogCategories(accountId,locationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Categories
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesInfiniteQueryOptions(accountId,locationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogCategories(accountId,locationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategories<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategories<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategories<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Categories
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogCategories<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogCategoriesQueryOptions(accountId,locationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new category within a catalog at a specific location. Users can define the category's details, including its name, description, and associated products. Once created, the category will be available for organizing products within the catalog, enhancing the catalog's structure and usability.
 * @summary Create Catalog Category
 */
export const postV1AccountsAccountIdLocationsLocationIdCatalogCategories = (
    accountId: string,
    locationId: string,
    catalogCategoryCreateEntity: CatalogCategoryCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountCatalogCategoryByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/categories`,
      catalogCategoryCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdCatalogCategoriesMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError,{accountId: string;locationId: string;data: CatalogCategoryCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError,{accountId: string;locationId: string;data: CatalogCategoryCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdCatalogCategories'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, {accountId: string;locationId: string;data: CatalogCategoryCreateEntity}> = (props) => {
          const {accountId,locationId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdCatalogCategories(accountId,locationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdCatalogCategoriesMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogCategories>>>
    export type PostV1AccountsAccountIdLocationsLocationIdCatalogCategoriesMutationBody = CatalogCategoryCreateEntity
    export type PostV1AccountsAccountIdLocationsLocationIdCatalogCategoriesMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Catalog Category
 */
export const usePostV1AccountsAccountIdLocationsLocationIdCatalogCategories = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogCategories>>, TError,{accountId: string;locationId: string;data: CatalogCategoryCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdCatalogCategories>>,
        TError,
        {accountId: string;locationId: string;data: CatalogCategoryCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdCatalogCategoriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows users to import a catalog dataset into a specific location under an account. The import process can include categories, products, modifiers, and other relevant details, allowing for efficient setup, migration, or restoration of the catalog.
 * @summary Import Catalog
 */
export const putV1AccountsAccountIdLocationsLocationIdCatalogImport = (
    accountId: string,
    locationId: string,
    catalogImportEntity: CatalogImportEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.put(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/import`,
      catalogImportEntity,options
    );
  }



export const getPutV1AccountsAccountIdLocationsLocationIdCatalogImportMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AccountsAccountIdLocationsLocationIdCatalogImport>>, TError,{accountId: string;locationId: string;data: CatalogImportEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof putV1AccountsAccountIdLocationsLocationIdCatalogImport>>, TError,{accountId: string;locationId: string;data: CatalogImportEntity}, TContext> => {
    
const mutationKey = ['putV1AccountsAccountIdLocationsLocationIdCatalogImport'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putV1AccountsAccountIdLocationsLocationIdCatalogImport>>, {accountId: string;locationId: string;data: CatalogImportEntity}> = (props) => {
          const {accountId,locationId,data} = props ?? {};

          return  putV1AccountsAccountIdLocationsLocationIdCatalogImport(accountId,locationId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutV1AccountsAccountIdLocationsLocationIdCatalogImportMutationResult = NonNullable<Awaited<ReturnType<typeof putV1AccountsAccountIdLocationsLocationIdCatalogImport>>>
    export type PutV1AccountsAccountIdLocationsLocationIdCatalogImportMutationBody = CatalogImportEntity
    export type PutV1AccountsAccountIdLocationsLocationIdCatalogImportMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Import Catalog
 */
export const usePutV1AccountsAccountIdLocationsLocationIdCatalogImport = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putV1AccountsAccountIdLocationsLocationIdCatalogImport>>, TError,{accountId: string;locationId: string;data: CatalogImportEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof putV1AccountsAccountIdLocationsLocationIdCatalogImport>>,
        TError,
        {accountId: string;locationId: string;data: CatalogImportEntity},
        TContext
      > => {

      const mutationOptions = getPutV1AccountsAccountIdLocationsLocationIdCatalogImportMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves metrics and performance data for a specific account. It allows account owners to monitor the account's usage, effectiveness, and other key performance indicators, providing insights that can inform decisions about resource allocation and account management.
 * @summary Get Metrics
 */
export const getV1AccountsAccountIdMetrics = (
    accountId: string,
    params?: GetV1AccountsAccountIdMetricsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/metrics`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdMetricsQueryKey = (accountId: string,
    params?: GetV1AccountsAccountIdMetricsParams,) => {
    return [`/v1/accounts/${accountId}/metrics`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdMetricsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, GetV1AccountsAccountIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    params?: GetV1AccountsAccountIdMetricsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, QueryKey, GetV1AccountsAccountIdMetricsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdMetricsQueryKey(accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, QueryKey, GetV1AccountsAccountIdMetricsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdMetrics(accountId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, QueryKey, GetV1AccountsAccountIdMetricsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdMetricsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>>
export type GetV1AccountsAccountIdMetricsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, GetV1AccountsAccountIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params: undefined |  GetV1AccountsAccountIdMetricsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, QueryKey, GetV1AccountsAccountIdMetricsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, GetV1AccountsAccountIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdMetricsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, QueryKey, GetV1AccountsAccountIdMetricsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, GetV1AccountsAccountIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdMetricsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, QueryKey, GetV1AccountsAccountIdMetricsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Metrics
 */

export function useGetV1AccountsAccountIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, GetV1AccountsAccountIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdMetricsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, QueryKey, GetV1AccountsAccountIdMetricsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdMetricsInfiniteQueryOptions(accountId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdMetricsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    params?: GetV1AccountsAccountIdMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdMetricsQueryKey(accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>> = ({ signal }) => getV1AccountsAccountIdMetrics(accountId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdMetricsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>>
export type GetV1AccountsAccountIdMetricsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdMetrics<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params: undefined |  GetV1AccountsAccountIdMetricsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdMetrics<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdMetrics<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Metrics
 */

export function useGetV1AccountsAccountIdMetrics<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdMetricsQueryOptions(accountId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves detailed information about a specific order associated with a location, identified by the orderId parameter. It provides comprehensive data about the order, including its status, items, and delivery information, allowing for effective tracking and management of the order.
 * @summary Get Order
 */
export const getV1AccountsAccountIdLocationsLocationIdOrdersOrderId = (
    accountId: string,
    locationId: string,
    orderId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetOrderByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/orders/${orderId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdQueryKey = (accountId: string,
    locationId: string,
    orderId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/orders/${orderId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdQueryKey(accountId,locationId,orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdOrdersOrderId(accountId,locationId,orderId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && orderId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>>
export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Order
 */

export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdInfiniteQueryOptions(accountId,locationId,orderId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdQueryKey(accountId,locationId,orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdOrdersOrderId(accountId,locationId,orderId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && orderId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>>
export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Order
 */

export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdQueryOptions(accountId,locationId,orderId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for updating the information of a specific order under a location. Users can modify details such as the order's status, delivery instructions, or items, ensuring that the order remains accurate and aligned with the customer's needs.
 * @summary Update Order
 */
export const patchV1AccountsAccountIdLocationsLocationIdOrdersOrderId = (
    accountId: string,
    locationId: string,
    orderId: string,
    orderPatchEntity: OrderPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetOrderByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/orders/${orderId}`,
      orderPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError,{accountId: string;locationId: string;orderId: string;data: OrderPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError,{accountId: string;locationId: string;orderId: string;data: OrderPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdOrdersOrderId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, {accountId: string;locationId: string;orderId: string;data: OrderPatchEntity}> = (props) => {
          const {accountId,locationId,orderId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdOrdersOrderId(accountId,locationId,orderId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdMutationBody = OrderPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Order
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdOrdersOrderId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>, TError,{accountId: string;locationId: string;orderId: string;data: OrderPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdOrdersOrderId>>,
        TError,
        {accountId: string;locationId: string;orderId: string;data: OrderPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdOrdersOrderIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications = (
    resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListApplicationsResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/accounts/${accountId}/locations/${locationId}/applications`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsQueryKey = (resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams,) => {
    return [`/v1/resellers/${resellerId}/accounts/${accountId}/locations/${locationId}/applications`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsQueryKey(resellerId,accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications(resellerId,accountId,locationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>>
export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params: undefined |  GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsInfiniteQueryOptions(resellerId,accountId,locationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsQueryKey(resellerId,accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>> = ({ signal }) => getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications(resellerId,accountId,locationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>>
export type GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params: undefined |  GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    locationId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplications>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsAccountIdLocationsLocationIdApplicationsQueryOptions(resellerId,accountId,locationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint lists all locations that are associated with a specific account under a reseller. The data returned includes location identifiers, names, and other relevant details, providing a comprehensive overview of all locations associated with the account.
 * @summary List Locations
 */
export const getV1ResellersResellerIdAccountsAccountIdLocations = (
    resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListLocationsResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/accounts/${accountId}/locations`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdAccountsAccountIdLocationsQueryKey = (resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsParams,) => {
    return [`/v1/resellers/${resellerId}/accounts/${accountId}/locations`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdAccountsAccountIdLocationsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, GetV1ResellersResellerIdAccountsAccountIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsAccountIdLocationsQueryKey(resellerId,accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdAccountsAccountIdLocations(resellerId,accountId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && accountId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsAccountIdLocationsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>>
export type GetV1ResellersResellerIdAccountsAccountIdLocationsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsAccountIdLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, GetV1ResellersResellerIdAccountsAccountIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params: undefined |  GetV1ResellersResellerIdAccountsAccountIdLocationsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, GetV1ResellersResellerIdAccountsAccountIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, GetV1ResellersResellerIdAccountsAccountIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Locations
 */

export function useGetV1ResellersResellerIdAccountsAccountIdLocationsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, GetV1ResellersResellerIdAccountsAccountIdLocationsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdLocationsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsAccountIdLocationsInfiniteQueryOptions(resellerId,accountId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdAccountsAccountIdLocationsQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsAccountIdLocationsQueryKey(resellerId,accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>> = ({ signal }) => getV1ResellersResellerIdAccountsAccountIdLocations(resellerId,accountId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && accountId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsAccountIdLocationsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>>
export type GetV1ResellersResellerIdAccountsAccountIdLocationsQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsAccountIdLocations<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params: undefined |  GetV1ResellersResellerIdAccountsAccountIdLocationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocations<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdLocations<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Locations
 */

export function useGetV1ResellersResellerIdAccountsAccountIdLocations<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdLocationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdLocations>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsAccountIdLocationsQueryOptions(resellerId,accountId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new location under a specific account associated with a reseller. Administrators can define the location's details, such as its name, address, and operational hours. Once created, the location will be linked to the account and managed accordingly.
 * @summary Create Location
 */
export const postV1ResellersResellerIdAccountsAccountIdLocations = (
    resellerId: string,
    accountId: string,
    locationCreateEntity: LocationCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetLocationByIdResponse>> => {
    
    
    return axios.post(
      `/v1/resellers/${resellerId}/accounts/${accountId}/locations`,
      locationCreateEntity,options
    );
  }



export const getPostV1ResellersResellerIdAccountsAccountIdLocationsMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdAccountsAccountIdLocations>>, TError,{resellerId: string;accountId: string;data: LocationCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdAccountsAccountIdLocations>>, TError,{resellerId: string;accountId: string;data: LocationCreateEntity}, TContext> => {
    
const mutationKey = ['postV1ResellersResellerIdAccountsAccountIdLocations'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ResellersResellerIdAccountsAccountIdLocations>>, {resellerId: string;accountId: string;data: LocationCreateEntity}> = (props) => {
          const {resellerId,accountId,data} = props ?? {};

          return  postV1ResellersResellerIdAccountsAccountIdLocations(resellerId,accountId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ResellersResellerIdAccountsAccountIdLocationsMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ResellersResellerIdAccountsAccountIdLocations>>>
    export type PostV1ResellersResellerIdAccountsAccountIdLocationsMutationBody = LocationCreateEntity
    export type PostV1ResellersResellerIdAccountsAccountIdLocationsMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Location
 */
export const usePostV1ResellersResellerIdAccountsAccountIdLocations = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdAccountsAccountIdLocations>>, TError,{resellerId: string;accountId: string;data: LocationCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1ResellersResellerIdAccountsAccountIdLocations>>,
        TError,
        {resellerId: string;accountId: string;data: LocationCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1ResellersResellerIdAccountsAccountIdLocationsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific menu associated with a location, identified by the menuId parameter. It provides comprehensive data about the menu, including its items, categories, and status, allowing for effective management and updates.
 * @summary Get Menu
 */
export const getV1AccountsAccountIdLocationsLocationIdMenusMenuId = (
    accountId: string,
    locationId: string,
    menuId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountMenuByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdQueryKey = (accountId: string,
    locationId: string,
    menuId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdQueryKey(accountId,locationId,menuId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuId(accountId,locationId,menuId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Menu
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdInfiniteQueryOptions(accountId,locationId,menuId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdQueryKey(accountId,locationId,menuId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuId(accountId,locationId,menuId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Menu
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdQueryOptions(accountId,locationId,menuId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific menu associated with a location. The menuId parameter identifies the menu to be deleted, which will remove it from the system and disassociate it from the location.
 * @summary Delete Menu
 */
export const deleteV1AccountsAccountIdLocationsLocationIdMenusMenuId = (
    accountId: string,
    locationId: string,
    menuId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError,{accountId: string;locationId: string;menuId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError,{accountId: string;locationId: string;menuId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationIdMenusMenuId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, {accountId: string;locationId: string;menuId: string}> = (props) => {
          const {accountId,locationId,menuId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationIdMenusMenuId(accountId,locationId,menuId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuId>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Menu
 */
export const useDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError,{accountId: string;locationId: string;menuId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuId>>,
        TError,
        {accountId: string;locationId: string;menuId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the information of a specific menu associated with a location. Administrators can modify various aspects of the menu, such as its items, categories, or availability, ensuring that the menu remains current and aligned with the location's offerings.
 * @summary Update Menu
 */
export const patchV1AccountsAccountIdLocationsLocationIdMenusMenuId = (
    accountId: string,
    locationId: string,
    menuId: string,
    menuPatchEntity: MenuPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountMenuByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}`,
      menuPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdMenusMenuId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, {accountId: string;locationId: string;menuId: string;data: MenuPatchEntity}> = (props) => {
          const {accountId,locationId,menuId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdMenusMenuId(accountId,locationId,menuId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdMutationBody = MenuPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Menu
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdMenusMenuId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuId>>, TError,{accountId: string;locationId: string;menuId: string;data: MenuPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuId>>,
        TError,
        {accountId: string;locationId: string;menuId: string;data: MenuPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves audit logs for a specific location associated with an account. The logs provide detailed records of actions and changes made at the location, allowing administrators to review and analyze activity for compliance and security purposes.
 * @summary Get Audits
 */
export const getV1AccountsAccountIdLocationsLocationIdAudits = (
    accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdAuditsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAuditsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/audits`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdAuditsQueryKey = (accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdAuditsParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/audits`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdAuditsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, GetV1AccountsAccountIdLocationsLocationIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdAuditsQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdAuditsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdAudits(accountId,locationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdAuditsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdAuditsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>>
export type GetV1AccountsAccountIdLocationsLocationIdAuditsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, GetV1AccountsAccountIdLocationsLocationIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdAuditsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdAuditsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, GetV1AccountsAccountIdLocationsLocationIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdAuditsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, GetV1AccountsAccountIdLocationsLocationIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Audits
 */

export function useGetV1AccountsAccountIdLocationsLocationIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, GetV1AccountsAccountIdLocationsLocationIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdAuditsInfiniteQueryOptions(accountId,locationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdAuditsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdAuditsQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdAudits(accountId,locationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdAuditsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>>
export type GetV1AccountsAccountIdLocationsLocationIdAuditsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdAudits<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdAuditsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdAudits<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdAudits<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Audits
 */

export function useGetV1AccountsAccountIdLocationsLocationIdAudits<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdAuditsQueryOptions(accountId,locationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the cancellation of a specific delivery associated with an order under a reseller. The deliveryId parameter identifies the delivery to be canceled. This operation will update the delivery status and make it unavailable for further processing.
 * @summary Cancel Order Delivery
 */
export const postV1ResellersResellerIdDeliveriesDeliveryIdCancel = (
    resellerId: string,
    deliveryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.post(
      `/v1/resellers/${resellerId}/deliveries/${deliveryId}/cancel`,undefined,options
    );
  }



export const getPostV1ResellersResellerIdDeliveriesDeliveryIdCancelMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdCancel>>, TError,{resellerId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdCancel>>, TError,{resellerId: string;deliveryId: string}, TContext> => {
    
const mutationKey = ['postV1ResellersResellerIdDeliveriesDeliveryIdCancel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdCancel>>, {resellerId: string;deliveryId: string}> = (props) => {
          const {resellerId,deliveryId} = props ?? {};

          return  postV1ResellersResellerIdDeliveriesDeliveryIdCancel(resellerId,deliveryId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ResellersResellerIdDeliveriesDeliveryIdCancelMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdCancel>>>
    
    export type PostV1ResellersResellerIdDeliveriesDeliveryIdCancelMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Cancel Order Delivery
 */
export const usePostV1ResellersResellerIdDeliveriesDeliveryIdCancel = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdCancel>>, TError,{resellerId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdCancel>>,
        TError,
        {resellerId: string;deliveryId: string},
        TContext
      > => {

      const mutationOptions = getPostV1ResellersResellerIdDeliveriesDeliveryIdCancelMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific modifier within a catalog at a location, identified by the modifierId parameter. It provides comprehensive data about the modifier, including its description, pricing, and availability, allowing for effective management and updates.
 * @summary Get Catalog Modifier
 */
export const getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId = (
    accountId: string,
    locationId: string,
    modifierId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountCatalogModifierByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/modifiers/${modifierId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdQueryKey = (accountId: string,
    locationId: string,
    modifierId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/catalog/modifiers/${modifierId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    modifierId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdQueryKey(accountId,locationId,modifierId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId(accountId,locationId,modifierId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && modifierId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Modifier
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdInfiniteQueryOptions(accountId,locationId,modifierId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    modifierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdQueryKey(accountId,locationId,modifierId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId(accountId,locationId,modifierId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && modifierId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Modifier
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    modifierId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdQueryOptions(accountId,locationId,modifierId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific modifier within a catalog at a location. The modifierId parameter identifies the modifier to be deleted, which will remove it from the system and disassociate it from the catalog.
 * @summary Delete Catalog Modifier
 */
export const deleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId = (
    accountId: string,
    locationId: string,
    modifierId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/modifiers/${modifierId}`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError,{accountId: string;locationId: string;modifierId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError,{accountId: string;locationId: string;modifierId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, {accountId: string;locationId: string;modifierId: string}> = (props) => {
          const {accountId,locationId,modifierId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId(accountId,locationId,modifierId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Catalog Modifier
 */
export const useDeleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError,{accountId: string;locationId: string;modifierId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>,
        TError,
        {accountId: string;locationId: string;modifierId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the information of a specific modifier within a catalog at a location. Users can modify the modifier's details, such as its description, pricing, or availability, ensuring that the modifier remains current and aligned with the catalog's customization options.
 * @summary Update Catalog Modifier
 */
export const patchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId = (
    accountId: string,
    locationId: string,
    modifierId: string,
    catalogModifierPatchEntity: CatalogModifierPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountCatalogModifierByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/modifiers/${modifierId}`,
      catalogModifierPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError,{accountId: string;locationId: string;modifierId: string;data: CatalogModifierPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError,{accountId: string;locationId: string;modifierId: string;data: CatalogModifierPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, {accountId: string;locationId: string;modifierId: string;data: CatalogModifierPatchEntity}> = (props) => {
          const {accountId,locationId,modifierId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId(accountId,locationId,modifierId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdMutationBody = CatalogModifierPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Catalog Modifier
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>, TError,{accountId: string;locationId: string;modifierId: string;data: CatalogModifierPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierId>>,
        TError,
        {accountId: string;locationId: string;modifierId: string;data: CatalogModifierPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdCatalogModifiersModifierIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific category within a menu at a location, identified by the categoryId parameter. It provides comprehensive data about the category, including its items and status, allowing for effective management and updates.
 * @summary Get Category
 */
export const getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId = (
    accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountMenuCategoryByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/categories/${categoryId}`,options
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdQueryKey = (accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/categories/${categoryId}`] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdQueryKey(accountId,locationId,menuId,categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId(accountId,locationId,menuId,categoryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId && categoryId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Category
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdInfiniteQueryOptions(accountId,locationId,menuId,categoryId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdQueryKey(accountId,locationId,menuId,categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId(accountId,locationId,menuId,categoryId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && menuId && categoryId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>>
export type GetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Category
 */

export function useGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdQueryOptions(accountId,locationId,menuId,categoryId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific category within a menu at a location. The categoryId parameter identifies the category to be deleted, which will remove it from the system and disassociate it from the menu.
 * @summary Delete Category
 */
export const deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId = (
    accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/categories/${categoryId}`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError,{accountId: string;locationId: string;menuId: string;categoryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError,{accountId: string;locationId: string;menuId: string;categoryId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, {accountId: string;locationId: string;menuId: string;categoryId: string}> = (props) => {
          const {accountId,locationId,menuId,categoryId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId(accountId,locationId,menuId,categoryId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Category
 */
export const useDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError,{accountId: string;locationId: string;menuId: string;categoryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>,
        TError,
        {accountId: string;locationId: string;menuId: string;categoryId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for updating the information of a specific category within a menu at a location. Administrators can modify various aspects of the category, such as its name, items, or availability, ensuring that the category remains current and aligned with the menu's offerings.
 * @summary Update Category
 */
export const patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId = (
    accountId: string,
    locationId: string,
    menuId: string,
    categoryId: string,
    menuCategoryPatchEntity: MenuCategoryPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountMenuCategoryByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/locations/${locationId}/menus/${menuId}/categories/${categoryId}`,
      menuCategoryPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError,{accountId: string;locationId: string;menuId: string;categoryId: string;data: MenuCategoryPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError,{accountId: string;locationId: string;menuId: string;categoryId: string;data: MenuCategoryPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, {accountId: string;locationId: string;menuId: string;categoryId: string;data: MenuCategoryPatchEntity}> = (props) => {
          const {accountId,locationId,menuId,categoryId,data} = props ?? {};

          return  patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId(accountId,locationId,menuId,categoryId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>>
    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdMutationBody = MenuCategoryPatchEntity
    export type PatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Category
 */
export const usePatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>, TError,{accountId: string;locationId: string;menuId: string;categoryId: string;data: MenuCategoryPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryId>>,
        TError,
        {accountId: string;locationId: string;menuId: string;categoryId: string;data: MenuCategoryPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdLocationsLocationIdMenusMenuIdCategoriesCategoryIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific order associated with an account, identified by the orderId parameter. It provides comprehensive data about the order, including items, status, and other relevant details, making it useful for managing individual orders.
 * @summary Get Order
 */
export const getV1AccountsAccountIdOrdersOrderId = (
    accountId: string,
    orderId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetOrderByIdResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/orders/${orderId}`,options
    );
  }


export const getGetV1AccountsAccountIdOrdersOrderIdQueryKey = (accountId: string,
    orderId: string,) => {
    return [`/v1/accounts/${accountId}/orders/${orderId}`] as const;
    }

    
export const getGetV1AccountsAccountIdOrdersOrderIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdOrdersOrderIdQueryKey(accountId,orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>> = ({ signal }) => getV1AccountsAccountIdOrdersOrderId(accountId,orderId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && orderId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdOrdersOrderIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>>
export type GetV1AccountsAccountIdOrdersOrderIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdOrdersOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdOrdersOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdOrdersOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Order
 */

export function useGetV1AccountsAccountIdOrdersOrderIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdOrdersOrderIdInfiniteQueryOptions(accountId,orderId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdOrdersOrderIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdOrdersOrderIdQueryKey(accountId,orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>> = ({ signal }) => getV1AccountsAccountIdOrdersOrderId(accountId,orderId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && orderId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdOrdersOrderIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>>
export type GetV1AccountsAccountIdOrdersOrderIdQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdOrdersOrderId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdOrdersOrderId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdOrdersOrderId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Order
 */

export function useGetV1AccountsAccountIdOrdersOrderId<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrdersOrderId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdOrdersOrderIdQueryOptions(accountId,orderId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for updating the information of a specific order associated with an account. Users can modify various aspects of the order, such as  status, or other attributes, ensuring that the order remains current and accurate.
 * @summary Update Order
 */
export const patchV1AccountsAccountIdOrdersOrderId = (
    accountId: string,
    orderId: string,
    orderPatchEntity: OrderPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetOrderByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/accounts/${accountId}/orders/${orderId}`,
      orderPatchEntity,options
    );
  }



export const getPatchV1AccountsAccountIdOrdersOrderIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdOrdersOrderId>>, TError,{accountId: string;orderId: string;data: OrderPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdOrdersOrderId>>, TError,{accountId: string;orderId: string;data: OrderPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1AccountsAccountIdOrdersOrderId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1AccountsAccountIdOrdersOrderId>>, {accountId: string;orderId: string;data: OrderPatchEntity}> = (props) => {
          const {accountId,orderId,data} = props ?? {};

          return  patchV1AccountsAccountIdOrdersOrderId(accountId,orderId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1AccountsAccountIdOrdersOrderIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1AccountsAccountIdOrdersOrderId>>>
    export type PatchV1AccountsAccountIdOrdersOrderIdMutationBody = OrderPatchEntity
    export type PatchV1AccountsAccountIdOrdersOrderIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Order
 */
export const usePatchV1AccountsAccountIdOrdersOrderId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1AccountsAccountIdOrdersOrderId>>, TError,{accountId: string;orderId: string;data: OrderPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1AccountsAccountIdOrdersOrderId>>,
        TError,
        {accountId: string;orderId: string;data: OrderPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1AccountsAccountIdOrdersOrderIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves detailed information about a specific account associated with a reseller, identified by the accountId parameter. It provides comprehensive data about the account, including contact details, status, and other relevant information. This is useful for managing a specific account's details.
 * @summary Get Account
 */
export const getV1ResellersResellerIdAccountsAccountId = (
    resellerId: string,
    accountId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountByIdResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/accounts/${accountId}`,options
    );
  }


export const getGetV1ResellersResellerIdAccountsAccountIdQueryKey = (resellerId: string,
    accountId: string,) => {
    return [`/v1/resellers/${resellerId}/accounts/${accountId}`] as const;
    }

    
export const getGetV1ResellersResellerIdAccountsAccountIdInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    accountId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsAccountIdQueryKey(resellerId,accountId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>> = ({ signal }) => getV1ResellersResellerIdAccountsAccountId(resellerId,accountId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && accountId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsAccountIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>>
export type GetV1ResellersResellerIdAccountsAccountIdInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsAccountIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Account
 */

export function useGetV1ResellersResellerIdAccountsAccountIdInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsAccountIdInfiniteQueryOptions(resellerId,accountId,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdAccountsAccountIdQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsAccountIdQueryKey(resellerId,accountId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>> = ({ signal }) => getV1ResellersResellerIdAccountsAccountId(resellerId,accountId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && accountId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsAccountIdQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>>
export type GetV1ResellersResellerIdAccountsAccountIdQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsAccountId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Account
 */

export function useGetV1ResellersResellerIdAccountsAccountId<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountId>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsAccountIdQueryOptions(resellerId,accountId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for updating the information of a specific account under a reseller, identified by the accountId parameter. Administrators can modify various aspects of the account, such as its contact information, status, or other relevant details.
 * @summary Update Account
 */
export const patchV1ResellersResellerIdAccountsAccountId = (
    resellerId: string,
    accountId: string,
    resellerAccountPatchEntity: ResellerAccountPatchEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountByIdResponse>> => {
    
    
    return axios.patch(
      `/v1/resellers/${resellerId}/accounts/${accountId}`,
      resellerAccountPatchEntity,options
    );
  }



export const getPatchV1ResellersResellerIdAccountsAccountIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerIdAccountsAccountId>>, TError,{resellerId: string;accountId: string;data: ResellerAccountPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerIdAccountsAccountId>>, TError,{resellerId: string;accountId: string;data: ResellerAccountPatchEntity}, TContext> => {
    
const mutationKey = ['patchV1ResellersResellerIdAccountsAccountId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchV1ResellersResellerIdAccountsAccountId>>, {resellerId: string;accountId: string;data: ResellerAccountPatchEntity}> = (props) => {
          const {resellerId,accountId,data} = props ?? {};

          return  patchV1ResellersResellerIdAccountsAccountId(resellerId,accountId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchV1ResellersResellerIdAccountsAccountIdMutationResult = NonNullable<Awaited<ReturnType<typeof patchV1ResellersResellerIdAccountsAccountId>>>
    export type PatchV1ResellersResellerIdAccountsAccountIdMutationBody = ResellerAccountPatchEntity
    export type PatchV1ResellersResellerIdAccountsAccountIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Update Account
 */
export const usePatchV1ResellersResellerIdAccountsAccountId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchV1ResellersResellerIdAccountsAccountId>>, TError,{resellerId: string;accountId: string;data: ResellerAccountPatchEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof patchV1ResellersResellerIdAccountsAccountId>>,
        TError,
        {resellerId: string;accountId: string;data: ResellerAccountPatchEntity},
        TContext
      > => {

      const mutationOptions = getPatchV1ResellersResellerIdAccountsAccountIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all connections associated with a specific location under an account. The data returned includes connection identifiers, types, and statuses, providing a comprehensive overview of the external systems and services linked to the location. Users can use this information to manage and monitor connections, ensuring they remain active and properly configured.
 * @summary Get Location Connections
 */
export const getV1AccountsAccountIdLocationsLocationIdConnections = (
    accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdConnectionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListConnectionsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/connections`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdConnectionsQueryKey = (accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdConnectionsParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/connections`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdConnectionsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, GetV1AccountsAccountIdLocationsLocationIdConnectionsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdConnectionsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdConnectionsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdConnectionsQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdConnectionsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdConnections(accountId,locationId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdConnectionsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdConnectionsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>>
export type GetV1AccountsAccountIdLocationsLocationIdConnectionsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdConnectionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, GetV1AccountsAccountIdLocationsLocationIdConnectionsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdConnectionsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdConnectionsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdConnectionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, GetV1AccountsAccountIdLocationsLocationIdConnectionsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdConnectionsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdConnectionsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdConnectionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, GetV1AccountsAccountIdLocationsLocationIdConnectionsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdConnectionsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdConnectionsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Location Connections
 */

export function useGetV1AccountsAccountIdLocationsLocationIdConnectionsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, GetV1AccountsAccountIdLocationsLocationIdConnectionsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdConnectionsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdConnectionsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdConnectionsInfiniteQueryOptions(accountId,locationId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdConnectionsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdConnectionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdConnectionsQueryKey(accountId,locationId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdConnections(accountId,locationId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdConnectionsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>>
export type GetV1AccountsAccountIdLocationsLocationIdConnectionsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdConnections<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdConnectionsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdConnections<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdConnectionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdConnections<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdConnectionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Location Connections
 */

export function useGetV1AccountsAccountIdLocationsLocationIdConnections<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdConnectionsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdConnections>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdConnectionsQueryOptions(accountId,locationId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint retrieves a list of all audits associated with a specific reseller. The data includes audit identifiers, actions, and other relevant details, providing a comprehensive overview of the audits managed by the reseller.
 * @summary Get Audits related to a given reseller
 */
export const getV1ResellersResellerIdAudits = (
    resellerId: string,
    params?: GetV1ResellersResellerIdAuditsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListAuditsResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/audits`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdAuditsQueryKey = (resellerId: string,
    params?: GetV1ResellersResellerIdAuditsParams,) => {
    return [`/v1/resellers/${resellerId}/audits`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdAuditsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, GetV1ResellersResellerIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, QueryKey, GetV1ResellersResellerIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAuditsQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, QueryKey, GetV1ResellersResellerIdAuditsParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdAudits(resellerId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, QueryKey, GetV1ResellersResellerIdAuditsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAuditsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>>
export type GetV1ResellersResellerIdAuditsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, GetV1ResellersResellerIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdAuditsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, QueryKey, GetV1ResellersResellerIdAuditsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, GetV1ResellersResellerIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, QueryKey, GetV1ResellersResellerIdAuditsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, GetV1ResellersResellerIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, QueryKey, GetV1ResellersResellerIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Audits related to a given reseller
 */

export function useGetV1ResellersResellerIdAuditsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, GetV1ResellersResellerIdAuditsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdAuditsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, QueryKey, GetV1ResellersResellerIdAuditsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAuditsInfiniteQueryOptions(resellerId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdAuditsQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAuditsQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>> = ({ signal }) => getV1ResellersResellerIdAudits(resellerId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAuditsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>>
export type GetV1ResellersResellerIdAuditsQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAudits<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdAuditsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAudits<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAudits<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Audits related to a given reseller
 */

export function useGetV1ResellersResellerIdAudits<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdAuditsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAudits>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAuditsQueryOptions(resellerId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the deletion of a specific application connected to a location under an account. The applicationId parameter identifies the application to be deleted, which will remove it from the system and disassociate it from the location.
 * @summary Delete Application
 */
export const deleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationId = (
    accountId: string,
    locationId: string,
    applicationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.delete(
      `/v1/accounts/${accountId}/locations/${locationId}/applications/${applicationId}`,options
    );
  }



export const getDeleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationIdMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationId>>, TError,{accountId: string;locationId: string;applicationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationId>>, TError,{accountId: string;locationId: string;applicationId: string}, TContext> => {
    
const mutationKey = ['deleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationId'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationId>>, {accountId: string;locationId: string;applicationId: string}> = (props) => {
          const {accountId,locationId,applicationId} = props ?? {};

          return  deleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationId(accountId,locationId,applicationId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationId>>>
    
    export type DeleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationIdMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Delete Application
 */
export const useDeleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationId = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationId>>, TError,{accountId: string;locationId: string;applicationId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationId>>,
        TError,
        {accountId: string;locationId: string;applicationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteV1AccountsAccountIdLocationsLocationIdApplicationsApplicationIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint allows for the dispatch of a specific quote to begin the delivery process. The deliveryId parameter identifies the delivery to be dispatched. This operation will update the delivery status and initiate the delivery process.
 * @summary Dispatch Delivery Quote
 */
export const postV1ResellersResellerIdDeliveriesDeliveryIdDispatch = (
    resellerId: string,
    deliveryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.post(
      `/v1/resellers/${resellerId}/deliveries/${deliveryId}/dispatch`,undefined,options
    );
  }



export const getPostV1ResellersResellerIdDeliveriesDeliveryIdDispatchMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdDispatch>>, TError,{resellerId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdDispatch>>, TError,{resellerId: string;deliveryId: string}, TContext> => {
    
const mutationKey = ['postV1ResellersResellerIdDeliveriesDeliveryIdDispatch'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdDispatch>>, {resellerId: string;deliveryId: string}> = (props) => {
          const {resellerId,deliveryId} = props ?? {};

          return  postV1ResellersResellerIdDeliveriesDeliveryIdDispatch(resellerId,deliveryId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ResellersResellerIdDeliveriesDeliveryIdDispatchMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdDispatch>>>
    
    export type PostV1ResellersResellerIdDeliveriesDeliveryIdDispatchMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Dispatch Delivery Quote
 */
export const usePostV1ResellersResellerIdDeliveriesDeliveryIdDispatch = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdDispatch>>, TError,{resellerId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1ResellersResellerIdDeliveriesDeliveryIdDispatch>>,
        TError,
        {resellerId: string;deliveryId: string},
        TContext
      > => {

      const mutationOptions = getPostV1ResellersResellerIdDeliveriesDeliveryIdDispatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all orders associated with a specific account. The data returned includes order identifiers, statuses, and other relevant details, providing a comprehensive overview of all orders managed by the account.
 * @summary List Orders
 */
export const getV1AccountsAccountIdOrders = (
    accountId: string,
    params?: GetV1AccountsAccountIdOrdersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListOrdersResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/orders`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdOrdersQueryKey = (accountId: string,
    params?: GetV1AccountsAccountIdOrdersParams,) => {
    return [`/v1/accounts/${accountId}/orders`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdOrdersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, GetV1AccountsAccountIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    params?: GetV1AccountsAccountIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, QueryKey, GetV1AccountsAccountIdOrdersParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdOrdersQueryKey(accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, QueryKey, GetV1AccountsAccountIdOrdersParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdOrders(accountId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, QueryKey, GetV1AccountsAccountIdOrdersParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdOrdersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>>
export type GetV1AccountsAccountIdOrdersInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, GetV1AccountsAccountIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params: undefined |  GetV1AccountsAccountIdOrdersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, QueryKey, GetV1AccountsAccountIdOrdersParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, GetV1AccountsAccountIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, QueryKey, GetV1AccountsAccountIdOrdersParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, GetV1AccountsAccountIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, QueryKey, GetV1AccountsAccountIdOrdersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Orders
 */

export function useGetV1AccountsAccountIdOrdersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, GetV1AccountsAccountIdOrdersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdOrdersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, QueryKey, GetV1AccountsAccountIdOrdersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdOrdersInfiniteQueryOptions(accountId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdOrdersQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    params?: GetV1AccountsAccountIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdOrdersQueryKey(accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>> = ({ signal }) => getV1AccountsAccountIdOrders(accountId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>>
export type GetV1AccountsAccountIdOrdersQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdOrders<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params: undefined |  GetV1AccountsAccountIdOrdersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdOrders<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdOrders<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Orders
 */

export function useGetV1AccountsAccountIdOrders<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    params?: GetV1AccountsAccountIdOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdOrders>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdOrdersQueryOptions(accountId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the refresh of a specific delivery associated with an account. The deliveryId parameter identifies the delivery to be refreshed, and this operation will update its status and make it available for further processing.
 * @summary Refresh Delivery
 */
export const postV1AccountsAccountIdDeliveriesDeliveryIdRefresh = (
    accountId: string,
    deliveryId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/deliveries/${deliveryId}/refresh`,undefined,options
    );
  }



export const getPostV1AccountsAccountIdDeliveriesDeliveryIdRefreshMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdRefresh>>, TError,{accountId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdRefresh>>, TError,{accountId: string;deliveryId: string}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdDeliveriesDeliveryIdRefresh'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdRefresh>>, {accountId: string;deliveryId: string}> = (props) => {
          const {accountId,deliveryId} = props ?? {};

          return  postV1AccountsAccountIdDeliveriesDeliveryIdRefresh(accountId,deliveryId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdDeliveriesDeliveryIdRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdRefresh>>>
    
    export type PostV1AccountsAccountIdDeliveriesDeliveryIdRefreshMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Refresh Delivery
 */
export const usePostV1AccountsAccountIdDeliveriesDeliveryIdRefresh = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdRefresh>>, TError,{accountId: string;deliveryId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdRefresh>>,
        TError,
        {accountId: string;deliveryId: string},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdDeliveriesDeliveryIdRefreshMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all users associated with a specific reseller. The data returned includes user identifiers, names, and other relevant details, allowing administrators to manage and monitor the user base effectively.
 * @summary List Users
 */
export const getV1ResellersResellerIdUsers = (
    resellerId: string,
    params?: GetV1ResellersResellerIdUsersParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListUsersResponse>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/users`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdUsersQueryKey = (resellerId: string,
    params?: GetV1ResellersResellerIdUsersParams,) => {
    return [`/v1/resellers/${resellerId}/users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdUsersInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, GetV1ResellersResellerIdUsersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdUsersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, QueryKey, GetV1ResellersResellerIdUsersParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdUsersQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, QueryKey, GetV1ResellersResellerIdUsersParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdUsers(resellerId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, QueryKey, GetV1ResellersResellerIdUsersParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdUsersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>>
export type GetV1ResellersResellerIdUsersInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdUsersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, GetV1ResellersResellerIdUsersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdUsersParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, QueryKey, GetV1ResellersResellerIdUsersParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdUsersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, GetV1ResellersResellerIdUsersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdUsersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, QueryKey, GetV1ResellersResellerIdUsersParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdUsersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, GetV1ResellersResellerIdUsersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdUsersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, QueryKey, GetV1ResellersResellerIdUsersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Users
 */

export function useGetV1ResellersResellerIdUsersInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, GetV1ResellersResellerIdUsersParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdUsersParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, QueryKey, GetV1ResellersResellerIdUsersParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdUsersInfiniteQueryOptions(resellerId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdUsersQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    params?: GetV1ResellersResellerIdUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdUsersQueryKey(resellerId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>> = ({ signal }) => getV1ResellersResellerIdUsers(resellerId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>>
export type GetV1ResellersResellerIdUsersQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdUsers<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params: undefined |  GetV1ResellersResellerIdUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdUsers<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdUsers<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Users
 */

export function useGetV1ResellersResellerIdUsers<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    params?: GetV1ResellersResellerIdUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdUsers>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdUsersQueryOptions(resellerId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new user under a specific reseller. Administrators can define the user's details, such as their name, email, and role. Once created, the user will be associated with the reseller and have access to the appropriate resources.
 * @summary Create User
 */
export const postV1ResellersResellerIdUsers = (
    resellerId: string,
    userCreateEntity: UserCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetUserByIdResponse>> => {
    
    
    return axios.post(
      `/v1/resellers/${resellerId}/users`,
      userCreateEntity,options
    );
  }



export const getPostV1ResellersResellerIdUsersMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdUsers>>, TError,{resellerId: string;data: UserCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdUsers>>, TError,{resellerId: string;data: UserCreateEntity}, TContext> => {
    
const mutationKey = ['postV1ResellersResellerIdUsers'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1ResellersResellerIdUsers>>, {resellerId: string;data: UserCreateEntity}> = (props) => {
          const {resellerId,data} = props ?? {};

          return  postV1ResellersResellerIdUsers(resellerId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1ResellersResellerIdUsersMutationResult = NonNullable<Awaited<ReturnType<typeof postV1ResellersResellerIdUsers>>>
    export type PostV1ResellersResellerIdUsersMutationBody = UserCreateEntity
    export type PostV1ResellersResellerIdUsersMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create User
 */
export const usePostV1ResellersResellerIdUsers = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1ResellersResellerIdUsers>>, TError,{resellerId: string;data: UserCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1ResellersResellerIdUsers>>,
        TError,
        {resellerId: string;data: UserCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1ResellersResellerIdUsersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const postV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancel = (
    accountId: string,
    deliveryId: string,
    dispatchedId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/deliveries/${deliveryId}/dispatch/${dispatchedId}/cancel`,undefined,options
    );
  }



export const getPostV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancelMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancel>>, TError,{accountId: string;deliveryId: string;dispatchedId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancel>>, TError,{accountId: string;deliveryId: string;dispatchedId: string}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancel>>, {accountId: string;deliveryId: string;dispatchedId: string}> = (props) => {
          const {accountId,deliveryId,dispatchedId} = props ?? {};

          return  postV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancel(accountId,deliveryId,dispatchedId,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancelMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancel>>>
    
    export type PostV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancelMutationError = AxiosError<ErrorResponse>

    export const usePostV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancel = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancel>>, TError,{accountId: string;deliveryId: string;dispatchedId: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancel>>,
        TError,
        {accountId: string;deliveryId: string;dispatchedId: string},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdDeliveriesDeliveryIdDispatchDispatchedIdCancelMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all deliveries associated with a specific order under a location. The data returned includes delivery identifiers, statuses, and other relevant details, providing a comprehensive overview of all deliveries linked to the order. Users can use this information to track delivery progress and status.
 * @summary List Deliveries
 */
export const getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries = (
    accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ListDeliveriesResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/orders/${orderId}/deliveries`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesQueryKey = (accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/orders/${orderId}/deliveries`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesQueryKey(accountId,locationId,orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries(accountId,locationId,orderId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && orderId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>>
export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Deliveries
 */

export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesInfiniteQueryOptions(accountId,locationId,orderId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesQueryKey(accountId,locationId,orderId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries(accountId,locationId,orderId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && orderId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>>
export type GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Deliveries
 */

export function useGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    orderId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesQueryOptions(accountId,locationId,orderId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint allows for the creation of a new delivery associated with a specific order under a location. Users can define the delivery's details, such as the driver, status, and location, ensuring that the delivery is accurately linked to the order and can be fulfilled accordingly.
 * @summary Create Delivery
 */
export const postV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries = (
    accountId: string,
    locationId: string,
    orderId: string,
    deliveryCreateEntity: DeliveryCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDeliveryByIdResponse>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/locations/${locationId}/orders/${orderId}/deliveries`,
      deliveryCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError,{accountId: string;locationId: string;orderId: string;data: DeliveryCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError,{accountId: string;locationId: string;orderId: string;data: DeliveryCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, {accountId: string;locationId: string;orderId: string;data: DeliveryCreateEntity}> = (props) => {
          const {accountId,locationId,orderId,data} = props ?? {};

          return  postV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries(accountId,locationId,orderId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>>
    export type PostV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesMutationBody = DeliveryCreateEntity
    export type PostV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Create Delivery
 */
export const usePostV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>, TError,{accountId: string;locationId: string;orderId: string;data: DeliveryCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveries>>,
        TError,
        {accountId: string;locationId: string;orderId: string;data: DeliveryCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdLocationsLocationIdOrdersOrderIdDeliveriesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Get Reseller Account Metrics
 */
export const getV1ResellersResellerIdAccountsAccountIdMetrics = (
    resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdMetricsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.get(
      `/v1/resellers/${resellerId}/accounts/${accountId}/metrics`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1ResellersResellerIdAccountsAccountIdMetricsQueryKey = (resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdMetricsParams,) => {
    return [`/v1/resellers/${resellerId}/accounts/${accountId}/metrics`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1ResellersResellerIdAccountsAccountIdMetricsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, GetV1ResellersResellerIdAccountsAccountIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdMetricsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdMetricsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsAccountIdMetricsQueryKey(resellerId,accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdMetricsParams['nextPageKey']> = ({ signal, pageParam }) => getV1ResellersResellerIdAccountsAccountIdMetrics(resellerId,accountId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && accountId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdMetricsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsAccountIdMetricsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>>
export type GetV1ResellersResellerIdAccountsAccountIdMetricsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsAccountIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, GetV1ResellersResellerIdAccountsAccountIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params: undefined |  GetV1ResellersResellerIdAccountsAccountIdMetricsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdMetricsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, GetV1ResellersResellerIdAccountsAccountIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdMetricsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdMetricsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, GetV1ResellersResellerIdAccountsAccountIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdMetricsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdMetricsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Reseller Account Metrics
 */

export function useGetV1ResellersResellerIdAccountsAccountIdMetricsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, GetV1ResellersResellerIdAccountsAccountIdMetricsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdMetricsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError, TData, Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, QueryKey, GetV1ResellersResellerIdAccountsAccountIdMetricsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsAccountIdMetricsInfiniteQueryOptions(resellerId,accountId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1ResellersResellerIdAccountsAccountIdMetricsQueryOptions = <TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError = AxiosError<ErrorResponse>>(resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1ResellersResellerIdAccountsAccountIdMetricsQueryKey(resellerId,accountId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>> = ({ signal }) => getV1ResellersResellerIdAccountsAccountIdMetrics(resellerId,accountId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(resellerId && accountId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1ResellersResellerIdAccountsAccountIdMetricsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>>
export type GetV1ResellersResellerIdAccountsAccountIdMetricsQueryError = AxiosError<ErrorResponse>


export function useGetV1ResellersResellerIdAccountsAccountIdMetrics<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params: undefined |  GetV1ResellersResellerIdAccountsAccountIdMetricsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdMetrics<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>,
          TError,
          Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1ResellersResellerIdAccountsAccountIdMetrics<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Reseller Account Metrics
 */

export function useGetV1ResellersResellerIdAccountsAccountIdMetrics<TData = Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError = AxiosError<ErrorResponse>>(
 resellerId: string,
    accountId: string,
    params?: GetV1ResellersResellerIdAccountsAccountIdMetricsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1ResellersResellerIdAccountsAccountIdMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1ResellersResellerIdAccountsAccountIdMetricsQueryOptions(resellerId,accountId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * This endpoint triggers a menu publish to a specific connection associated with an account. The publish process ensures that the latest menu data is sent to the connected system or service, keeping it up-to-date with the account's offerings. Proper authorization is required to perform this action, and it is typically used by users to synchronize data across systems.
 * @summary Publish to Connection
 */
export const postV1AccountsAccountIdConnectionsConnectionIdPublish = (
    accountId: string,
    connectionId: string,
    menuPublishCreateEntity: MenuPublishCreateEntity, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.post(
      `/v1/accounts/${accountId}/connections/${connectionId}/publish`,
      menuPublishCreateEntity,options
    );
  }



export const getPostV1AccountsAccountIdConnectionsConnectionIdPublishMutationOptions = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdConnectionsConnectionIdPublish>>, TError,{accountId: string;connectionId: string;data: MenuPublishCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdConnectionsConnectionIdPublish>>, TError,{accountId: string;connectionId: string;data: MenuPublishCreateEntity}, TContext> => {
    
const mutationKey = ['postV1AccountsAccountIdConnectionsConnectionIdPublish'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postV1AccountsAccountIdConnectionsConnectionIdPublish>>, {accountId: string;connectionId: string;data: MenuPublishCreateEntity}> = (props) => {
          const {accountId,connectionId,data} = props ?? {};

          return  postV1AccountsAccountIdConnectionsConnectionIdPublish(accountId,connectionId,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostV1AccountsAccountIdConnectionsConnectionIdPublishMutationResult = NonNullable<Awaited<ReturnType<typeof postV1AccountsAccountIdConnectionsConnectionIdPublish>>>
    export type PostV1AccountsAccountIdConnectionsConnectionIdPublishMutationBody = MenuPublishCreateEntity
    export type PostV1AccountsAccountIdConnectionsConnectionIdPublishMutationError = AxiosError<ErrorResponse>

    /**
 * @summary Publish to Connection
 */
export const usePostV1AccountsAccountIdConnectionsConnectionIdPublish = <TError = AxiosError<ErrorResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postV1AccountsAccountIdConnectionsConnectionIdPublish>>, TError,{accountId: string;connectionId: string;data: MenuPublishCreateEntity}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postV1AccountsAccountIdConnectionsConnectionIdPublish>>,
        TError,
        {accountId: string;connectionId: string;data: MenuPublishCreateEntity},
        TContext
      > => {

      const mutationOptions = getPostV1AccountsAccountIdConnectionsConnectionIdPublishMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * This endpoint retrieves a list of all variants associated with a specific product in a catalog at a location. The data includes variant identifiers, names, and other relevant details, providing an overview of the variants available for the product within the specified catalog. Users can use this information to manage the product's variations effectively.
 * @summary Get Product Variants
 */
export const getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants = (
    accountId: string,
    locationId: string,
    productId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetAccountProductVariantsResponse>> => {
    
    
    return axios.get(
      `/v1/accounts/${accountId}/locations/${locationId}/catalog/products/${productId}/variants`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsQueryKey = (accountId: string,
    locationId: string,
    productId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams,) => {
    return [`/v1/accounts/${accountId}/locations/${locationId}/catalog/products/${productId}/variants`, ...(params ? [params]: [])] as const;
    }

    
export const getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    productId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams['nextPageKey']>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsQueryKey(accountId,locationId,productId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams['nextPageKey']> = ({ signal, pageParam }) => getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants(accountId,locationId,productId,{...params, nextPageKey: pageParam || params?.['nextPageKey']}, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && productId),  staleTime: 30000,  ...queryOptions} as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams['nextPageKey']> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsInfiniteQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams, options: { query:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams['nextPageKey']>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams['nextPageKey']>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, QueryKey
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Product Variants
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams['nextPageKey']>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams, options?: { query?:Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError, TData, Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, QueryKey, GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams['nextPageKey']>>, axios?: AxiosRequestConfig}

  ):  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsInfiniteQueryOptions(accountId,locationId,productId,params,options)

  const query = useInfiniteQuery(queryOptions) as  UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsQueryOptions = <TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError = AxiosError<ErrorResponse>>(accountId: string,
    locationId: string,
    productId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsQueryKey(accountId,locationId,productId,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>> = ({ signal }) => getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants(accountId,locationId,productId,params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId && locationId && productId),  staleTime: 30000,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsQueryResult = NonNullable<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>>
export type GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsQueryError = AxiosError<ErrorResponse>


export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string,
    params: undefined |  GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>,
          TError,
          Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Product Variants
 */

export function useGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants<TData = Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError = AxiosError<ErrorResponse>>(
 accountId: string,
    locationId: string,
    productId: string,
    params?: GetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariants>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetV1AccountsAccountIdLocationsLocationIdCatalogProductsProductIdVariantsQueryOptions(accountId,locationId,productId,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




